syntax = "proto3";
package sqoop.solo.io;
option go_package = "github.com/solo-io/solo-projects/projects/sqoop/pkg/api/v1";

import "gogoproto/gogo.proto";
option (gogoproto.equal_all) = true;

import "github.com/solo-io/solo-kit/api/v1/metadata.proto";
import "github.com/solo-io/solo-kit/api/v1/status.proto";
import "github.com/solo-io/gloo/projects/gloo/api/v1/proxy.proto";

/*
@solo-kit:resource.short_name=rm
@solo-kit:resource.plural_name=resolver_maps
@solo-kit:resource.resource_groups=api.sqoop.solo.io

 * The ResolverMap object maps Resolvers to the fields in the GraphQL Schema
 * The skeleton of a Resolver Map will be generated by Sqoop automatically when a schema
 * is read or updated if one does not alreay exist.
*/
message ResolverMap {
    // Types is a map of Type Names (defined in the schema) to a TypeResolver, which contain resolvers for the
    // specific fields of the type
    map<string, TypeResolver> types = 3;

    // Status indicates the validation status of this resource.
    // Status is read-only by clients, and set by gloo during validation
    core.solo.io.Status status = 6 [(gogoproto.nullable) = false, (gogoproto.moretags) = "testdiff:\"ignore\""];

    // Metadata contains the object metadata for this resource
    core.solo.io.Metadata metadata = 7 [(gogoproto.nullable) = false];
}

// TypeResolver contains the individual resolvers for each field for a specific type
message TypeResolver {
    // This is a map of Field Names to the resolver that Sqoop should invoke when a query arrives for that field
    map<string, FieldResolver> fields = 1;
}

// Resolvers define the actual logic Sqoop needs to know in order to resolve a specific field query
message FieldResolver {
    // a resolver can have one of three types:
    oneof resolver {
        // a GlooResolver, which leverages Gloo to retrieve data from backend services and functions for the query
        GlooResolver gloo_resolver = 1;
        // a TemplateResolver, which uses Go Templates to generate data for the query
        TemplateResolver template_resolver = 2;
        // a NodeJSResolver, which calls NodeJS functions to return data for the query
        NodeJSResolver nodejs_resolver = 3;
    }
}

// GlooResolvers are the "meat" of Sqoop. GlooResolvers tell Sqoop how to invoke a "Gloo Function"
message GlooResolver {
    // the Request Template, if specified, will become the body of the HTTP request used to invoke a function through Gloo
    // input parameters, if needed, should be specified in the request template. See Sqoop's [Resolver documentation](TODO)
    // for more information on Request Templates.
    RequestTemplate request_template = 1;
    // The response template, if specified, will transform the body of HTTP responses returned by Gloo functions.
    // This field should be used if the object returned by the Gloo Function does not match the type specified in the GraphQL schema.
    // It can also be used to modify or transform responses from their original state. See Sqoop's [Resolver documentation](TODO)
    // for more information on Response Templates.
    ResponseTemplate response_template = 2;

    // the routing action to take when resolver is executed. usually this is a Route destination
    gloo.solo.io.RouteAction action = 4;
}

message RequestTemplate {
    string verb = 1;
    string path = 2;
    string body = 3;
    map<string, string> headers = 4;
}

message ResponseTemplate {
    string body = 2;
    map<string, string> headers = 3;
}

// A Go-template which will return data for a Resolver without making a function call. Template Resolvers can make use
// of Sqoop's builtin template functions as well as the data provided by the Params object to the resolver.
// Read more about Templates and Resolvers in Sqoop\'s [Resolver documentation](TODO).
message TemplateResolver {
    // the Go template as an inline string
    string inline_template = 1;
}

// NOTE: currently unsupported
message NodeJSResolver {
    string inline_code = 1;
}