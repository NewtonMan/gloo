// Code generated by skv2. DO NOT EDIT.

package check

import (
	"context"

	"github.com/solo-io/go-utils/stringutils"
	corev1 "github.com/solo-io/skv2/pkg/api/core.skv2.solo.io/v1"
	types2 "github.com/solo-io/solo-apis/pkg/api/gloo.solo.io/v1"
	sets "github.com/solo-io/solo-apis/pkg/api/gloo.solo.io/v1/sets"
	"github.com/solo-io/solo-projects/projects/gloo-fed/pkg/api/fed.solo.io/v1/types"
	"github.com/solo-io/solo-projects/projects/gloo-fed/pkg/discovery/translator/summarize"
)

func GetUpstreamSummary(ctx context.Context, set sets.UpstreamSet, watchedNamespaces []string, cluster string) *types.GlooInstanceSpec_Check_Summary {
	summary := &types.GlooInstanceSpec_Check_Summary{}

	for _, upstreamIter := range set.List() {
		upstream := upstreamIter

		// If the resource is not in the right cluster, continue
		if upstream.GetClusterName() != cluster {
			continue
		}

		// If the resource is not in a watched namespace, continue
		if len(watchedNamespaces) > 0 && !stringutils.ContainsString(upstream.Namespace, watchedNamespaces) {
			continue
		}

		summary.Total += 1

		if upstream.Status.GetState() == types2.UpstreamStatus_Rejected {
			summary.Errors = append(summary.Errors, &types.GlooInstanceSpec_Check_Summary_ResourceReport{
				Ref: &corev1.ObjectRef{
					Name:      upstream.Name,
					Namespace: upstream.Namespace,
				},
				Message: upstream.Status.Reason,
			})
		}

		if upstream.Status.GetState() == types2.UpstreamStatus_Warning {
			summary.Warnings = append(summary.Warnings, &types.GlooInstanceSpec_Check_Summary_ResourceReport{
				Ref: &corev1.ObjectRef{
					Name:      upstream.Name,
					Namespace: upstream.Namespace,
				},
				Message: upstream.Status.Reason,
			})
		}

	}

	summarize.SortLists(summary)
	return summary
}

func GetUpstreamGroupSummary(ctx context.Context, set sets.UpstreamGroupSet, watchedNamespaces []string, cluster string) *types.GlooInstanceSpec_Check_Summary {
	summary := &types.GlooInstanceSpec_Check_Summary{}

	for _, upstreamGroupIter := range set.List() {
		upstreamGroup := upstreamGroupIter

		// If the resource is not in the right cluster, continue
		if upstreamGroup.GetClusterName() != cluster {
			continue
		}

		// If the resource is not in a watched namespace, continue
		if len(watchedNamespaces) > 0 && !stringutils.ContainsString(upstreamGroup.Namespace, watchedNamespaces) {
			continue
		}

		summary.Total += 1

		if upstreamGroup.Status.GetState() == types2.UpstreamGroupStatus_Rejected {
			summary.Errors = append(summary.Errors, &types.GlooInstanceSpec_Check_Summary_ResourceReport{
				Ref: &corev1.ObjectRef{
					Name:      upstreamGroup.Name,
					Namespace: upstreamGroup.Namespace,
				},
				Message: upstreamGroup.Status.Reason,
			})
		}

		if upstreamGroup.Status.GetState() == types2.UpstreamGroupStatus_Warning {
			summary.Warnings = append(summary.Warnings, &types.GlooInstanceSpec_Check_Summary_ResourceReport{
				Ref: &corev1.ObjectRef{
					Name:      upstreamGroup.Name,
					Namespace: upstreamGroup.Namespace,
				},
				Message: upstreamGroup.Status.Reason,
			})
		}

	}

	summarize.SortLists(summary)
	return summary
}

func GetSettingsSummary(ctx context.Context, set sets.SettingsSet, watchedNamespaces []string, cluster string) *types.GlooInstanceSpec_Check_Summary {
	summary := &types.GlooInstanceSpec_Check_Summary{}

	for _, settingsIter := range set.List() {
		settings := settingsIter

		// If the resource is not in the right cluster, continue
		if settings.GetClusterName() != cluster {
			continue
		}

		// If the resource is not in a watched namespace, continue
		if len(watchedNamespaces) > 0 && !stringutils.ContainsString(settings.Namespace, watchedNamespaces) {
			continue
		}

		summary.Total += 1

		if settings.Status.GetState() == types2.SettingsStatus_Rejected {
			summary.Errors = append(summary.Errors, &types.GlooInstanceSpec_Check_Summary_ResourceReport{
				Ref: &corev1.ObjectRef{
					Name:      settings.Name,
					Namespace: settings.Namespace,
				},
				Message: settings.Status.Reason,
			})
		}

		if settings.Status.GetState() == types2.SettingsStatus_Warning {
			summary.Warnings = append(summary.Warnings, &types.GlooInstanceSpec_Check_Summary_ResourceReport{
				Ref: &corev1.ObjectRef{
					Name:      settings.Name,
					Namespace: settings.Namespace,
				},
				Message: settings.Status.Reason,
			})
		}

	}

	summarize.SortLists(summary)
	return summary
}

func GetProxySummary(ctx context.Context, set sets.ProxySet, watchedNamespaces []string, cluster string) *types.GlooInstanceSpec_Check_Summary {
	summary := &types.GlooInstanceSpec_Check_Summary{}

	for _, proxyIter := range set.List() {
		proxy := proxyIter

		// If the resource is not in the right cluster, continue
		if proxy.GetClusterName() != cluster {
			continue
		}

		// If the resource is not in a watched namespace, continue
		if len(watchedNamespaces) > 0 && !stringutils.ContainsString(proxy.Namespace, watchedNamespaces) {
			continue
		}

		summary.Total += 1

		if proxy.Status.GetState() == types2.ProxyStatus_Rejected {
			summary.Errors = append(summary.Errors, &types.GlooInstanceSpec_Check_Summary_ResourceReport{
				Ref: &corev1.ObjectRef{
					Name:      proxy.Name,
					Namespace: proxy.Namespace,
				},
				Message: proxy.Status.Reason,
			})
		}

		if proxy.Status.GetState() == types2.ProxyStatus_Warning {
			summary.Warnings = append(summary.Warnings, &types.GlooInstanceSpec_Check_Summary_ResourceReport{
				Ref: &corev1.ObjectRef{
					Name:      proxy.Name,
					Namespace: proxy.Namespace,
				},
				Message: proxy.Status.Reason,
			})
		}

	}

	summarize.SortLists(summary)
	return summary
}
