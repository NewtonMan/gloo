// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./snapshot.go -destination mocks/snapshot.go

// The Input Snapshot contains the set of all:
// * Services
// * Pods
// * Deployments
// * DaemonSets
// * Gateways
// * MatchableHttpGateways
// * VirtualServices
// * RouteTables
// * Upstreams
// * UpstreamGroups
// * Settings
// * Proxies
// * AuthConfigs
// * RateLimitConfigs
// read from a given cluster or set of clusters, across all namespaces.
//
// A snapshot can be constructed from either a single Manager (for a single cluster)
// or a ClusterWatcher (for multiple clusters) using the SnapshotBuilder.
//
// Resources in a MultiCluster snapshot will have their ClusterName set to the
// name of the cluster from which the resource was read.

package input

import (
	"context"
	"encoding/json"

	snapshotutils "github.com/solo-io/skv2/contrib/pkg/snapshot"

	"github.com/solo-io/go-utils/contextutils"
	"github.com/solo-io/skv2/pkg/ezkube"
	"github.com/solo-io/skv2/pkg/resource"
	"github.com/solo-io/skv2/pkg/verifier"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/apimachinery/pkg/runtime/schema"

	"github.com/hashicorp/go-multierror"

	sk_sets "github.com/solo-io/skv2/contrib/pkg/sets/v2"
	sk_client "github.com/solo-io/skv2/pkg/client"
	"github.com/solo-io/skv2/pkg/controllerutils"
	"github.com/solo-io/skv2/pkg/multicluster"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/manager"

	v1_types "k8s.io/api/core/v1"

	apps_v1_types "k8s.io/api/apps/v1"

	gateway_solo_io_v1_types "github.com/solo-io/solo-apis/pkg/api/gateway.solo.io/v1"

	gloo_solo_io_v1_types "github.com/solo-io/solo-apis/pkg/api/gloo.solo.io/v1"

	enterprise_gloo_solo_io_v1_types "github.com/solo-io/solo-apis/pkg/api/enterprise.gloo.solo.io/v1"

	ratelimit_api_solo_io_v1alpha1_types "github.com/solo-io/solo-apis/pkg/api/ratelimit.solo.io/v1alpha1"
)

// SnapshotGVKs is a list of the GVKs included in this snapshot
var SnapshotGVKs = []schema.GroupVersionKind{
	schema.GroupVersionKind{
		Group:   "",
		Version: "v1",
		Kind:    "Service",
	},
	schema.GroupVersionKind{
		Group:   "",
		Version: "v1",
		Kind:    "Pod",
	},
	schema.GroupVersionKind{
		Group:   "apps",
		Version: "v1",
		Kind:    "Deployment",
	},
	schema.GroupVersionKind{
		Group:   "apps",
		Version: "v1",
		Kind:    "DaemonSet",
	},
	schema.GroupVersionKind{
		Group:   "gateway.solo.io",
		Version: "v1",
		Kind:    "Gateway",
	},
	schema.GroupVersionKind{
		Group:   "gateway.solo.io",
		Version: "v1",
		Kind:    "MatchableHttpGateway",
	},
	schema.GroupVersionKind{
		Group:   "gateway.solo.io",
		Version: "v1",
		Kind:    "VirtualService",
	},
	schema.GroupVersionKind{
		Group:   "gateway.solo.io",
		Version: "v1",
		Kind:    "RouteTable",
	},
	schema.GroupVersionKind{
		Group:   "gloo.solo.io",
		Version: "v1",
		Kind:    "Upstream",
	},
	schema.GroupVersionKind{
		Group:   "gloo.solo.io",
		Version: "v1",
		Kind:    "UpstreamGroup",
	},
	schema.GroupVersionKind{
		Group:   "gloo.solo.io",
		Version: "v1",
		Kind:    "Settings",
	},
	schema.GroupVersionKind{
		Group:   "gloo.solo.io",
		Version: "v1",
		Kind:    "Proxy",
	},
	schema.GroupVersionKind{
		Group:   "enterprise.gloo.solo.io",
		Version: "v1",
		Kind:    "AuthConfig",
	},
	schema.GroupVersionKind{
		Group:   "ratelimit.api.solo.io",
		Version: "v1alpha1",
		Kind:    "RateLimitConfig",
	},
}

// the snapshot of input resources consumed by translation
type Snapshot interface {

	// return the set of input Services
	Services() sk_sets.ResourceSet[*v1_types.Service]
	// return the set of input Pods
	Pods() sk_sets.ResourceSet[*v1_types.Pod]

	// return the set of input Deployments
	Deployments() sk_sets.ResourceSet[*apps_v1_types.Deployment]
	// return the set of input DaemonSets
	DaemonSets() sk_sets.ResourceSet[*apps_v1_types.DaemonSet]

	// return the set of input Gateways
	Gateways() sk_sets.ResourceSet[*gateway_solo_io_v1_types.Gateway]
	// return the set of input MatchableHttpGateways
	MatchableHttpGateways() sk_sets.ResourceSet[*gateway_solo_io_v1_types.MatchableHttpGateway]
	// return the set of input VirtualServices
	VirtualServices() sk_sets.ResourceSet[*gateway_solo_io_v1_types.VirtualService]
	// return the set of input RouteTables
	RouteTables() sk_sets.ResourceSet[*gateway_solo_io_v1_types.RouteTable]

	// return the set of input Upstreams
	Upstreams() sk_sets.ResourceSet[*gloo_solo_io_v1_types.Upstream]
	// return the set of input UpstreamGroups
	UpstreamGroups() sk_sets.ResourceSet[*gloo_solo_io_v1_types.UpstreamGroup]
	// return the set of input Settings
	Settings() sk_sets.ResourceSet[*gloo_solo_io_v1_types.Settings]
	// return the set of input Proxies
	Proxies() sk_sets.ResourceSet[*gloo_solo_io_v1_types.Proxy]

	// return the set of input AuthConfigs
	AuthConfigs() sk_sets.ResourceSet[*enterprise_gloo_solo_io_v1_types.AuthConfig]

	// return the set of input RateLimitConfigs
	RateLimitConfigs() sk_sets.ResourceSet[*ratelimit_api_solo_io_v1alpha1_types.RateLimitConfig]
	// update the status of all input objects which support
	// the Status subresource (across multiple clusters)
	SyncStatusesMultiCluster(ctx context.Context, mcClient multicluster.Client, opts SyncStatusOptions) error
	// update the status of all input objects which support
	// the Status subresource (in the local cluster)
	SyncStatuses(ctx context.Context, c client.Client, opts SyncStatusOptions) error
	// serialize the entire snapshot as JSON
	MarshalJSON() ([]byte, error)

	// Clone the snapshot
	Clone() Snapshot

	// convert this snapshot to its generic form.
	Generic() resource.ClusterSnapshot

	// iterate over the objects contained in the snapshot
	ForEachObject(handleObject func(cluster string, gvk schema.GroupVersionKind, obj resource.TypedObject))
}

// options for syncing input object statuses
type SyncStatusOptions struct {

	// sync status of Service objects
	Service bool
	// sync status of Pod objects
	Pod bool
	// sync status of Deployment objects
	Deployment bool
	// sync status of DaemonSet objects
	DaemonSet bool
	// sync status of Gateway objects
	Gateway bool
	// sync status of MatchableHttpGateway objects
	MatchableHttpGateway bool
	// sync status of VirtualService objects
	VirtualService bool
	// sync status of RouteTable objects
	RouteTable bool
	// sync status of Upstream objects
	Upstream bool
	// sync status of UpstreamGroup objects
	UpstreamGroup bool
	// sync status of Settings objects
	Settings bool
	// sync status of Proxy objects
	Proxy bool
	// sync status of AuthConfig objects
	AuthConfig bool
	// sync status of RateLimitConfig objects
	RateLimitConfig bool
}

type snapshot struct {
	name string

	services sk_sets.ResourceSet[*v1_types.Service]
	pods     sk_sets.ResourceSet[*v1_types.Pod]

	deployments sk_sets.ResourceSet[*apps_v1_types.Deployment]
	daemonSets  sk_sets.ResourceSet[*apps_v1_types.DaemonSet]

	gateways              sk_sets.ResourceSet[*gateway_solo_io_v1_types.Gateway]
	matchableHttpGateways sk_sets.ResourceSet[*gateway_solo_io_v1_types.MatchableHttpGateway]
	virtualServices       sk_sets.ResourceSet[*gateway_solo_io_v1_types.VirtualService]
	routeTables           sk_sets.ResourceSet[*gateway_solo_io_v1_types.RouteTable]

	upstreams      sk_sets.ResourceSet[*gloo_solo_io_v1_types.Upstream]
	upstreamGroups sk_sets.ResourceSet[*gloo_solo_io_v1_types.UpstreamGroup]
	settings       sk_sets.ResourceSet[*gloo_solo_io_v1_types.Settings]
	proxies        sk_sets.ResourceSet[*gloo_solo_io_v1_types.Proxy]

	authConfigs sk_sets.ResourceSet[*enterprise_gloo_solo_io_v1_types.AuthConfig]

	rateLimitConfigs sk_sets.ResourceSet[*ratelimit_api_solo_io_v1alpha1_types.RateLimitConfig]
}

func NewSnapshot(
	name string,

	services sk_sets.ResourceSet[*v1_types.Service],
	pods sk_sets.ResourceSet[*v1_types.Pod],

	deployments sk_sets.ResourceSet[*apps_v1_types.Deployment],
	daemonSets sk_sets.ResourceSet[*apps_v1_types.DaemonSet],

	gateways sk_sets.ResourceSet[*gateway_solo_io_v1_types.Gateway],
	matchableHttpGateways sk_sets.ResourceSet[*gateway_solo_io_v1_types.MatchableHttpGateway],
	virtualServices sk_sets.ResourceSet[*gateway_solo_io_v1_types.VirtualService],
	routeTables sk_sets.ResourceSet[*gateway_solo_io_v1_types.RouteTable],

	upstreams sk_sets.ResourceSet[*gloo_solo_io_v1_types.Upstream],
	upstreamGroups sk_sets.ResourceSet[*gloo_solo_io_v1_types.UpstreamGroup],
	settings sk_sets.ResourceSet[*gloo_solo_io_v1_types.Settings],
	proxies sk_sets.ResourceSet[*gloo_solo_io_v1_types.Proxy],

	authConfigs sk_sets.ResourceSet[*enterprise_gloo_solo_io_v1_types.AuthConfig],

	rateLimitConfigs sk_sets.ResourceSet[*ratelimit_api_solo_io_v1alpha1_types.RateLimitConfig],

) Snapshot {
	return &snapshot{
		name: name,

		services:              services,
		pods:                  pods,
		deployments:           deployments,
		daemonSets:            daemonSets,
		gateways:              gateways,
		matchableHttpGateways: matchableHttpGateways,
		virtualServices:       virtualServices,
		routeTables:           routeTables,
		upstreams:             upstreams,
		upstreamGroups:        upstreamGroups,
		settings:              settings,
		proxies:               proxies,
		authConfigs:           authConfigs,
		rateLimitConfigs:      rateLimitConfigs,
	}
}

func NewSnapshotFromGeneric(
	name string,
	genericSnapshot resource.ClusterSnapshot,
) Snapshot {

	serviceSet := sk_sets.NewResourceSet[*v1_types.Service]()
	podSet := sk_sets.NewResourceSet[*v1_types.Pod]()

	deploymentSet := sk_sets.NewResourceSet[*apps_v1_types.Deployment]()
	daemonSetSet := sk_sets.NewResourceSet[*apps_v1_types.DaemonSet]()

	gatewaySet := sk_sets.NewResourceSet[*gateway_solo_io_v1_types.Gateway]()
	matchableHttpGatewaySet := sk_sets.NewResourceSet[*gateway_solo_io_v1_types.MatchableHttpGateway]()
	virtualServiceSet := sk_sets.NewResourceSet[*gateway_solo_io_v1_types.VirtualService]()
	routeTableSet := sk_sets.NewResourceSet[*gateway_solo_io_v1_types.RouteTable]()

	upstreamSet := sk_sets.NewResourceSet[*gloo_solo_io_v1_types.Upstream]()
	upstreamGroupSet := sk_sets.NewResourceSet[*gloo_solo_io_v1_types.UpstreamGroup]()
	settingsSet := sk_sets.NewResourceSet[*gloo_solo_io_v1_types.Settings]()
	proxySet := sk_sets.NewResourceSet[*gloo_solo_io_v1_types.Proxy]()

	authConfigSet := sk_sets.NewResourceSet[*enterprise_gloo_solo_io_v1_types.AuthConfig]()

	rateLimitConfigSet := sk_sets.NewResourceSet[*ratelimit_api_solo_io_v1alpha1_types.RateLimitConfig]()

	for _, snapshot := range genericSnapshot {

		services := snapshot[schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Service",
		}]

		for _, service := range services {
			serviceSet.Insert(service.(*v1_types.Service))
		}
		pods := snapshot[schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Pod",
		}]

		for _, pod := range pods {
			podSet.Insert(pod.(*v1_types.Pod))
		}

		deployments := snapshot[schema.GroupVersionKind{
			Group:   "apps",
			Version: "v1",
			Kind:    "Deployment",
		}]

		for _, deployment := range deployments {
			deploymentSet.Insert(deployment.(*apps_v1_types.Deployment))
		}
		daemonSets := snapshot[schema.GroupVersionKind{
			Group:   "apps",
			Version: "v1",
			Kind:    "DaemonSet",
		}]

		for _, daemonSet := range daemonSets {
			daemonSetSet.Insert(daemonSet.(*apps_v1_types.DaemonSet))
		}

		gateways := snapshot[schema.GroupVersionKind{
			Group:   "gateway.solo.io",
			Version: "v1",
			Kind:    "Gateway",
		}]

		for _, gateway := range gateways {
			gatewaySet.Insert(gateway.(*gateway_solo_io_v1_types.Gateway))
		}
		matchableHttpGateways := snapshot[schema.GroupVersionKind{
			Group:   "gateway.solo.io",
			Version: "v1",
			Kind:    "MatchableHttpGateway",
		}]

		for _, matchableHttpGateway := range matchableHttpGateways {
			matchableHttpGatewaySet.Insert(matchableHttpGateway.(*gateway_solo_io_v1_types.MatchableHttpGateway))
		}
		virtualServices := snapshot[schema.GroupVersionKind{
			Group:   "gateway.solo.io",
			Version: "v1",
			Kind:    "VirtualService",
		}]

		for _, virtualService := range virtualServices {
			virtualServiceSet.Insert(virtualService.(*gateway_solo_io_v1_types.VirtualService))
		}
		routeTables := snapshot[schema.GroupVersionKind{
			Group:   "gateway.solo.io",
			Version: "v1",
			Kind:    "RouteTable",
		}]

		for _, routeTable := range routeTables {
			routeTableSet.Insert(routeTable.(*gateway_solo_io_v1_types.RouteTable))
		}

		upstreams := snapshot[schema.GroupVersionKind{
			Group:   "gloo.solo.io",
			Version: "v1",
			Kind:    "Upstream",
		}]

		for _, upstream := range upstreams {
			upstreamSet.Insert(upstream.(*gloo_solo_io_v1_types.Upstream))
		}
		upstreamGroups := snapshot[schema.GroupVersionKind{
			Group:   "gloo.solo.io",
			Version: "v1",
			Kind:    "UpstreamGroup",
		}]

		for _, upstreamGroup := range upstreamGroups {
			upstreamGroupSet.Insert(upstreamGroup.(*gloo_solo_io_v1_types.UpstreamGroup))
		}
		settings := snapshot[schema.GroupVersionKind{
			Group:   "gloo.solo.io",
			Version: "v1",
			Kind:    "Settings",
		}]

		for _, settings := range settings {
			settingsSet.Insert(settings.(*gloo_solo_io_v1_types.Settings))
		}
		proxies := snapshot[schema.GroupVersionKind{
			Group:   "gloo.solo.io",
			Version: "v1",
			Kind:    "Proxy",
		}]

		for _, proxy := range proxies {
			proxySet.Insert(proxy.(*gloo_solo_io_v1_types.Proxy))
		}

		authConfigs := snapshot[schema.GroupVersionKind{
			Group:   "enterprise.gloo.solo.io",
			Version: "v1",
			Kind:    "AuthConfig",
		}]

		for _, authConfig := range authConfigs {
			authConfigSet.Insert(authConfig.(*enterprise_gloo_solo_io_v1_types.AuthConfig))
		}

		rateLimitConfigs := snapshot[schema.GroupVersionKind{
			Group:   "ratelimit.api.solo.io",
			Version: "v1alpha1",
			Kind:    "RateLimitConfig",
		}]

		for _, rateLimitConfig := range rateLimitConfigs {
			rateLimitConfigSet.Insert(rateLimitConfig.(*ratelimit_api_solo_io_v1alpha1_types.RateLimitConfig))
		}

	}
	return NewSnapshot(
		name,
		serviceSet,
		podSet,
		deploymentSet,
		daemonSetSet,
		gatewaySet,
		matchableHttpGatewaySet,
		virtualServiceSet,
		routeTableSet,
		upstreamSet,
		upstreamGroupSet,
		settingsSet,
		proxySet,
		authConfigSet,
		rateLimitConfigSet,
	)
}

func (s *snapshot) Services() sk_sets.ResourceSet[*v1_types.Service] {
	return s.services
}

func (s *snapshot) Pods() sk_sets.ResourceSet[*v1_types.Pod] {
	return s.pods
}

func (s *snapshot) Deployments() sk_sets.ResourceSet[*apps_v1_types.Deployment] {
	return s.deployments
}

func (s *snapshot) DaemonSets() sk_sets.ResourceSet[*apps_v1_types.DaemonSet] {
	return s.daemonSets
}

func (s *snapshot) Gateways() sk_sets.ResourceSet[*gateway_solo_io_v1_types.Gateway] {
	return s.gateways
}

func (s *snapshot) MatchableHttpGateways() sk_sets.ResourceSet[*gateway_solo_io_v1_types.MatchableHttpGateway] {
	return s.matchableHttpGateways
}

func (s *snapshot) VirtualServices() sk_sets.ResourceSet[*gateway_solo_io_v1_types.VirtualService] {
	return s.virtualServices
}

func (s *snapshot) RouteTables() sk_sets.ResourceSet[*gateway_solo_io_v1_types.RouteTable] {
	return s.routeTables
}

func (s *snapshot) Upstreams() sk_sets.ResourceSet[*gloo_solo_io_v1_types.Upstream] {
	return s.upstreams
}

func (s *snapshot) UpstreamGroups() sk_sets.ResourceSet[*gloo_solo_io_v1_types.UpstreamGroup] {
	return s.upstreamGroups
}

func (s *snapshot) Settings() sk_sets.ResourceSet[*gloo_solo_io_v1_types.Settings] {
	return s.settings
}

func (s *snapshot) Proxies() sk_sets.ResourceSet[*gloo_solo_io_v1_types.Proxy] {
	return s.proxies
}

func (s *snapshot) AuthConfigs() sk_sets.ResourceSet[*enterprise_gloo_solo_io_v1_types.AuthConfig] {
	return s.authConfigs
}

func (s *snapshot) RateLimitConfigs() sk_sets.ResourceSet[*ratelimit_api_solo_io_v1alpha1_types.RateLimitConfig] {
	return s.rateLimitConfigs
}

func (s *snapshot) SyncStatusesMultiCluster(ctx context.Context, mcClient multicluster.Client, opts SyncStatusOptions) error {
	var errs error

	if opts.Gateway {
		for _, obj := range s.Gateways().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatusImmutable(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.MatchableHttpGateway {
		for _, obj := range s.MatchableHttpGateways().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatusImmutable(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.VirtualService {
		for _, obj := range s.VirtualServices().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatusImmutable(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.RouteTable {
		for _, obj := range s.RouteTables().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatusImmutable(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.Upstream {
		for _, obj := range s.Upstreams().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatusImmutable(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.UpstreamGroup {
		for _, obj := range s.UpstreamGroups().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatusImmutable(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.Settings {
		for _, obj := range s.Settings().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatusImmutable(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.Proxy {
		for _, obj := range s.Proxies().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatusImmutable(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.AuthConfig {
		for _, obj := range s.AuthConfigs().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatusImmutable(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.RateLimitConfig {
		for _, obj := range s.RateLimitConfigs().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatusImmutable(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	return errs
}

func (s *snapshot) SyncStatuses(ctx context.Context, c client.Client, opts SyncStatusOptions) error {
	var errs error

	if opts.Gateway {
		for _, obj := range s.Gateways().List() {
			if _, err := controllerutils.UpdateStatusImmutable(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.MatchableHttpGateway {
		for _, obj := range s.MatchableHttpGateways().List() {
			if _, err := controllerutils.UpdateStatusImmutable(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.VirtualService {
		for _, obj := range s.VirtualServices().List() {
			if _, err := controllerutils.UpdateStatusImmutable(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.RouteTable {
		for _, obj := range s.RouteTables().List() {
			if _, err := controllerutils.UpdateStatusImmutable(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.Upstream {
		for _, obj := range s.Upstreams().List() {
			if _, err := controllerutils.UpdateStatusImmutable(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.UpstreamGroup {
		for _, obj := range s.UpstreamGroups().List() {
			if _, err := controllerutils.UpdateStatusImmutable(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.Settings {
		for _, obj := range s.Settings().List() {
			if _, err := controllerutils.UpdateStatusImmutable(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.Proxy {
		for _, obj := range s.Proxies().List() {
			if _, err := controllerutils.UpdateStatusImmutable(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.AuthConfig {
		for _, obj := range s.AuthConfigs().List() {
			if _, err := controllerutils.UpdateStatusImmutable(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.RateLimitConfig {
		for _, obj := range s.RateLimitConfigs().List() {
			if _, err := controllerutils.UpdateStatusImmutable(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	return errs
}

func (s *snapshot) MarshalJSON() ([]byte, error) {
	snapshotMap := map[string]interface{}{"name": s.name}

	serviceSet := sk_sets.NewResourceSet[*v1_types.Service]()
	for _, obj := range s.services.UnsortedList() {
		// redact secret data from the snapshot
		obj := snapshotutils.RedactSecretData(obj)
		serviceSet.Insert(obj.(*v1_types.Service))
	}
	snapshotMap["services"] = serviceSet.List()
	podSet := sk_sets.NewResourceSet[*v1_types.Pod]()
	for _, obj := range s.pods.UnsortedList() {
		// redact secret data from the snapshot
		obj := snapshotutils.RedactSecretData(obj)
		podSet.Insert(obj.(*v1_types.Pod))
	}
	snapshotMap["pods"] = podSet.List()
	deploymentSet := sk_sets.NewResourceSet[*apps_v1_types.Deployment]()
	for _, obj := range s.deployments.UnsortedList() {
		// redact secret data from the snapshot
		obj := snapshotutils.RedactSecretData(obj)
		deploymentSet.Insert(obj.(*apps_v1_types.Deployment))
	}
	snapshotMap["deployments"] = deploymentSet.List()
	daemonSetSet := sk_sets.NewResourceSet[*apps_v1_types.DaemonSet]()
	for _, obj := range s.daemonSets.UnsortedList() {
		// redact secret data from the snapshot
		obj := snapshotutils.RedactSecretData(obj)
		daemonSetSet.Insert(obj.(*apps_v1_types.DaemonSet))
	}
	snapshotMap["daemonSets"] = daemonSetSet.List()
	gatewaySet := sk_sets.NewResourceSet[*gateway_solo_io_v1_types.Gateway]()
	for _, obj := range s.gateways.UnsortedList() {
		// redact secret data from the snapshot
		obj := snapshotutils.RedactSecretData(obj)
		gatewaySet.Insert(obj.(*gateway_solo_io_v1_types.Gateway))
	}
	snapshotMap["gateways"] = gatewaySet.List()
	matchableHttpGatewaySet := sk_sets.NewResourceSet[*gateway_solo_io_v1_types.MatchableHttpGateway]()
	for _, obj := range s.matchableHttpGateways.UnsortedList() {
		// redact secret data from the snapshot
		obj := snapshotutils.RedactSecretData(obj)
		matchableHttpGatewaySet.Insert(obj.(*gateway_solo_io_v1_types.MatchableHttpGateway))
	}
	snapshotMap["matchableHttpGateways"] = matchableHttpGatewaySet.List()
	virtualServiceSet := sk_sets.NewResourceSet[*gateway_solo_io_v1_types.VirtualService]()
	for _, obj := range s.virtualServices.UnsortedList() {
		// redact secret data from the snapshot
		obj := snapshotutils.RedactSecretData(obj)
		virtualServiceSet.Insert(obj.(*gateway_solo_io_v1_types.VirtualService))
	}
	snapshotMap["virtualServices"] = virtualServiceSet.List()
	routeTableSet := sk_sets.NewResourceSet[*gateway_solo_io_v1_types.RouteTable]()
	for _, obj := range s.routeTables.UnsortedList() {
		// redact secret data from the snapshot
		obj := snapshotutils.RedactSecretData(obj)
		routeTableSet.Insert(obj.(*gateway_solo_io_v1_types.RouteTable))
	}
	snapshotMap["routeTables"] = routeTableSet.List()
	upstreamSet := sk_sets.NewResourceSet[*gloo_solo_io_v1_types.Upstream]()
	for _, obj := range s.upstreams.UnsortedList() {
		// redact secret data from the snapshot
		obj := snapshotutils.RedactSecretData(obj)
		upstreamSet.Insert(obj.(*gloo_solo_io_v1_types.Upstream))
	}
	snapshotMap["upstreams"] = upstreamSet.List()
	upstreamGroupSet := sk_sets.NewResourceSet[*gloo_solo_io_v1_types.UpstreamGroup]()
	for _, obj := range s.upstreamGroups.UnsortedList() {
		// redact secret data from the snapshot
		obj := snapshotutils.RedactSecretData(obj)
		upstreamGroupSet.Insert(obj.(*gloo_solo_io_v1_types.UpstreamGroup))
	}
	snapshotMap["upstreamGroups"] = upstreamGroupSet.List()
	settingsSet := sk_sets.NewResourceSet[*gloo_solo_io_v1_types.Settings]()
	for _, obj := range s.settings.UnsortedList() {
		// redact secret data from the snapshot
		obj := snapshotutils.RedactSecretData(obj)
		settingsSet.Insert(obj.(*gloo_solo_io_v1_types.Settings))
	}
	snapshotMap["settings"] = settingsSet.List()
	proxySet := sk_sets.NewResourceSet[*gloo_solo_io_v1_types.Proxy]()
	for _, obj := range s.proxies.UnsortedList() {
		// redact secret data from the snapshot
		obj := snapshotutils.RedactSecretData(obj)
		proxySet.Insert(obj.(*gloo_solo_io_v1_types.Proxy))
	}
	snapshotMap["proxies"] = proxySet.List()
	authConfigSet := sk_sets.NewResourceSet[*enterprise_gloo_solo_io_v1_types.AuthConfig]()
	for _, obj := range s.authConfigs.UnsortedList() {
		// redact secret data from the snapshot
		obj := snapshotutils.RedactSecretData(obj)
		authConfigSet.Insert(obj.(*enterprise_gloo_solo_io_v1_types.AuthConfig))
	}
	snapshotMap["authConfigs"] = authConfigSet.List()
	rateLimitConfigSet := sk_sets.NewResourceSet[*ratelimit_api_solo_io_v1alpha1_types.RateLimitConfig]()
	for _, obj := range s.rateLimitConfigs.UnsortedList() {
		// redact secret data from the snapshot
		obj := snapshotutils.RedactSecretData(obj)
		rateLimitConfigSet.Insert(obj.(*ratelimit_api_solo_io_v1alpha1_types.RateLimitConfig))
	}
	snapshotMap["rateLimitConfigs"] = rateLimitConfigSet.List()
	return json.Marshal(snapshotMap)
}

func (s *snapshot) Clone() Snapshot {
	return &snapshot{
		name: s.name,

		services:              s.services.Clone(),
		pods:                  s.pods.Clone(),
		deployments:           s.deployments.Clone(),
		daemonSets:            s.daemonSets.Clone(),
		gateways:              s.gateways.Clone(),
		matchableHttpGateways: s.matchableHttpGateways.Clone(),
		virtualServices:       s.virtualServices.Clone(),
		routeTables:           s.routeTables.Clone(),
		upstreams:             s.upstreams.Clone(),
		upstreamGroups:        s.upstreamGroups.Clone(),
		settings:              s.settings.Clone(),
		proxies:               s.proxies.Clone(),
		authConfigs:           s.authConfigs.Clone(),
		rateLimitConfigs:      s.rateLimitConfigs.Clone(),
	}
}

func (s *snapshot) Generic() resource.ClusterSnapshot {
	clusterSnapshots := resource.ClusterSnapshot{}
	s.ForEachObject(func(cluster string, gvk schema.GroupVersionKind, obj resource.TypedObject) {
		clusterSnapshots.Insert(cluster, gvk, obj)
	})

	return clusterSnapshots
}

// convert this snapshot to its generic form
func (s *snapshot) ForEachObject(handleObject func(cluster string, gvk schema.GroupVersionKind, obj resource.TypedObject)) {
	for _, obj := range s.services.List() {
		cluster := ezkube.GetClusterName(obj)
		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Service",
		}
		handleObject(cluster, gvk, obj)
	}
	for _, obj := range s.pods.List() {
		cluster := ezkube.GetClusterName(obj)
		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Pod",
		}
		handleObject(cluster, gvk, obj)
	}
	for _, obj := range s.deployments.List() {
		cluster := ezkube.GetClusterName(obj)
		gvk := schema.GroupVersionKind{
			Group:   "apps",
			Version: "v1",
			Kind:    "Deployment",
		}
		handleObject(cluster, gvk, obj)
	}
	for _, obj := range s.daemonSets.List() {
		cluster := ezkube.GetClusterName(obj)
		gvk := schema.GroupVersionKind{
			Group:   "apps",
			Version: "v1",
			Kind:    "DaemonSet",
		}
		handleObject(cluster, gvk, obj)
	}
	for _, obj := range s.gateways.List() {
		cluster := ezkube.GetClusterName(obj)
		gvk := schema.GroupVersionKind{
			Group:   "gateway.solo.io",
			Version: "v1",
			Kind:    "Gateway",
		}
		handleObject(cluster, gvk, obj)
	}
	for _, obj := range s.matchableHttpGateways.List() {
		cluster := ezkube.GetClusterName(obj)
		gvk := schema.GroupVersionKind{
			Group:   "gateway.solo.io",
			Version: "v1",
			Kind:    "MatchableHttpGateway",
		}
		handleObject(cluster, gvk, obj)
	}
	for _, obj := range s.virtualServices.List() {
		cluster := ezkube.GetClusterName(obj)
		gvk := schema.GroupVersionKind{
			Group:   "gateway.solo.io",
			Version: "v1",
			Kind:    "VirtualService",
		}
		handleObject(cluster, gvk, obj)
	}
	for _, obj := range s.routeTables.List() {
		cluster := ezkube.GetClusterName(obj)
		gvk := schema.GroupVersionKind{
			Group:   "gateway.solo.io",
			Version: "v1",
			Kind:    "RouteTable",
		}
		handleObject(cluster, gvk, obj)
	}
	for _, obj := range s.upstreams.List() {
		cluster := ezkube.GetClusterName(obj)
		gvk := schema.GroupVersionKind{
			Group:   "gloo.solo.io",
			Version: "v1",
			Kind:    "Upstream",
		}
		handleObject(cluster, gvk, obj)
	}
	for _, obj := range s.upstreamGroups.List() {
		cluster := ezkube.GetClusterName(obj)
		gvk := schema.GroupVersionKind{
			Group:   "gloo.solo.io",
			Version: "v1",
			Kind:    "UpstreamGroup",
		}
		handleObject(cluster, gvk, obj)
	}
	for _, obj := range s.settings.List() {
		cluster := ezkube.GetClusterName(obj)
		gvk := schema.GroupVersionKind{
			Group:   "gloo.solo.io",
			Version: "v1",
			Kind:    "Settings",
		}
		handleObject(cluster, gvk, obj)
	}
	for _, obj := range s.proxies.List() {
		cluster := ezkube.GetClusterName(obj)
		gvk := schema.GroupVersionKind{
			Group:   "gloo.solo.io",
			Version: "v1",
			Kind:    "Proxy",
		}
		handleObject(cluster, gvk, obj)
	}
	for _, obj := range s.authConfigs.List() {
		cluster := ezkube.GetClusterName(obj)
		gvk := schema.GroupVersionKind{
			Group:   "enterprise.gloo.solo.io",
			Version: "v1",
			Kind:    "AuthConfig",
		}
		handleObject(cluster, gvk, obj)
	}
	for _, obj := range s.rateLimitConfigs.List() {
		cluster := ezkube.GetClusterName(obj)
		gvk := schema.GroupVersionKind{
			Group:   "ratelimit.api.solo.io",
			Version: "v1alpha1",
			Kind:    "RateLimitConfig",
		}
		handleObject(cluster, gvk, obj)
	}
}

// builds the input snapshot from API Clients.
type Builder interface {
	BuildSnapshot(ctx context.Context, name string, opts BuildOptions) (Snapshot, error)
}

// Options for building a snapshot
type BuildOptions struct {

	// List options for composing a snapshot from Services
	Services ResourceBuildOptions
	// List options for composing a snapshot from Pods
	Pods ResourceBuildOptions

	// List options for composing a snapshot from Deployments
	Deployments ResourceBuildOptions
	// List options for composing a snapshot from DaemonSets
	DaemonSets ResourceBuildOptions

	// List options for composing a snapshot from Gateways
	Gateways ResourceBuildOptions
	// List options for composing a snapshot from MatchableHttpGateways
	MatchableHttpGateways ResourceBuildOptions
	// List options for composing a snapshot from VirtualServices
	VirtualServices ResourceBuildOptions
	// List options for composing a snapshot from RouteTables
	RouteTables ResourceBuildOptions

	// List options for composing a snapshot from Upstreams
	Upstreams ResourceBuildOptions
	// List options for composing a snapshot from UpstreamGroups
	UpstreamGroups ResourceBuildOptions
	// List options for composing a snapshot from Settings
	Settings ResourceBuildOptions
	// List options for composing a snapshot from Proxies
	Proxies ResourceBuildOptions

	// List options for composing a snapshot from AuthConfigs
	AuthConfigs ResourceBuildOptions

	// List options for composing a snapshot from RateLimitConfigs
	RateLimitConfigs ResourceBuildOptions
}

// Options for reading resources of a given type
type ResourceBuildOptions struct {

	// List options for composing a snapshot from a resource type
	ListOptions []client.ListOption

	// If provided, ensure the resource has been verified before adding it to snapshots
	Verifier verifier.ServerResourceVerifier
}

// build a snapshot from resources across multiple clusters
type multiClusterBuilder struct {
	clusters multicluster.Interface
	client   multicluster.Client
}

// Produces snapshots of resources across all clusters defined in the ClusterSet
func NewMultiClusterBuilder(
	clusters multicluster.Interface,
	client multicluster.Client,
) Builder {
	return &multiClusterBuilder{
		clusters: clusters,
		client:   client,
	}
}

func (b *multiClusterBuilder) BuildSnapshot(ctx context.Context, name string, opts BuildOptions) (Snapshot, error) {

	services := sk_sets.NewResourceSet[*v1_types.Service]()
	pods := sk_sets.NewResourceSet[*v1_types.Pod]()
	deployments := sk_sets.NewResourceSet[*apps_v1_types.Deployment]()
	daemonSets := sk_sets.NewResourceSet[*apps_v1_types.DaemonSet]()
	gateways := sk_sets.NewResourceSet[*gateway_solo_io_v1_types.Gateway]()
	matchableHttpGateways := sk_sets.NewResourceSet[*gateway_solo_io_v1_types.MatchableHttpGateway]()
	virtualServices := sk_sets.NewResourceSet[*gateway_solo_io_v1_types.VirtualService]()
	routeTables := sk_sets.NewResourceSet[*gateway_solo_io_v1_types.RouteTable]()
	upstreams := sk_sets.NewResourceSet[*gloo_solo_io_v1_types.Upstream]()
	upstreamGroups := sk_sets.NewResourceSet[*gloo_solo_io_v1_types.UpstreamGroup]()
	settings := sk_sets.NewResourceSet[*gloo_solo_io_v1_types.Settings]()
	proxies := sk_sets.NewResourceSet[*gloo_solo_io_v1_types.Proxy]()
	authConfigs := sk_sets.NewResourceSet[*enterprise_gloo_solo_io_v1_types.AuthConfig]()
	rateLimitConfigs := sk_sets.NewResourceSet[*ratelimit_api_solo_io_v1alpha1_types.RateLimitConfig]()

	var errs error

	for _, cluster := range b.clusters.ListClusters() {

		if err := b.insertServicesFromCluster(ctx, cluster, services, opts.Services); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertPodsFromCluster(ctx, cluster, pods, opts.Pods); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertDeploymentsFromCluster(ctx, cluster, deployments, opts.Deployments); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertDaemonSetsFromCluster(ctx, cluster, daemonSets, opts.DaemonSets); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertGatewaysFromCluster(ctx, cluster, gateways, opts.Gateways); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertMatchableHttpGatewaysFromCluster(ctx, cluster, matchableHttpGateways, opts.MatchableHttpGateways); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertVirtualServicesFromCluster(ctx, cluster, virtualServices, opts.VirtualServices); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertRouteTablesFromCluster(ctx, cluster, routeTables, opts.RouteTables); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertUpstreamsFromCluster(ctx, cluster, upstreams, opts.Upstreams); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertUpstreamGroupsFromCluster(ctx, cluster, upstreamGroups, opts.UpstreamGroups); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertSettingsFromCluster(ctx, cluster, settings, opts.Settings); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertProxiesFromCluster(ctx, cluster, proxies, opts.Proxies); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertAuthConfigsFromCluster(ctx, cluster, authConfigs, opts.AuthConfigs); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertRateLimitConfigsFromCluster(ctx, cluster, rateLimitConfigs, opts.RateLimitConfigs); err != nil {
			errs = multierror.Append(errs, err)
		}

	}

	outputSnap := NewSnapshot(
		name,

		services,
		pods,
		deployments,
		daemonSets,
		gateways,
		matchableHttpGateways,
		virtualServices,
		routeTables,
		upstreams,
		upstreamGroups,
		settings,
		proxies,
		authConfigs,
		rateLimitConfigs,
	)

	return outputSnap, errs
}

func (b *multiClusterBuilder) insertServicesFromCluster(ctx context.Context, cluster string, services sk_sets.ResourceSet[*v1_types.Service], opts ResourceBuildOptions) error {
	clusterClient, err := b.client.Cluster(cluster)
	if err != nil {
		return err
	}

	serviceClient := sk_client.NewGenericClient(clusterClient, &v1_types.Service{}, &v1_types.ServiceList{})

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Service",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	serviceList, err := serviceClient.List(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range serviceList.Items {
		item := item.DeepCopy() // pike + own

		ezkube.SetClusterName(item, cluster) // set cluster for what was in-memory processing
		services.Insert(item)
	}

	return nil
}
func (b *multiClusterBuilder) insertPodsFromCluster(ctx context.Context, cluster string, pods sk_sets.ResourceSet[*v1_types.Pod], opts ResourceBuildOptions) error {
	clusterClient, err := b.client.Cluster(cluster)
	if err != nil {
		return err
	}

	podClient := sk_client.NewGenericClient(clusterClient, &v1_types.Pod{}, &v1_types.PodList{})

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Pod",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	podList, err := podClient.List(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range podList.Items {
		item := item.DeepCopy() // pike + own

		ezkube.SetClusterName(item, cluster) // set cluster for what was in-memory processing
		pods.Insert(item)
	}

	return nil
}
func (b *multiClusterBuilder) insertDeploymentsFromCluster(ctx context.Context, cluster string, deployments sk_sets.ResourceSet[*apps_v1_types.Deployment], opts ResourceBuildOptions) error {
	clusterClient, err := b.client.Cluster(cluster)
	if err != nil {
		return err
	}

	deploymentClient := sk_client.NewGenericClient(clusterClient, &apps_v1_types.Deployment{}, &apps_v1_types.DeploymentList{})

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "apps",
			Version: "v1",
			Kind:    "Deployment",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	deploymentList, err := deploymentClient.List(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range deploymentList.Items {
		item := item.DeepCopy() // pike + own

		ezkube.SetClusterName(item, cluster) // set cluster for what was in-memory processing
		deployments.Insert(item)
	}

	return nil
}
func (b *multiClusterBuilder) insertDaemonSetsFromCluster(ctx context.Context, cluster string, daemonSets sk_sets.ResourceSet[*apps_v1_types.DaemonSet], opts ResourceBuildOptions) error {
	clusterClient, err := b.client.Cluster(cluster)
	if err != nil {
		return err
	}

	daemonSetClient := sk_client.NewGenericClient(clusterClient, &apps_v1_types.DaemonSet{}, &apps_v1_types.DaemonSetList{})

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "apps",
			Version: "v1",
			Kind:    "DaemonSet",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	daemonSetList, err := daemonSetClient.List(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range daemonSetList.Items {
		item := item.DeepCopy() // pike + own

		ezkube.SetClusterName(item, cluster) // set cluster for what was in-memory processing
		daemonSets.Insert(item)
	}

	return nil
}
func (b *multiClusterBuilder) insertGatewaysFromCluster(ctx context.Context, cluster string, gateways sk_sets.ResourceSet[*gateway_solo_io_v1_types.Gateway], opts ResourceBuildOptions) error {
	clusterClient, err := b.client.Cluster(cluster)
	if err != nil {
		return err
	}

	gatewayClient := sk_client.NewGenericClient(clusterClient, &gateway_solo_io_v1_types.Gateway{}, &gateway_solo_io_v1_types.GatewayList{})

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "gateway.solo.io",
			Version: "v1",
			Kind:    "Gateway",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	gatewayList, err := gatewayClient.List(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range gatewayList.Items {
		item := item.DeepCopy() // pike + own

		ezkube.SetClusterName(item, cluster) // set cluster for what was in-memory processing
		gateways.Insert(item)
	}

	return nil
}
func (b *multiClusterBuilder) insertMatchableHttpGatewaysFromCluster(ctx context.Context, cluster string, matchableHttpGateways sk_sets.ResourceSet[*gateway_solo_io_v1_types.MatchableHttpGateway], opts ResourceBuildOptions) error {
	clusterClient, err := b.client.Cluster(cluster)
	if err != nil {
		return err
	}

	matchableHttpGatewayClient := sk_client.NewGenericClient(clusterClient, &gateway_solo_io_v1_types.MatchableHttpGateway{}, &gateway_solo_io_v1_types.MatchableHttpGatewayList{})

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "gateway.solo.io",
			Version: "v1",
			Kind:    "MatchableHttpGateway",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	matchableHttpGatewayList, err := matchableHttpGatewayClient.List(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range matchableHttpGatewayList.Items {
		item := item.DeepCopy() // pike + own

		ezkube.SetClusterName(item, cluster) // set cluster for what was in-memory processing
		matchableHttpGateways.Insert(item)
	}

	return nil
}
func (b *multiClusterBuilder) insertVirtualServicesFromCluster(ctx context.Context, cluster string, virtualServices sk_sets.ResourceSet[*gateway_solo_io_v1_types.VirtualService], opts ResourceBuildOptions) error {
	clusterClient, err := b.client.Cluster(cluster)
	if err != nil {
		return err
	}

	virtualServiceClient := sk_client.NewGenericClient(clusterClient, &gateway_solo_io_v1_types.VirtualService{}, &gateway_solo_io_v1_types.VirtualServiceList{})

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "gateway.solo.io",
			Version: "v1",
			Kind:    "VirtualService",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	virtualServiceList, err := virtualServiceClient.List(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range virtualServiceList.Items {
		item := item.DeepCopy() // pike + own

		ezkube.SetClusterName(item, cluster) // set cluster for what was in-memory processing
		virtualServices.Insert(item)
	}

	return nil
}
func (b *multiClusterBuilder) insertRouteTablesFromCluster(ctx context.Context, cluster string, routeTables sk_sets.ResourceSet[*gateway_solo_io_v1_types.RouteTable], opts ResourceBuildOptions) error {
	clusterClient, err := b.client.Cluster(cluster)
	if err != nil {
		return err
	}

	routeTableClient := sk_client.NewGenericClient(clusterClient, &gateway_solo_io_v1_types.RouteTable{}, &gateway_solo_io_v1_types.RouteTableList{})

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "gateway.solo.io",
			Version: "v1",
			Kind:    "RouteTable",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	routeTableList, err := routeTableClient.List(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range routeTableList.Items {
		item := item.DeepCopy() // pike + own

		ezkube.SetClusterName(item, cluster) // set cluster for what was in-memory processing
		routeTables.Insert(item)
	}

	return nil
}
func (b *multiClusterBuilder) insertUpstreamsFromCluster(ctx context.Context, cluster string, upstreams sk_sets.ResourceSet[*gloo_solo_io_v1_types.Upstream], opts ResourceBuildOptions) error {
	clusterClient, err := b.client.Cluster(cluster)
	if err != nil {
		return err
	}

	upstreamClient := sk_client.NewGenericClient(clusterClient, &gloo_solo_io_v1_types.Upstream{}, &gloo_solo_io_v1_types.UpstreamList{})

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "gloo.solo.io",
			Version: "v1",
			Kind:    "Upstream",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	upstreamList, err := upstreamClient.List(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range upstreamList.Items {
		item := item.DeepCopy() // pike + own

		ezkube.SetClusterName(item, cluster) // set cluster for what was in-memory processing
		upstreams.Insert(item)
	}

	return nil
}
func (b *multiClusterBuilder) insertUpstreamGroupsFromCluster(ctx context.Context, cluster string, upstreamGroups sk_sets.ResourceSet[*gloo_solo_io_v1_types.UpstreamGroup], opts ResourceBuildOptions) error {
	clusterClient, err := b.client.Cluster(cluster)
	if err != nil {
		return err
	}

	upstreamGroupClient := sk_client.NewGenericClient(clusterClient, &gloo_solo_io_v1_types.UpstreamGroup{}, &gloo_solo_io_v1_types.UpstreamGroupList{})

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "gloo.solo.io",
			Version: "v1",
			Kind:    "UpstreamGroup",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	upstreamGroupList, err := upstreamGroupClient.List(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range upstreamGroupList.Items {
		item := item.DeepCopy() // pike + own

		ezkube.SetClusterName(item, cluster) // set cluster for what was in-memory processing
		upstreamGroups.Insert(item)
	}

	return nil
}
func (b *multiClusterBuilder) insertSettingsFromCluster(ctx context.Context, cluster string, settings sk_sets.ResourceSet[*gloo_solo_io_v1_types.Settings], opts ResourceBuildOptions) error {
	clusterClient, err := b.client.Cluster(cluster)
	if err != nil {
		return err
	}

	settingsClient := sk_client.NewGenericClient(clusterClient, &gloo_solo_io_v1_types.Settings{}, &gloo_solo_io_v1_types.SettingsList{})

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "gloo.solo.io",
			Version: "v1",
			Kind:    "Settings",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	settingsList, err := settingsClient.List(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range settingsList.Items {
		item := item.DeepCopy() // pike + own

		ezkube.SetClusterName(item, cluster) // set cluster for what was in-memory processing
		settings.Insert(item)
	}

	return nil
}
func (b *multiClusterBuilder) insertProxiesFromCluster(ctx context.Context, cluster string, proxies sk_sets.ResourceSet[*gloo_solo_io_v1_types.Proxy], opts ResourceBuildOptions) error {
	clusterClient, err := b.client.Cluster(cluster)
	if err != nil {
		return err
	}

	proxyClient := sk_client.NewGenericClient(clusterClient, &gloo_solo_io_v1_types.Proxy{}, &gloo_solo_io_v1_types.ProxyList{})

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "gloo.solo.io",
			Version: "v1",
			Kind:    "Proxy",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	proxyList, err := proxyClient.List(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range proxyList.Items {
		item := item.DeepCopy() // pike + own

		ezkube.SetClusterName(item, cluster) // set cluster for what was in-memory processing
		proxies.Insert(item)
	}

	return nil
}
func (b *multiClusterBuilder) insertAuthConfigsFromCluster(ctx context.Context, cluster string, authConfigs sk_sets.ResourceSet[*enterprise_gloo_solo_io_v1_types.AuthConfig], opts ResourceBuildOptions) error {
	clusterClient, err := b.client.Cluster(cluster)
	if err != nil {
		return err
	}

	authConfigClient := sk_client.NewGenericClient(clusterClient, &enterprise_gloo_solo_io_v1_types.AuthConfig{}, &enterprise_gloo_solo_io_v1_types.AuthConfigList{})

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "enterprise.gloo.solo.io",
			Version: "v1",
			Kind:    "AuthConfig",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	authConfigList, err := authConfigClient.List(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range authConfigList.Items {
		item := item.DeepCopy() // pike + own

		ezkube.SetClusterName(item, cluster) // set cluster for what was in-memory processing
		authConfigs.Insert(item)
	}

	return nil
}
func (b *multiClusterBuilder) insertRateLimitConfigsFromCluster(ctx context.Context, cluster string, rateLimitConfigs sk_sets.ResourceSet[*ratelimit_api_solo_io_v1alpha1_types.RateLimitConfig], opts ResourceBuildOptions) error {
	clusterClient, err := b.client.Cluster(cluster)
	if err != nil {
		return err
	}

	rateLimitConfigClient := sk_client.NewGenericClient(clusterClient, &ratelimit_api_solo_io_v1alpha1_types.RateLimitConfig{}, &ratelimit_api_solo_io_v1alpha1_types.RateLimitConfigList{})

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "ratelimit.api.solo.io",
			Version: "v1alpha1",
			Kind:    "RateLimitConfig",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	rateLimitConfigList, err := rateLimitConfigClient.List(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range rateLimitConfigList.Items {
		item := item.DeepCopy() // pike + own

		ezkube.SetClusterName(item, cluster) // set cluster for what was in-memory processing
		rateLimitConfigs.Insert(item)
	}

	return nil
}

// build a snapshot from resources in a single cluster
type singleClusterBuilder struct {
	mgr         manager.Manager
	clusterName string
}

// Produces snapshots of resources read from the manager for the given cluster
func NewSingleClusterBuilder(
	mgr manager.Manager,
) Builder {
	return NewSingleClusterBuilderWithClusterName(mgr, "")
}

// Produces snapshots of resources read from the manager for the given cluster.
// Snapshot resources will be marked with the given ClusterName.
func NewSingleClusterBuilderWithClusterName(
	mgr manager.Manager,
	clusterName string,
) Builder {
	return &singleClusterBuilder{
		mgr:         mgr,
		clusterName: clusterName,
	}
}

func (b *singleClusterBuilder) BuildSnapshot(ctx context.Context, name string, opts BuildOptions) (Snapshot, error) {

	services := sk_sets.NewResourceSet[*v1_types.Service]()
	pods := sk_sets.NewResourceSet[*v1_types.Pod]()
	deployments := sk_sets.NewResourceSet[*apps_v1_types.Deployment]()
	daemonSets := sk_sets.NewResourceSet[*apps_v1_types.DaemonSet]()
	gateways := sk_sets.NewResourceSet[*gateway_solo_io_v1_types.Gateway]()
	matchableHttpGateways := sk_sets.NewResourceSet[*gateway_solo_io_v1_types.MatchableHttpGateway]()
	virtualServices := sk_sets.NewResourceSet[*gateway_solo_io_v1_types.VirtualService]()
	routeTables := sk_sets.NewResourceSet[*gateway_solo_io_v1_types.RouteTable]()
	upstreams := sk_sets.NewResourceSet[*gloo_solo_io_v1_types.Upstream]()
	upstreamGroups := sk_sets.NewResourceSet[*gloo_solo_io_v1_types.UpstreamGroup]()
	settings := sk_sets.NewResourceSet[*gloo_solo_io_v1_types.Settings]()
	proxies := sk_sets.NewResourceSet[*gloo_solo_io_v1_types.Proxy]()
	authConfigs := sk_sets.NewResourceSet[*enterprise_gloo_solo_io_v1_types.AuthConfig]()
	rateLimitConfigs := sk_sets.NewResourceSet[*ratelimit_api_solo_io_v1alpha1_types.RateLimitConfig]()

	var errs error

	if err := b.insertServices(ctx, services, opts.Services); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertPods(ctx, pods, opts.Pods); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertDeployments(ctx, deployments, opts.Deployments); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertDaemonSets(ctx, daemonSets, opts.DaemonSets); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertGateways(ctx, gateways, opts.Gateways); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertMatchableHttpGateways(ctx, matchableHttpGateways, opts.MatchableHttpGateways); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertVirtualServices(ctx, virtualServices, opts.VirtualServices); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertRouteTables(ctx, routeTables, opts.RouteTables); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertUpstreams(ctx, upstreams, opts.Upstreams); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertUpstreamGroups(ctx, upstreamGroups, opts.UpstreamGroups); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertSettings(ctx, settings, opts.Settings); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertProxies(ctx, proxies, opts.Proxies); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertAuthConfigs(ctx, authConfigs, opts.AuthConfigs); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertRateLimitConfigs(ctx, rateLimitConfigs, opts.RateLimitConfigs); err != nil {
		errs = multierror.Append(errs, err)
	}

	outputSnap := NewSnapshot(
		name,

		services,
		pods,
		deployments,
		daemonSets,
		gateways,
		matchableHttpGateways,
		virtualServices,
		routeTables,
		upstreams,
		upstreamGroups,
		settings,
		proxies,
		authConfigs,
		rateLimitConfigs,
	)

	return outputSnap, errs
}

func (b *singleClusterBuilder) insertServices(ctx context.Context, services sk_sets.ResourceSet[*v1_types.Service], opts ResourceBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Service",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	serviceClient := sk_client.NewGenericClient(b.mgr.GetClient(), &v1_types.Service{}, &v1_types.ServiceList{})

	serviceList, err := serviceClient.List(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range serviceList.Items {
		item := item.DeepCopy()                    // pike + own the item.
		ezkube.SetClusterName(item, b.clusterName) // set cluster for what was in-memory processing
		services.Insert(item)
	}

	return nil
}
func (b *singleClusterBuilder) insertPods(ctx context.Context, pods sk_sets.ResourceSet[*v1_types.Pod], opts ResourceBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Pod",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	podClient := sk_client.NewGenericClient(b.mgr.GetClient(), &v1_types.Pod{}, &v1_types.PodList{})

	podList, err := podClient.List(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range podList.Items {
		item := item.DeepCopy()                    // pike + own the item.
		ezkube.SetClusterName(item, b.clusterName) // set cluster for what was in-memory processing
		pods.Insert(item)
	}

	return nil
}
func (b *singleClusterBuilder) insertDeployments(ctx context.Context, deployments sk_sets.ResourceSet[*apps_v1_types.Deployment], opts ResourceBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "apps",
			Version: "v1",
			Kind:    "Deployment",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	deploymentClient := sk_client.NewGenericClient(b.mgr.GetClient(), &apps_v1_types.Deployment{}, &apps_v1_types.DeploymentList{})

	deploymentList, err := deploymentClient.List(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range deploymentList.Items {
		item := item.DeepCopy()                    // pike + own the item.
		ezkube.SetClusterName(item, b.clusterName) // set cluster for what was in-memory processing
		deployments.Insert(item)
	}

	return nil
}
func (b *singleClusterBuilder) insertDaemonSets(ctx context.Context, daemonSets sk_sets.ResourceSet[*apps_v1_types.DaemonSet], opts ResourceBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "apps",
			Version: "v1",
			Kind:    "DaemonSet",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	daemonSetClient := sk_client.NewGenericClient(b.mgr.GetClient(), &apps_v1_types.DaemonSet{}, &apps_v1_types.DaemonSetList{})

	daemonSetList, err := daemonSetClient.List(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range daemonSetList.Items {
		item := item.DeepCopy()                    // pike + own the item.
		ezkube.SetClusterName(item, b.clusterName) // set cluster for what was in-memory processing
		daemonSets.Insert(item)
	}

	return nil
}
func (b *singleClusterBuilder) insertGateways(ctx context.Context, gateways sk_sets.ResourceSet[*gateway_solo_io_v1_types.Gateway], opts ResourceBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "gateway.solo.io",
			Version: "v1",
			Kind:    "Gateway",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	gatewayClient := sk_client.NewGenericClient(b.mgr.GetClient(), &gateway_solo_io_v1_types.Gateway{}, &gateway_solo_io_v1_types.GatewayList{})

	gatewayList, err := gatewayClient.List(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range gatewayList.Items {
		item := item.DeepCopy()                    // pike + own the item.
		ezkube.SetClusterName(item, b.clusterName) // set cluster for what was in-memory processing
		gateways.Insert(item)
	}

	return nil
}
func (b *singleClusterBuilder) insertMatchableHttpGateways(ctx context.Context, matchableHttpGateways sk_sets.ResourceSet[*gateway_solo_io_v1_types.MatchableHttpGateway], opts ResourceBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "gateway.solo.io",
			Version: "v1",
			Kind:    "MatchableHttpGateway",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	matchableHttpGatewayClient := sk_client.NewGenericClient(b.mgr.GetClient(), &gateway_solo_io_v1_types.MatchableHttpGateway{}, &gateway_solo_io_v1_types.MatchableHttpGatewayList{})

	matchableHttpGatewayList, err := matchableHttpGatewayClient.List(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range matchableHttpGatewayList.Items {
		item := item.DeepCopy()                    // pike + own the item.
		ezkube.SetClusterName(item, b.clusterName) // set cluster for what was in-memory processing
		matchableHttpGateways.Insert(item)
	}

	return nil
}
func (b *singleClusterBuilder) insertVirtualServices(ctx context.Context, virtualServices sk_sets.ResourceSet[*gateway_solo_io_v1_types.VirtualService], opts ResourceBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "gateway.solo.io",
			Version: "v1",
			Kind:    "VirtualService",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	virtualServiceClient := sk_client.NewGenericClient(b.mgr.GetClient(), &gateway_solo_io_v1_types.VirtualService{}, &gateway_solo_io_v1_types.VirtualServiceList{})

	virtualServiceList, err := virtualServiceClient.List(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range virtualServiceList.Items {
		item := item.DeepCopy()                    // pike + own the item.
		ezkube.SetClusterName(item, b.clusterName) // set cluster for what was in-memory processing
		virtualServices.Insert(item)
	}

	return nil
}
func (b *singleClusterBuilder) insertRouteTables(ctx context.Context, routeTables sk_sets.ResourceSet[*gateway_solo_io_v1_types.RouteTable], opts ResourceBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "gateway.solo.io",
			Version: "v1",
			Kind:    "RouteTable",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	routeTableClient := sk_client.NewGenericClient(b.mgr.GetClient(), &gateway_solo_io_v1_types.RouteTable{}, &gateway_solo_io_v1_types.RouteTableList{})

	routeTableList, err := routeTableClient.List(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range routeTableList.Items {
		item := item.DeepCopy()                    // pike + own the item.
		ezkube.SetClusterName(item, b.clusterName) // set cluster for what was in-memory processing
		routeTables.Insert(item)
	}

	return nil
}
func (b *singleClusterBuilder) insertUpstreams(ctx context.Context, upstreams sk_sets.ResourceSet[*gloo_solo_io_v1_types.Upstream], opts ResourceBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "gloo.solo.io",
			Version: "v1",
			Kind:    "Upstream",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	upstreamClient := sk_client.NewGenericClient(b.mgr.GetClient(), &gloo_solo_io_v1_types.Upstream{}, &gloo_solo_io_v1_types.UpstreamList{})

	upstreamList, err := upstreamClient.List(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range upstreamList.Items {
		item := item.DeepCopy()                    // pike + own the item.
		ezkube.SetClusterName(item, b.clusterName) // set cluster for what was in-memory processing
		upstreams.Insert(item)
	}

	return nil
}
func (b *singleClusterBuilder) insertUpstreamGroups(ctx context.Context, upstreamGroups sk_sets.ResourceSet[*gloo_solo_io_v1_types.UpstreamGroup], opts ResourceBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "gloo.solo.io",
			Version: "v1",
			Kind:    "UpstreamGroup",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	upstreamGroupClient := sk_client.NewGenericClient(b.mgr.GetClient(), &gloo_solo_io_v1_types.UpstreamGroup{}, &gloo_solo_io_v1_types.UpstreamGroupList{})

	upstreamGroupList, err := upstreamGroupClient.List(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range upstreamGroupList.Items {
		item := item.DeepCopy()                    // pike + own the item.
		ezkube.SetClusterName(item, b.clusterName) // set cluster for what was in-memory processing
		upstreamGroups.Insert(item)
	}

	return nil
}
func (b *singleClusterBuilder) insertSettings(ctx context.Context, settings sk_sets.ResourceSet[*gloo_solo_io_v1_types.Settings], opts ResourceBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "gloo.solo.io",
			Version: "v1",
			Kind:    "Settings",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	settingsClient := sk_client.NewGenericClient(b.mgr.GetClient(), &gloo_solo_io_v1_types.Settings{}, &gloo_solo_io_v1_types.SettingsList{})

	settingsList, err := settingsClient.List(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range settingsList.Items {
		item := item.DeepCopy()                    // pike + own the item.
		ezkube.SetClusterName(item, b.clusterName) // set cluster for what was in-memory processing
		settings.Insert(item)
	}

	return nil
}
func (b *singleClusterBuilder) insertProxies(ctx context.Context, proxies sk_sets.ResourceSet[*gloo_solo_io_v1_types.Proxy], opts ResourceBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "gloo.solo.io",
			Version: "v1",
			Kind:    "Proxy",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	proxyClient := sk_client.NewGenericClient(b.mgr.GetClient(), &gloo_solo_io_v1_types.Proxy{}, &gloo_solo_io_v1_types.ProxyList{})

	proxyList, err := proxyClient.List(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range proxyList.Items {
		item := item.DeepCopy()                    // pike + own the item.
		ezkube.SetClusterName(item, b.clusterName) // set cluster for what was in-memory processing
		proxies.Insert(item)
	}

	return nil
}
func (b *singleClusterBuilder) insertAuthConfigs(ctx context.Context, authConfigs sk_sets.ResourceSet[*enterprise_gloo_solo_io_v1_types.AuthConfig], opts ResourceBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "enterprise.gloo.solo.io",
			Version: "v1",
			Kind:    "AuthConfig",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	authConfigClient := sk_client.NewGenericClient(b.mgr.GetClient(), &enterprise_gloo_solo_io_v1_types.AuthConfig{}, &enterprise_gloo_solo_io_v1_types.AuthConfigList{})

	authConfigList, err := authConfigClient.List(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range authConfigList.Items {
		item := item.DeepCopy()                    // pike + own the item.
		ezkube.SetClusterName(item, b.clusterName) // set cluster for what was in-memory processing
		authConfigs.Insert(item)
	}

	return nil
}
func (b *singleClusterBuilder) insertRateLimitConfigs(ctx context.Context, rateLimitConfigs sk_sets.ResourceSet[*ratelimit_api_solo_io_v1alpha1_types.RateLimitConfig], opts ResourceBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "ratelimit.api.solo.io",
			Version: "v1alpha1",
			Kind:    "RateLimitConfig",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	rateLimitConfigClient := sk_client.NewGenericClient(b.mgr.GetClient(), &ratelimit_api_solo_io_v1alpha1_types.RateLimitConfig{}, &ratelimit_api_solo_io_v1alpha1_types.RateLimitConfigList{})

	rateLimitConfigList, err := rateLimitConfigClient.List(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range rateLimitConfigList.Items {
		item := item.DeepCopy()                    // pike + own the item.
		ezkube.SetClusterName(item, b.clusterName) // set cluster for what was in-memory processing
		rateLimitConfigs.Insert(item)
	}

	return nil
}

// build a snapshot from resources in a single cluster
type inMemoryBuilder struct {
	getSnapshot func() (resource.ClusterSnapshot, error)
}

// Produces snapshots of resources read from the manager for the given cluster
func NewInMemoryBuilder(
	getSnapshot func() (resource.ClusterSnapshot, error),
) Builder {
	return &inMemoryBuilder{
		getSnapshot: getSnapshot,
	}
}

func (i *inMemoryBuilder) BuildSnapshot(ctx context.Context, name string, opts BuildOptions) (Snapshot, error) {
	genericSnap, err := i.getSnapshot()
	if err != nil {
		return nil, err
	}

	services := sk_sets.NewResourceSet[*v1_types.Service]()
	pods := sk_sets.NewResourceSet[*v1_types.Pod]()
	deployments := sk_sets.NewResourceSet[*apps_v1_types.Deployment]()
	daemonSets := sk_sets.NewResourceSet[*apps_v1_types.DaemonSet]()
	gateways := sk_sets.NewResourceSet[*gateway_solo_io_v1_types.Gateway]()
	matchableHttpGateways := sk_sets.NewResourceSet[*gateway_solo_io_v1_types.MatchableHttpGateway]()
	virtualServices := sk_sets.NewResourceSet[*gateway_solo_io_v1_types.VirtualService]()
	routeTables := sk_sets.NewResourceSet[*gateway_solo_io_v1_types.RouteTable]()
	upstreams := sk_sets.NewResourceSet[*gloo_solo_io_v1_types.Upstream]()
	upstreamGroups := sk_sets.NewResourceSet[*gloo_solo_io_v1_types.UpstreamGroup]()
	settings := sk_sets.NewResourceSet[*gloo_solo_io_v1_types.Settings]()
	proxies := sk_sets.NewResourceSet[*gloo_solo_io_v1_types.Proxy]()
	authConfigs := sk_sets.NewResourceSet[*enterprise_gloo_solo_io_v1_types.AuthConfig]()
	rateLimitConfigs := sk_sets.NewResourceSet[*ratelimit_api_solo_io_v1alpha1_types.RateLimitConfig]()

	genericSnap.ForEachObject(func(cluster string, gvk schema.GroupVersionKind, obj resource.TypedObject) {
		switch obj := obj.(type) {
		// insert Services
		case *v1_types.Service:
			i.insertService(ctx, obj, services, opts)
		// insert Pods
		case *v1_types.Pod:
			i.insertPod(ctx, obj, pods, opts)
		// insert Deployments
		case *apps_v1_types.Deployment:
			i.insertDeployment(ctx, obj, deployments, opts)
		// insert DaemonSets
		case *apps_v1_types.DaemonSet:
			i.insertDaemonSet(ctx, obj, daemonSets, opts)
		// insert Gateways
		case *gateway_solo_io_v1_types.Gateway:
			i.insertGateway(ctx, obj, gateways, opts)
		// insert MatchableHttpGateways
		case *gateway_solo_io_v1_types.MatchableHttpGateway:
			i.insertMatchableHttpGateway(ctx, obj, matchableHttpGateways, opts)
		// insert VirtualServices
		case *gateway_solo_io_v1_types.VirtualService:
			i.insertVirtualService(ctx, obj, virtualServices, opts)
		// insert RouteTables
		case *gateway_solo_io_v1_types.RouteTable:
			i.insertRouteTable(ctx, obj, routeTables, opts)
		// insert Upstreams
		case *gloo_solo_io_v1_types.Upstream:
			i.insertUpstream(ctx, obj, upstreams, opts)
		// insert UpstreamGroups
		case *gloo_solo_io_v1_types.UpstreamGroup:
			i.insertUpstreamGroup(ctx, obj, upstreamGroups, opts)
		// insert Settings
		case *gloo_solo_io_v1_types.Settings:
			i.insertSettings(ctx, obj, settings, opts)
		// insert Proxies
		case *gloo_solo_io_v1_types.Proxy:
			i.insertProxy(ctx, obj, proxies, opts)
		// insert AuthConfigs
		case *enterprise_gloo_solo_io_v1_types.AuthConfig:
			i.insertAuthConfig(ctx, obj, authConfigs, opts)
		// insert RateLimitConfigs
		case *ratelimit_api_solo_io_v1alpha1_types.RateLimitConfig:
			i.insertRateLimitConfig(ctx, obj, rateLimitConfigs, opts)
		}
	})

	return NewSnapshot(
		name,

		services,
		pods,
		deployments,
		daemonSets,
		gateways,
		matchableHttpGateways,
		virtualServices,
		routeTables,
		upstreams,
		upstreamGroups,
		settings,
		proxies,
		authConfigs,
		rateLimitConfigs,
	), nil
}

func (i *inMemoryBuilder) insertService(
	ctx context.Context,
	service *v1_types.Service,
	serviceSet sk_sets.ResourceSet[*v1_types.Service],
	buildOpts BuildOptions,
) {

	opts := buildOpts.Services.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = service.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(service.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		serviceSet.Insert(service)
	}
}
func (i *inMemoryBuilder) insertPod(
	ctx context.Context,
	pod *v1_types.Pod,
	podSet sk_sets.ResourceSet[*v1_types.Pod],
	buildOpts BuildOptions,
) {

	opts := buildOpts.Pods.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = pod.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(pod.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		podSet.Insert(pod)
	}
}

func (i *inMemoryBuilder) insertDeployment(
	ctx context.Context,
	deployment *apps_v1_types.Deployment,
	deploymentSet sk_sets.ResourceSet[*apps_v1_types.Deployment],
	buildOpts BuildOptions,
) {

	opts := buildOpts.Deployments.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = deployment.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(deployment.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		deploymentSet.Insert(deployment)
	}
}
func (i *inMemoryBuilder) insertDaemonSet(
	ctx context.Context,
	daemonSet *apps_v1_types.DaemonSet,
	daemonSetSet sk_sets.ResourceSet[*apps_v1_types.DaemonSet],
	buildOpts BuildOptions,
) {

	opts := buildOpts.DaemonSets.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = daemonSet.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(daemonSet.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		daemonSetSet.Insert(daemonSet)
	}
}

func (i *inMemoryBuilder) insertGateway(
	ctx context.Context,
	gateway *gateway_solo_io_v1_types.Gateway,
	gatewaySet sk_sets.ResourceSet[*gateway_solo_io_v1_types.Gateway],
	buildOpts BuildOptions,
) {

	opts := buildOpts.Gateways.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = gateway.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(gateway.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		gatewaySet.Insert(gateway)
	}
}
func (i *inMemoryBuilder) insertMatchableHttpGateway(
	ctx context.Context,
	matchableHttpGateway *gateway_solo_io_v1_types.MatchableHttpGateway,
	matchableHttpGatewaySet sk_sets.ResourceSet[*gateway_solo_io_v1_types.MatchableHttpGateway],
	buildOpts BuildOptions,
) {

	opts := buildOpts.MatchableHttpGateways.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = matchableHttpGateway.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(matchableHttpGateway.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		matchableHttpGatewaySet.Insert(matchableHttpGateway)
	}
}
func (i *inMemoryBuilder) insertVirtualService(
	ctx context.Context,
	virtualService *gateway_solo_io_v1_types.VirtualService,
	virtualServiceSet sk_sets.ResourceSet[*gateway_solo_io_v1_types.VirtualService],
	buildOpts BuildOptions,
) {

	opts := buildOpts.VirtualServices.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = virtualService.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(virtualService.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		virtualServiceSet.Insert(virtualService)
	}
}
func (i *inMemoryBuilder) insertRouteTable(
	ctx context.Context,
	routeTable *gateway_solo_io_v1_types.RouteTable,
	routeTableSet sk_sets.ResourceSet[*gateway_solo_io_v1_types.RouteTable],
	buildOpts BuildOptions,
) {

	opts := buildOpts.RouteTables.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = routeTable.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(routeTable.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		routeTableSet.Insert(routeTable)
	}
}

func (i *inMemoryBuilder) insertUpstream(
	ctx context.Context,
	upstream *gloo_solo_io_v1_types.Upstream,
	upstreamSet sk_sets.ResourceSet[*gloo_solo_io_v1_types.Upstream],
	buildOpts BuildOptions,
) {

	opts := buildOpts.Upstreams.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = upstream.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(upstream.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		upstreamSet.Insert(upstream)
	}
}
func (i *inMemoryBuilder) insertUpstreamGroup(
	ctx context.Context,
	upstreamGroup *gloo_solo_io_v1_types.UpstreamGroup,
	upstreamGroupSet sk_sets.ResourceSet[*gloo_solo_io_v1_types.UpstreamGroup],
	buildOpts BuildOptions,
) {

	opts := buildOpts.UpstreamGroups.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = upstreamGroup.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(upstreamGroup.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		upstreamGroupSet.Insert(upstreamGroup)
	}
}
func (i *inMemoryBuilder) insertSettings(
	ctx context.Context,
	settings *gloo_solo_io_v1_types.Settings,
	settingsSet sk_sets.ResourceSet[*gloo_solo_io_v1_types.Settings],
	buildOpts BuildOptions,
) {

	opts := buildOpts.Settings.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = settings.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(settings.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		settingsSet.Insert(settings)
	}
}
func (i *inMemoryBuilder) insertProxy(
	ctx context.Context,
	proxy *gloo_solo_io_v1_types.Proxy,
	proxySet sk_sets.ResourceSet[*gloo_solo_io_v1_types.Proxy],
	buildOpts BuildOptions,
) {

	opts := buildOpts.Proxies.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = proxy.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(proxy.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		proxySet.Insert(proxy)
	}
}

func (i *inMemoryBuilder) insertAuthConfig(
	ctx context.Context,
	authConfig *enterprise_gloo_solo_io_v1_types.AuthConfig,
	authConfigSet sk_sets.ResourceSet[*enterprise_gloo_solo_io_v1_types.AuthConfig],
	buildOpts BuildOptions,
) {

	opts := buildOpts.AuthConfigs.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = authConfig.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(authConfig.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		authConfigSet.Insert(authConfig)
	}
}

func (i *inMemoryBuilder) insertRateLimitConfig(
	ctx context.Context,
	rateLimitConfig *ratelimit_api_solo_io_v1alpha1_types.RateLimitConfig,
	rateLimitConfigSet sk_sets.ResourceSet[*ratelimit_api_solo_io_v1alpha1_types.RateLimitConfig],
	buildOpts BuildOptions,
) {

	opts := buildOpts.RateLimitConfigs.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = rateLimitConfig.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(rateLimitConfig.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		rateLimitConfigSet.Insert(rateLimitConfig)
	}
}
