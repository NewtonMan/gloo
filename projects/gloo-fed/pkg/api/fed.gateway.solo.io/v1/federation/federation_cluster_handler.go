// Code generated by skv2. DO NOT EDIT.

// Definition for federated resource cluster handler templates
package federation

import (
	"context"

	"github.com/avast/retry-go"
	"github.com/solo-io/go-utils/contextutils"
	"github.com/solo-io/skv2/pkg/multicluster"
	fed_gateway_solo_io_v1 "github.com/solo-io/solo-projects/projects/gloo-fed/pkg/api/fed.gateway.solo.io/v1"
	mc_types "github.com/solo-io/solo-projects/projects/gloo-fed/pkg/api/fed.solo.io/core/v1"
	"github.com/solo-io/solo-projects/projects/gloo-fed/pkg/federation/placement"
	"go.uber.org/zap"
	"k8s.io/apimachinery/pkg/api/errors"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/manager"
)

var ClusterHandlerRetryAttempts uint = 5

type clusterHandler struct {
	ctx     context.Context
	clients fed_gateway_solo_io_v1.Clientset
	factory placement.StatusBuilderFactory
}

func NewClusterHandler(ctx context.Context, clients fed_gateway_solo_io_v1.Clientset, factory placement.StatusBuilderFactory) multicluster.ClusterHandler {
	return &clusterHandler{
		ctx:     ctx,
		clients: clients,
		factory: factory,
	}
}

func (f *clusterHandler) AddCluster(_ context.Context, cluster string, _ manager.Manager) {
	f.handleClusterEvent(cluster)
}

func (f *clusterHandler) RemoveCluster(cluster string) {
	f.handleClusterEvent(cluster)
}

func (f *clusterHandler) handleClusterEvent(cluster string) {

	federatedGatewayList, err := f.clients.FederatedGateways().ListFederatedGateway(f.ctx)
	if err != nil {
		contextutils.LoggerFrom(f.ctx).Errorf("Failed to list FederatedGateways referencing cluster %s", cluster)
	} else {
		for _, item := range federatedGatewayList.Items {
			item := item
			if err := f.maybeUpdateFederatedGatewayStatusWithRetries(&item, cluster); err != nil {
				contextutils.LoggerFrom(f.ctx).Errorw("Failed to update status on FederatedGateway",
					zap.Error(err),
					zap.Any("FederatedGateway", item))
			}
		}
	}

	federatedVirtualServiceList, err := f.clients.FederatedVirtualServices().ListFederatedVirtualService(f.ctx)
	if err != nil {
		contextutils.LoggerFrom(f.ctx).Errorf("Failed to list FederatedVirtualServices referencing cluster %s", cluster)
	} else {
		for _, item := range federatedVirtualServiceList.Items {
			item := item
			if err := f.maybeUpdateFederatedVirtualServiceStatusWithRetries(&item, cluster); err != nil {
				contextutils.LoggerFrom(f.ctx).Errorw("Failed to update status on FederatedVirtualService",
					zap.Error(err),
					zap.Any("FederatedVirtualService", item))
			}
		}
	}

	federatedRouteTableList, err := f.clients.FederatedRouteTables().ListFederatedRouteTable(f.ctx)
	if err != nil {
		contextutils.LoggerFrom(f.ctx).Errorf("Failed to list FederatedRouteTables referencing cluster %s", cluster)
	} else {
		for _, item := range federatedRouteTableList.Items {
			item := item
			if err := f.maybeUpdateFederatedRouteTableStatusWithRetries(&item, cluster); err != nil {
				contextutils.LoggerFrom(f.ctx).Errorw("Failed to update status on FederatedRouteTable",
					zap.Error(err),
					zap.Any("FederatedRouteTable", item))
			}
		}
	}
}

func (f *clusterHandler) maybeUpdateFederatedGatewayStatusWithRetries(item *fed_gateway_solo_io_v1.FederatedGateway, cluster string) error {
	return retry.Do(func() error {
		err := f.maybeUpdateFederatedGatewayStatus(item, cluster)
		if err != nil && errors.IsNotFound(err) {
			// If the resource no longer exists, there is nothing to do.
			return nil
		} else if err != nil {
			// On conflict, retry with the new object to pick up any changes to the resource's spec.
			obj, err := f.clients.FederatedGateways().GetFederatedGateway(f.ctx, client.ObjectKey{Namespace: item.Namespace, Name: item.Name})
			if err != nil {
				return err
			}
			item = obj
		}
		return err
	}, retry.Attempts(ClusterHandlerRetryAttempts))
}

func (f *clusterHandler) maybeUpdateFederatedGatewayStatus(item *fed_gateway_solo_io_v1.FederatedGateway, cluster string) error {
	for _, c := range item.Spec.Placement.GetClusters() {
		if c == cluster {
			// An existing resource references the given cluster. Update its status to trigger a resync.
			item.Status.PlacementStatus = f.factory.GetBuilder().
				UpdateUnprocessed(item.Status.PlacementStatus, placement.ClusterEventTriggered(cluster), mc_types.PlacementStatus_PENDING).
				// Do not update the observed generation or written by fields as we have not actually processed the resource.
				Eject(item.Status.PlacementStatus.GetObservedGeneration())

			return f.clients.FederatedGateways().UpdateFederatedGatewayStatus(f.ctx, item)
		}
	}
	return nil
}

func (f *clusterHandler) maybeUpdateFederatedVirtualServiceStatusWithRetries(item *fed_gateway_solo_io_v1.FederatedVirtualService, cluster string) error {
	return retry.Do(func() error {
		err := f.maybeUpdateFederatedVirtualServiceStatus(item, cluster)
		if err != nil && errors.IsNotFound(err) {
			// If the resource no longer exists, there is nothing to do.
			return nil
		} else if err != nil {
			// On conflict, retry with the new object to pick up any changes to the resource's spec.
			obj, err := f.clients.FederatedVirtualServices().GetFederatedVirtualService(f.ctx, client.ObjectKey{Namespace: item.Namespace, Name: item.Name})
			if err != nil {
				return err
			}
			item = obj
		}
		return err
	}, retry.Attempts(ClusterHandlerRetryAttempts))
}

func (f *clusterHandler) maybeUpdateFederatedVirtualServiceStatus(item *fed_gateway_solo_io_v1.FederatedVirtualService, cluster string) error {
	for _, c := range item.Spec.Placement.GetClusters() {
		if c == cluster {
			// An existing resource references the given cluster. Update its status to trigger a resync.
			item.Status.PlacementStatus = f.factory.GetBuilder().
				UpdateUnprocessed(item.Status.PlacementStatus, placement.ClusterEventTriggered(cluster), mc_types.PlacementStatus_PENDING).
				// Do not update the observed generation or written by fields as we have not actually processed the resource.
				Eject(item.Status.PlacementStatus.GetObservedGeneration())

			return f.clients.FederatedVirtualServices().UpdateFederatedVirtualServiceStatus(f.ctx, item)
		}
	}
	return nil
}

func (f *clusterHandler) maybeUpdateFederatedRouteTableStatusWithRetries(item *fed_gateway_solo_io_v1.FederatedRouteTable, cluster string) error {
	return retry.Do(func() error {
		err := f.maybeUpdateFederatedRouteTableStatus(item, cluster)
		if err != nil && errors.IsNotFound(err) {
			// If the resource no longer exists, there is nothing to do.
			return nil
		} else if err != nil {
			// On conflict, retry with the new object to pick up any changes to the resource's spec.
			obj, err := f.clients.FederatedRouteTables().GetFederatedRouteTable(f.ctx, client.ObjectKey{Namespace: item.Namespace, Name: item.Name})
			if err != nil {
				return err
			}
			item = obj
		}
		return err
	}, retry.Attempts(ClusterHandlerRetryAttempts))
}

func (f *clusterHandler) maybeUpdateFederatedRouteTableStatus(item *fed_gateway_solo_io_v1.FederatedRouteTable, cluster string) error {
	for _, c := range item.Spec.Placement.GetClusters() {
		if c == cluster {
			// An existing resource references the given cluster. Update its status to trigger a resync.
			item.Status.PlacementStatus = f.factory.GetBuilder().
				UpdateUnprocessed(item.Status.PlacementStatus, placement.ClusterEventTriggered(cluster), mc_types.PlacementStatus_PENDING).
				// Do not update the observed generation or written by fields as we have not actually processed the resource.
				Eject(item.Status.PlacementStatus.GetObservedGeneration())

			return f.clients.FederatedRouteTables().UpdateFederatedRouteTableStatus(f.ctx, item)
		}
	}
	return nil
}
