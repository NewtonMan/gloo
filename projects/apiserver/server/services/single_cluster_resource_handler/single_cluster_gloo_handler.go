// Code generated by skv2. DO NOT EDIT.

package single_cluster_resource_handler

import (
	"context"
	"sort"
	"strings"

	"github.com/ghodss/yaml"
	"github.com/rotisserie/eris"
	"github.com/solo-io/go-utils/contextutils"
	skv2_v1 "github.com/solo-io/skv2/pkg/api/core.skv2.solo.io/v1"
	gloo_solo_io_v1 "github.com/solo-io/solo-apis/pkg/api/gloo.solo.io/v1"
	rpc_edge_v1 "github.com/solo-io/solo-projects/projects/apiserver/pkg/api/rpc.edge.gloo/v1"
	"github.com/solo-io/solo-projects/projects/apiserver/server/apiserverutils"
	"github.com/solo-io/solo-projects/projects/apiserver/server/services/glooinstance_handler"
	"go.uber.org/zap"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

func NewSingleClusterGlooResourceHandler(
	glooClientset gloo_solo_io_v1.Clientset,
	glooInstanceLister glooinstance_handler.SingleClusterGlooInstanceLister,
) rpc_edge_v1.GlooResourceApiServer {
	return &singleClusterGlooResourceHandler{
		glooClientset:      glooClientset,
		glooInstanceLister: glooInstanceLister,
	}
}

type singleClusterGlooResourceHandler struct {
	glooClientset      gloo_solo_io_v1.Clientset
	glooInstanceLister glooinstance_handler.SingleClusterGlooInstanceLister
}

func (h *singleClusterGlooResourceHandler) ListUpstreams(ctx context.Context, request *rpc_edge_v1.ListUpstreamsRequest) (*rpc_edge_v1.ListUpstreamsResponse, error) {
	var rpcUpstreams []*rpc_edge_v1.Upstream
	if request.GetGlooInstanceRef() == nil || request.GetGlooInstanceRef().GetName() == "" || request.GetGlooInstanceRef().GetNamespace() == "" {
		// List upstreams across all gloo edge instances
		instanceList, err := h.glooInstanceLister.ListGlooInstances(ctx)
		if err != nil {
			wrapped := eris.Wrapf(err, "Failed to list gloo edge instances")
			contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
			return nil, wrapped
		}
		for _, instance := range instanceList {
			rpcUpstreamList, err := h.listUpstreamsForGlooInstance(ctx, instance)
			if err != nil {
				wrapped := eris.Wrapf(err, "Failed to list upstreams for gloo edge instance %v", instance)
				contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
				return nil, wrapped
			}
			rpcUpstreams = append(rpcUpstreams, rpcUpstreamList...)
		}
	} else {
		// List upstreams for a specific gloo edge instance
		instance, err := h.glooInstanceLister.GetGlooInstance(ctx, request.GetGlooInstanceRef())
		if err != nil {
			wrapped := eris.Wrap(err, "Failed to get gloo edge instance")
			contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
			return nil, wrapped
		}
		rpcUpstreams, err = h.listUpstreamsForGlooInstance(ctx, instance)
		if err != nil {
			wrapped := eris.Wrapf(err, "Failed to list upstreams for gloo edge instance %v", instance)
			contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
			return nil, wrapped
		}
	}

	// Search, Filter
	var filteredUpstreams []*rpc_edge_v1.Upstream
	qs := request.GetQueryString()
	sf := request.GetStatusFilter()
	if sf != nil || qs != "" {
		for _, d := range rpcUpstreams {
			if (sf == nil || sf.State == int32(d.Status.State)) && strings.Contains(d.Metadata.Name, qs) {
				filteredUpstreams = append(filteredUpstreams, d)
			}
		}
	} else {
		filteredUpstreams = rpcUpstreams
	}
	// Sort
	sortOptions := request.GetSortOptions()
	if sortOptions != nil {
		isDescending := sortOptions.GetDescending()
		sortKey := sortOptions.GetSortKey()
		if isDescending == true {
			switch sortKey {
			case rpc_edge_v1.SortOptions_NAME:
				sort.SliceStable(filteredUpstreams, func(i, j int) bool {
					a := filteredUpstreams[i]
					b := filteredUpstreams[j]
					return a.Metadata.Name+a.Metadata.Namespace+string(a.Status.State) > b.Metadata.Name+b.Metadata.Namespace+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_NAMESPACE:
				sort.SliceStable(filteredUpstreams, func(i, j int) bool {
					a := filteredUpstreams[i]
					b := filteredUpstreams[j]
					return a.Metadata.Namespace+a.Metadata.Name+string(a.Status.State) > b.Metadata.Namespace+b.Metadata.Name+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_STATUS:
				sort.SliceStable(filteredUpstreams, func(i, j int) bool {
					a := filteredUpstreams[i]
					b := filteredUpstreams[j]
					return string(a.Status.State)+a.Metadata.Name+a.Metadata.Namespace > string(b.Status.State)+b.Metadata.Name+b.Metadata.Namespace
				})
			}
		} else {
			switch sortKey {
			case rpc_edge_v1.SortOptions_NAME:
				sort.SliceStable(filteredUpstreams, func(i, j int) bool {
					a := filteredUpstreams[i]
					b := filteredUpstreams[j]
					return a.Metadata.Name+a.Metadata.Namespace+string(a.Status.State) < b.Metadata.Name+b.Metadata.Namespace+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_NAMESPACE:
				sort.SliceStable(filteredUpstreams, func(i, j int) bool {
					a := filteredUpstreams[i]
					b := filteredUpstreams[j]
					return a.Metadata.Namespace+a.Metadata.Name+string(a.Status.State) < b.Metadata.Namespace+b.Metadata.Name+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_STATUS:
				sort.SliceStable(filteredUpstreams, func(i, j int) bool {
					a := filteredUpstreams[i]
					b := filteredUpstreams[j]
					return string(a.Status.State)+a.Metadata.Name+a.Metadata.Namespace < string(b.Status.State)+b.Metadata.Name+b.Metadata.Namespace
				})
			}
		}
	}
	// Paginate
	paginatedUpstreams := filteredUpstreams
	pagination := request.GetPagination()
	totalCount := int32(len(filteredUpstreams))
	if pagination.GetLimit() > 0 && pagination.GetOffset() >= 0 {
		start := apiserverutils.Min(pagination.GetOffset(), totalCount)
		end := apiserverutils.Min(pagination.GetOffset()+pagination.GetLimit(), totalCount)
		paginatedUpstreams = filteredUpstreams[start:end]
	}
	// Build response
	res := &rpc_edge_v1.ListUpstreamsResponse{
		Upstreams: paginatedUpstreams,
		Total:     totalCount,
	}
	return res, nil
}

func (h *singleClusterGlooResourceHandler) listUpstreamsForGlooInstance(ctx context.Context, instance *rpc_edge_v1.GlooInstance) ([]*rpc_edge_v1.Upstream, error) {
	var upstreamList []*gloo_solo_io_v1.Upstream
	watchedNamespaces := instance.Spec.GetControlPlane().GetWatchedNamespaces()
	if len(watchedNamespaces) != 0 {
		for _, ns := range watchedNamespaces {
			list, err := h.glooClientset.Upstreams().ListUpstream(ctx, client.InNamespace(ns))
			if err != nil {
				return nil, err
			}
			for i, _ := range list.Items {
				upstreamList = append(upstreamList, &list.Items[i])
			}
		}
	} else {
		list, err := h.glooClientset.Upstreams().ListUpstream(ctx)
		if err != nil {
			return nil, err
		}
		for i, _ := range list.Items {
			upstreamList = append(upstreamList, &list.Items[i])
		}
	}
	sort.Slice(upstreamList, func(i, j int) bool {
		x := upstreamList[i]
		y := upstreamList[j]
		return x.GetNamespace()+x.GetName() < y.GetNamespace()+y.GetName()
	})

	var rpcUpstreams []*rpc_edge_v1.Upstream
	glooInstanceRef := &skv2_v1.ObjectRef{
		Name:      instance.GetMetadata().GetName(),
		Namespace: instance.GetMetadata().GetNamespace(),
	}
	for _, upstream := range upstreamList {
		rpcUpstreams = append(rpcUpstreams, &rpc_edge_v1.Upstream{
			Metadata:     apiserverutils.ToMetadata(upstream.ObjectMeta),
			GlooInstance: glooInstanceRef,
			Spec:         &upstream.Spec,
			Status:       &upstream.Status,
		})
	}
	return rpcUpstreams, nil
}

func (h *singleClusterGlooResourceHandler) GetUpstreamYaml(ctx context.Context, request *rpc_edge_v1.GetUpstreamYamlRequest) (*rpc_edge_v1.GetUpstreamYamlResponse, error) {
	upstream, err := h.glooClientset.Upstreams().GetUpstream(ctx, client.ObjectKey{
		Namespace: request.GetUpstreamRef().GetNamespace(),
		Name:      request.GetUpstreamRef().GetName(),
	})
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to get upstream")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	content, err := yaml.Marshal(upstream)
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to marshal kube resource into yaml")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	return &rpc_edge_v1.GetUpstreamYamlResponse{
		YamlData: &rpc_edge_v1.ResourceYaml{
			Yaml: string(content),
		},
	}, nil
}

func (h *singleClusterGlooResourceHandler) GetUpstreamDetails(ctx context.Context, request *rpc_edge_v1.GetUpstreamDetailsRequest) (*rpc_edge_v1.GetUpstreamDetailsResponse, error) {
	UpstreamRef := request.GetUpstreamRef()
	if UpstreamRef == nil {
		return nil, eris.Errorf("Upstream ref missing from request: %v", request)
	}
	Upstream, err := h.glooClientset.Upstreams().GetUpstream(ctx, client.ObjectKey{
		Namespace: UpstreamRef.GetNamespace(),
		Name:      UpstreamRef.GetName(),
	})
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to get Upstream")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	// find which gloo instance this Upstream belongs to, by finding a gloo instance that is watching
	// the Upstream's namespace
	instanceList, err := h.glooInstanceLister.ListGlooInstances(ctx)
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to list gloo edge instances")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	var glooInstance *rpc_edge_v1.GlooInstance
	for _, instance := range instanceList {
		watchedNamespaces := instance.Spec.GetControlPlane().GetWatchedNamespaces()
		if len(watchedNamespaces) == 0 {
			glooInstance = instance
			break
		}
		for _, ns := range watchedNamespaces {
			if ns == UpstreamRef.GetNamespace() {
				glooInstance = instance
				break
			}
		}
		if glooInstance != nil {
			break
		}
	}
	if glooInstance == nil {
		return nil, eris.Errorf("Failed to find a gloo edge instance for namespace %s", Upstream.GetNamespace())
	}
	rpcUpstream := &rpc_edge_v1.Upstream{
		Metadata: apiserverutils.ToMetadata(Upstream.ObjectMeta),
		GlooInstance: &skv2_v1.ObjectRef{
			Name:      glooInstance.GetMetadata().GetName(),
			Namespace: glooInstance.GetMetadata().GetNamespace(),
		},
		Spec:   &Upstream.Spec,
		Status: &Upstream.Status,
	}
	rpcUpstream.Metadata.ClusterName = glooInstance.GetSpec().GetCluster()
	return &rpc_edge_v1.GetUpstreamDetailsResponse{
		Upstream: rpcUpstream,
	}, nil
}

func (h *singleClusterGlooResourceHandler) ListUpstreamGroups(ctx context.Context, request *rpc_edge_v1.ListUpstreamGroupsRequest) (*rpc_edge_v1.ListUpstreamGroupsResponse, error) {
	var rpcUpstreamGroups []*rpc_edge_v1.UpstreamGroup
	if request.GetGlooInstanceRef() == nil || request.GetGlooInstanceRef().GetName() == "" || request.GetGlooInstanceRef().GetNamespace() == "" {
		// List upstreamGroups across all gloo edge instances
		instanceList, err := h.glooInstanceLister.ListGlooInstances(ctx)
		if err != nil {
			wrapped := eris.Wrapf(err, "Failed to list gloo edge instances")
			contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
			return nil, wrapped
		}
		for _, instance := range instanceList {
			rpcUpstreamGroupList, err := h.listUpstreamGroupsForGlooInstance(ctx, instance)
			if err != nil {
				wrapped := eris.Wrapf(err, "Failed to list upstreamGroups for gloo edge instance %v", instance)
				contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
				return nil, wrapped
			}
			rpcUpstreamGroups = append(rpcUpstreamGroups, rpcUpstreamGroupList...)
		}
	} else {
		// List upstreamGroups for a specific gloo edge instance
		instance, err := h.glooInstanceLister.GetGlooInstance(ctx, request.GetGlooInstanceRef())
		if err != nil {
			wrapped := eris.Wrap(err, "Failed to get gloo edge instance")
			contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
			return nil, wrapped
		}
		rpcUpstreamGroups, err = h.listUpstreamGroupsForGlooInstance(ctx, instance)
		if err != nil {
			wrapped := eris.Wrapf(err, "Failed to list upstreamGroups for gloo edge instance %v", instance)
			contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
			return nil, wrapped
		}
	}

	// Search, Filter
	var filteredUpstreamGroups []*rpc_edge_v1.UpstreamGroup
	qs := request.GetQueryString()
	sf := request.GetStatusFilter()
	if sf != nil || qs != "" {
		for _, d := range rpcUpstreamGroups {
			if (sf == nil || sf.State == int32(d.Status.State)) && strings.Contains(d.Metadata.Name, qs) {
				filteredUpstreamGroups = append(filteredUpstreamGroups, d)
			}
		}
	} else {
		filteredUpstreamGroups = rpcUpstreamGroups
	}
	// Sort
	sortOptions := request.GetSortOptions()
	if sortOptions != nil {
		isDescending := sortOptions.GetDescending()
		sortKey := sortOptions.GetSortKey()
		if isDescending == true {
			switch sortKey {
			case rpc_edge_v1.SortOptions_NAME:
				sort.SliceStable(filteredUpstreamGroups, func(i, j int) bool {
					a := filteredUpstreamGroups[i]
					b := filteredUpstreamGroups[j]
					return a.Metadata.Name+a.Metadata.Namespace+string(a.Status.State) > b.Metadata.Name+b.Metadata.Namespace+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_NAMESPACE:
				sort.SliceStable(filteredUpstreamGroups, func(i, j int) bool {
					a := filteredUpstreamGroups[i]
					b := filteredUpstreamGroups[j]
					return a.Metadata.Namespace+a.Metadata.Name+string(a.Status.State) > b.Metadata.Namespace+b.Metadata.Name+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_STATUS:
				sort.SliceStable(filteredUpstreamGroups, func(i, j int) bool {
					a := filteredUpstreamGroups[i]
					b := filteredUpstreamGroups[j]
					return string(a.Status.State)+a.Metadata.Name+a.Metadata.Namespace > string(b.Status.State)+b.Metadata.Name+b.Metadata.Namespace
				})
			}
		} else {
			switch sortKey {
			case rpc_edge_v1.SortOptions_NAME:
				sort.SliceStable(filteredUpstreamGroups, func(i, j int) bool {
					a := filteredUpstreamGroups[i]
					b := filteredUpstreamGroups[j]
					return a.Metadata.Name+a.Metadata.Namespace+string(a.Status.State) < b.Metadata.Name+b.Metadata.Namespace+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_NAMESPACE:
				sort.SliceStable(filteredUpstreamGroups, func(i, j int) bool {
					a := filteredUpstreamGroups[i]
					b := filteredUpstreamGroups[j]
					return a.Metadata.Namespace+a.Metadata.Name+string(a.Status.State) < b.Metadata.Namespace+b.Metadata.Name+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_STATUS:
				sort.SliceStable(filteredUpstreamGroups, func(i, j int) bool {
					a := filteredUpstreamGroups[i]
					b := filteredUpstreamGroups[j]
					return string(a.Status.State)+a.Metadata.Name+a.Metadata.Namespace < string(b.Status.State)+b.Metadata.Name+b.Metadata.Namespace
				})
			}
		}
	}
	// Paginate
	paginatedUpstreamGroups := filteredUpstreamGroups
	pagination := request.GetPagination()
	totalCount := int32(len(filteredUpstreamGroups))
	if pagination.GetLimit() > 0 && pagination.GetOffset() >= 0 {
		start := apiserverutils.Min(pagination.GetOffset(), totalCount)
		end := apiserverutils.Min(pagination.GetOffset()+pagination.GetLimit(), totalCount)
		paginatedUpstreamGroups = filteredUpstreamGroups[start:end]
	}
	// Build response
	res := &rpc_edge_v1.ListUpstreamGroupsResponse{
		UpstreamGroups: paginatedUpstreamGroups,
		Total:          totalCount,
	}
	return res, nil
}

func (h *singleClusterGlooResourceHandler) listUpstreamGroupsForGlooInstance(ctx context.Context, instance *rpc_edge_v1.GlooInstance) ([]*rpc_edge_v1.UpstreamGroup, error) {
	var upstreamGroupList []*gloo_solo_io_v1.UpstreamGroup
	watchedNamespaces := instance.Spec.GetControlPlane().GetWatchedNamespaces()
	if len(watchedNamespaces) != 0 {
		for _, ns := range watchedNamespaces {
			list, err := h.glooClientset.UpstreamGroups().ListUpstreamGroup(ctx, client.InNamespace(ns))
			if err != nil {
				return nil, err
			}
			for i, _ := range list.Items {
				upstreamGroupList = append(upstreamGroupList, &list.Items[i])
			}
		}
	} else {
		list, err := h.glooClientset.UpstreamGroups().ListUpstreamGroup(ctx)
		if err != nil {
			return nil, err
		}
		for i, _ := range list.Items {
			upstreamGroupList = append(upstreamGroupList, &list.Items[i])
		}
	}
	sort.Slice(upstreamGroupList, func(i, j int) bool {
		x := upstreamGroupList[i]
		y := upstreamGroupList[j]
		return x.GetNamespace()+x.GetName() < y.GetNamespace()+y.GetName()
	})

	var rpcUpstreamGroups []*rpc_edge_v1.UpstreamGroup
	glooInstanceRef := &skv2_v1.ObjectRef{
		Name:      instance.GetMetadata().GetName(),
		Namespace: instance.GetMetadata().GetNamespace(),
	}
	for _, upstreamGroup := range upstreamGroupList {
		rpcUpstreamGroups = append(rpcUpstreamGroups, &rpc_edge_v1.UpstreamGroup{
			Metadata:     apiserverutils.ToMetadata(upstreamGroup.ObjectMeta),
			GlooInstance: glooInstanceRef,
			Spec:         &upstreamGroup.Spec,
			Status:       &upstreamGroup.Status,
		})
	}
	return rpcUpstreamGroups, nil
}

func (h *singleClusterGlooResourceHandler) GetUpstreamGroupYaml(ctx context.Context, request *rpc_edge_v1.GetUpstreamGroupYamlRequest) (*rpc_edge_v1.GetUpstreamGroupYamlResponse, error) {
	upstreamGroup, err := h.glooClientset.UpstreamGroups().GetUpstreamGroup(ctx, client.ObjectKey{
		Namespace: request.GetUpstreamGroupRef().GetNamespace(),
		Name:      request.GetUpstreamGroupRef().GetName(),
	})
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to get upstreamGroup")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	content, err := yaml.Marshal(upstreamGroup)
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to marshal kube resource into yaml")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	return &rpc_edge_v1.GetUpstreamGroupYamlResponse{
		YamlData: &rpc_edge_v1.ResourceYaml{
			Yaml: string(content),
		},
	}, nil
}

func (h *singleClusterGlooResourceHandler) GetUpstreamGroupDetails(ctx context.Context, request *rpc_edge_v1.GetUpstreamGroupDetailsRequest) (*rpc_edge_v1.GetUpstreamGroupDetailsResponse, error) {
	UpstreamGroupRef := request.GetUpstreamGroupRef()
	if UpstreamGroupRef == nil {
		return nil, eris.Errorf("UpstreamGroup ref missing from request: %v", request)
	}
	UpstreamGroup, err := h.glooClientset.UpstreamGroups().GetUpstreamGroup(ctx, client.ObjectKey{
		Namespace: UpstreamGroupRef.GetNamespace(),
		Name:      UpstreamGroupRef.GetName(),
	})
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to get UpstreamGroup")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	// find which gloo instance this UpstreamGroup belongs to, by finding a gloo instance that is watching
	// the UpstreamGroup's namespace
	instanceList, err := h.glooInstanceLister.ListGlooInstances(ctx)
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to list gloo edge instances")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	var glooInstance *rpc_edge_v1.GlooInstance
	for _, instance := range instanceList {
		watchedNamespaces := instance.Spec.GetControlPlane().GetWatchedNamespaces()
		if len(watchedNamespaces) == 0 {
			glooInstance = instance
			break
		}
		for _, ns := range watchedNamespaces {
			if ns == UpstreamGroupRef.GetNamespace() {
				glooInstance = instance
				break
			}
		}
		if glooInstance != nil {
			break
		}
	}
	if glooInstance == nil {
		return nil, eris.Errorf("Failed to find a gloo edge instance for namespace %s", UpstreamGroup.GetNamespace())
	}
	rpcUpstreamGroup := &rpc_edge_v1.UpstreamGroup{
		Metadata: apiserverutils.ToMetadata(UpstreamGroup.ObjectMeta),
		GlooInstance: &skv2_v1.ObjectRef{
			Name:      glooInstance.GetMetadata().GetName(),
			Namespace: glooInstance.GetMetadata().GetNamespace(),
		},
		Spec:   &UpstreamGroup.Spec,
		Status: &UpstreamGroup.Status,
	}
	rpcUpstreamGroup.Metadata.ClusterName = glooInstance.GetSpec().GetCluster()
	return &rpc_edge_v1.GetUpstreamGroupDetailsResponse{
		UpstreamGroup: rpcUpstreamGroup,
	}, nil
}

func (h *singleClusterGlooResourceHandler) ListSettings(ctx context.Context, request *rpc_edge_v1.ListSettingsRequest) (*rpc_edge_v1.ListSettingsResponse, error) {
	var rpcSettings []*rpc_edge_v1.Settings
	if request.GetGlooInstanceRef() == nil || request.GetGlooInstanceRef().GetName() == "" || request.GetGlooInstanceRef().GetNamespace() == "" {
		// List settings across all gloo edge instances
		instanceList, err := h.glooInstanceLister.ListGlooInstances(ctx)
		if err != nil {
			wrapped := eris.Wrapf(err, "Failed to list gloo edge instances")
			contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
			return nil, wrapped
		}
		for _, instance := range instanceList {
			rpcSettingsList, err := h.listSettingsForGlooInstance(ctx, instance)
			if err != nil {
				wrapped := eris.Wrapf(err, "Failed to list settings for gloo edge instance %v", instance)
				contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
				return nil, wrapped
			}
			rpcSettings = append(rpcSettings, rpcSettingsList...)
		}
	} else {
		// List settings for a specific gloo edge instance
		instance, err := h.glooInstanceLister.GetGlooInstance(ctx, request.GetGlooInstanceRef())
		if err != nil {
			wrapped := eris.Wrap(err, "Failed to get gloo edge instance")
			contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
			return nil, wrapped
		}
		rpcSettings, err = h.listSettingsForGlooInstance(ctx, instance)
		if err != nil {
			wrapped := eris.Wrapf(err, "Failed to list settings for gloo edge instance %v", instance)
			contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
			return nil, wrapped
		}
	}

	// Search, Filter
	var filteredSettings []*rpc_edge_v1.Settings
	qs := request.GetQueryString()
	sf := request.GetStatusFilter()
	if sf != nil || qs != "" {
		for _, d := range rpcSettings {
			if (sf == nil || sf.State == int32(d.Status.State)) && strings.Contains(d.Metadata.Name, qs) {
				filteredSettings = append(filteredSettings, d)
			}
		}
	} else {
		filteredSettings = rpcSettings
	}
	// Sort
	sortOptions := request.GetSortOptions()
	if sortOptions != nil {
		isDescending := sortOptions.GetDescending()
		sortKey := sortOptions.GetSortKey()
		if isDescending == true {
			switch sortKey {
			case rpc_edge_v1.SortOptions_NAME:
				sort.SliceStable(filteredSettings, func(i, j int) bool {
					a := filteredSettings[i]
					b := filteredSettings[j]
					return a.Metadata.Name+a.Metadata.Namespace+string(a.Status.State) > b.Metadata.Name+b.Metadata.Namespace+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_NAMESPACE:
				sort.SliceStable(filteredSettings, func(i, j int) bool {
					a := filteredSettings[i]
					b := filteredSettings[j]
					return a.Metadata.Namespace+a.Metadata.Name+string(a.Status.State) > b.Metadata.Namespace+b.Metadata.Name+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_STATUS:
				sort.SliceStable(filteredSettings, func(i, j int) bool {
					a := filteredSettings[i]
					b := filteredSettings[j]
					return string(a.Status.State)+a.Metadata.Name+a.Metadata.Namespace > string(b.Status.State)+b.Metadata.Name+b.Metadata.Namespace
				})
			}
		} else {
			switch sortKey {
			case rpc_edge_v1.SortOptions_NAME:
				sort.SliceStable(filteredSettings, func(i, j int) bool {
					a := filteredSettings[i]
					b := filteredSettings[j]
					return a.Metadata.Name+a.Metadata.Namespace+string(a.Status.State) < b.Metadata.Name+b.Metadata.Namespace+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_NAMESPACE:
				sort.SliceStable(filteredSettings, func(i, j int) bool {
					a := filteredSettings[i]
					b := filteredSettings[j]
					return a.Metadata.Namespace+a.Metadata.Name+string(a.Status.State) < b.Metadata.Namespace+b.Metadata.Name+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_STATUS:
				sort.SliceStable(filteredSettings, func(i, j int) bool {
					a := filteredSettings[i]
					b := filteredSettings[j]
					return string(a.Status.State)+a.Metadata.Name+a.Metadata.Namespace < string(b.Status.State)+b.Metadata.Name+b.Metadata.Namespace
				})
			}
		}
	}
	// Paginate
	paginatedSettings := filteredSettings
	pagination := request.GetPagination()
	totalCount := int32(len(filteredSettings))
	if pagination.GetLimit() > 0 && pagination.GetOffset() >= 0 {
		start := apiserverutils.Min(pagination.GetOffset(), totalCount)
		end := apiserverutils.Min(pagination.GetOffset()+pagination.GetLimit(), totalCount)
		paginatedSettings = filteredSettings[start:end]
	}
	// Build response
	res := &rpc_edge_v1.ListSettingsResponse{
		Settings: paginatedSettings,
		Total:    totalCount,
	}
	return res, nil
}

func (h *singleClusterGlooResourceHandler) listSettingsForGlooInstance(ctx context.Context, instance *rpc_edge_v1.GlooInstance) ([]*rpc_edge_v1.Settings, error) {
	var settingsList []*gloo_solo_io_v1.Settings
	watchedNamespaces := instance.Spec.GetControlPlane().GetWatchedNamespaces()
	if len(watchedNamespaces) != 0 {
		for _, ns := range watchedNamespaces {
			list, err := h.glooClientset.Settings().ListSettings(ctx, client.InNamespace(ns))
			if err != nil {
				return nil, err
			}
			for i, _ := range list.Items {
				settingsList = append(settingsList, &list.Items[i])
			}
		}
	} else {
		list, err := h.glooClientset.Settings().ListSettings(ctx)
		if err != nil {
			return nil, err
		}
		for i, _ := range list.Items {
			settingsList = append(settingsList, &list.Items[i])
		}
	}
	sort.Slice(settingsList, func(i, j int) bool {
		x := settingsList[i]
		y := settingsList[j]
		return x.GetNamespace()+x.GetName() < y.GetNamespace()+y.GetName()
	})

	var rpcSettings []*rpc_edge_v1.Settings
	glooInstanceRef := &skv2_v1.ObjectRef{
		Name:      instance.GetMetadata().GetName(),
		Namespace: instance.GetMetadata().GetNamespace(),
	}
	for _, settings := range settingsList {
		rpcSettings = append(rpcSettings, &rpc_edge_v1.Settings{
			Metadata:     apiserverutils.ToMetadata(settings.ObjectMeta),
			GlooInstance: glooInstanceRef,
			Spec:         &settings.Spec,
			Status:       &settings.Status,
		})
	}
	return rpcSettings, nil
}

func (h *singleClusterGlooResourceHandler) GetSettingsYaml(ctx context.Context, request *rpc_edge_v1.GetSettingsYamlRequest) (*rpc_edge_v1.GetSettingsYamlResponse, error) {
	settings, err := h.glooClientset.Settings().GetSettings(ctx, client.ObjectKey{
		Namespace: request.GetSettingsRef().GetNamespace(),
		Name:      request.GetSettingsRef().GetName(),
	})
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to get settings")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	content, err := yaml.Marshal(settings)
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to marshal kube resource into yaml")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	return &rpc_edge_v1.GetSettingsYamlResponse{
		YamlData: &rpc_edge_v1.ResourceYaml{
			Yaml: string(content),
		},
	}, nil
}

func (h *singleClusterGlooResourceHandler) GetSettingsDetails(ctx context.Context, request *rpc_edge_v1.GetSettingsDetailsRequest) (*rpc_edge_v1.GetSettingsDetailsResponse, error) {
	SettingsRef := request.GetSettingsRef()
	if SettingsRef == nil {
		return nil, eris.Errorf("Settings ref missing from request: %v", request)
	}
	Settings, err := h.glooClientset.Settings().GetSettings(ctx, client.ObjectKey{
		Namespace: SettingsRef.GetNamespace(),
		Name:      SettingsRef.GetName(),
	})
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to get Settings")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	// find which gloo instance this Settings belongs to, by finding a gloo instance that is watching
	// the Settings's namespace
	instanceList, err := h.glooInstanceLister.ListGlooInstances(ctx)
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to list gloo edge instances")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	var glooInstance *rpc_edge_v1.GlooInstance
	for _, instance := range instanceList {
		watchedNamespaces := instance.Spec.GetControlPlane().GetWatchedNamespaces()
		if len(watchedNamespaces) == 0 {
			glooInstance = instance
			break
		}
		for _, ns := range watchedNamespaces {
			if ns == SettingsRef.GetNamespace() {
				glooInstance = instance
				break
			}
		}
		if glooInstance != nil {
			break
		}
	}
	if glooInstance == nil {
		return nil, eris.Errorf("Failed to find a gloo edge instance for namespace %s", Settings.GetNamespace())
	}
	rpcSettings := &rpc_edge_v1.Settings{
		Metadata: apiserverutils.ToMetadata(Settings.ObjectMeta),
		GlooInstance: &skv2_v1.ObjectRef{
			Name:      glooInstance.GetMetadata().GetName(),
			Namespace: glooInstance.GetMetadata().GetNamespace(),
		},
		Spec:   &Settings.Spec,
		Status: &Settings.Status,
	}
	rpcSettings.Metadata.ClusterName = glooInstance.GetSpec().GetCluster()
	return &rpc_edge_v1.GetSettingsDetailsResponse{
		Settings: rpcSettings,
	}, nil
}

func (h *singleClusterGlooResourceHandler) ListProxies(ctx context.Context, request *rpc_edge_v1.ListProxiesRequest) (*rpc_edge_v1.ListProxiesResponse, error) {
	var rpcProxies []*rpc_edge_v1.Proxy
	if request.GetGlooInstanceRef() == nil || request.GetGlooInstanceRef().GetName() == "" || request.GetGlooInstanceRef().GetNamespace() == "" {
		// List proxies across all gloo edge instances
		instanceList, err := h.glooInstanceLister.ListGlooInstances(ctx)
		if err != nil {
			wrapped := eris.Wrapf(err, "Failed to list gloo edge instances")
			contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
			return nil, wrapped
		}
		for _, instance := range instanceList {
			rpcProxyList, err := h.listProxiesForGlooInstance(ctx, instance)
			if err != nil {
				wrapped := eris.Wrapf(err, "Failed to list proxies for gloo edge instance %v", instance)
				contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
				return nil, wrapped
			}
			rpcProxies = append(rpcProxies, rpcProxyList...)
		}
	} else {
		// List proxies for a specific gloo edge instance
		instance, err := h.glooInstanceLister.GetGlooInstance(ctx, request.GetGlooInstanceRef())
		if err != nil {
			wrapped := eris.Wrap(err, "Failed to get gloo edge instance")
			contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
			return nil, wrapped
		}
		rpcProxies, err = h.listProxiesForGlooInstance(ctx, instance)
		if err != nil {
			wrapped := eris.Wrapf(err, "Failed to list proxies for gloo edge instance %v", instance)
			contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
			return nil, wrapped
		}
	}

	// Search, Filter
	var filteredProxies []*rpc_edge_v1.Proxy
	qs := request.GetQueryString()
	sf := request.GetStatusFilter()
	if sf != nil || qs != "" {
		for _, d := range rpcProxies {
			if (sf == nil || sf.State == int32(d.Status.State)) && strings.Contains(d.Metadata.Name, qs) {
				filteredProxies = append(filteredProxies, d)
			}
		}
	} else {
		filteredProxies = rpcProxies
	}
	// Sort
	sortOptions := request.GetSortOptions()
	if sortOptions != nil {
		isDescending := sortOptions.GetDescending()
		sortKey := sortOptions.GetSortKey()
		if isDescending == true {
			switch sortKey {
			case rpc_edge_v1.SortOptions_NAME:
				sort.SliceStable(filteredProxies, func(i, j int) bool {
					a := filteredProxies[i]
					b := filteredProxies[j]
					return a.Metadata.Name+a.Metadata.Namespace+string(a.Status.State) > b.Metadata.Name+b.Metadata.Namespace+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_NAMESPACE:
				sort.SliceStable(filteredProxies, func(i, j int) bool {
					a := filteredProxies[i]
					b := filteredProxies[j]
					return a.Metadata.Namespace+a.Metadata.Name+string(a.Status.State) > b.Metadata.Namespace+b.Metadata.Name+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_STATUS:
				sort.SliceStable(filteredProxies, func(i, j int) bool {
					a := filteredProxies[i]
					b := filteredProxies[j]
					return string(a.Status.State)+a.Metadata.Name+a.Metadata.Namespace > string(b.Status.State)+b.Metadata.Name+b.Metadata.Namespace
				})
			}
		} else {
			switch sortKey {
			case rpc_edge_v1.SortOptions_NAME:
				sort.SliceStable(filteredProxies, func(i, j int) bool {
					a := filteredProxies[i]
					b := filteredProxies[j]
					return a.Metadata.Name+a.Metadata.Namespace+string(a.Status.State) < b.Metadata.Name+b.Metadata.Namespace+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_NAMESPACE:
				sort.SliceStable(filteredProxies, func(i, j int) bool {
					a := filteredProxies[i]
					b := filteredProxies[j]
					return a.Metadata.Namespace+a.Metadata.Name+string(a.Status.State) < b.Metadata.Namespace+b.Metadata.Name+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_STATUS:
				sort.SliceStable(filteredProxies, func(i, j int) bool {
					a := filteredProxies[i]
					b := filteredProxies[j]
					return string(a.Status.State)+a.Metadata.Name+a.Metadata.Namespace < string(b.Status.State)+b.Metadata.Name+b.Metadata.Namespace
				})
			}
		}
	}
	// Paginate
	paginatedProxies := filteredProxies
	pagination := request.GetPagination()
	totalCount := int32(len(filteredProxies))
	if pagination.GetLimit() > 0 && pagination.GetOffset() >= 0 {
		start := apiserverutils.Min(pagination.GetOffset(), totalCount)
		end := apiserverutils.Min(pagination.GetOffset()+pagination.GetLimit(), totalCount)
		paginatedProxies = filteredProxies[start:end]
	}
	// Build response
	res := &rpc_edge_v1.ListProxiesResponse{
		Proxies: paginatedProxies,
		Total:   totalCount,
	}
	return res, nil
}

func (h *singleClusterGlooResourceHandler) listProxiesForGlooInstance(ctx context.Context, instance *rpc_edge_v1.GlooInstance) ([]*rpc_edge_v1.Proxy, error) {
	var proxyList []*gloo_solo_io_v1.Proxy
	watchedNamespaces := instance.Spec.GetControlPlane().GetWatchedNamespaces()
	if len(watchedNamespaces) != 0 {
		for _, ns := range watchedNamespaces {
			list, err := h.glooClientset.Proxies().ListProxy(ctx, client.InNamespace(ns))
			if err != nil {
				return nil, err
			}
			for i, _ := range list.Items {
				proxyList = append(proxyList, &list.Items[i])
			}
		}
	} else {
		list, err := h.glooClientset.Proxies().ListProxy(ctx)
		if err != nil {
			return nil, err
		}
		for i, _ := range list.Items {
			proxyList = append(proxyList, &list.Items[i])
		}
	}
	sort.Slice(proxyList, func(i, j int) bool {
		x := proxyList[i]
		y := proxyList[j]
		return x.GetNamespace()+x.GetName() < y.GetNamespace()+y.GetName()
	})

	var rpcProxies []*rpc_edge_v1.Proxy
	glooInstanceRef := &skv2_v1.ObjectRef{
		Name:      instance.GetMetadata().GetName(),
		Namespace: instance.GetMetadata().GetNamespace(),
	}
	for _, proxy := range proxyList {
		rpcProxies = append(rpcProxies, &rpc_edge_v1.Proxy{
			Metadata:     apiserverutils.ToMetadata(proxy.ObjectMeta),
			GlooInstance: glooInstanceRef,
			Spec:         &proxy.Spec,
			Status:       &proxy.Status,
		})
	}
	return rpcProxies, nil
}

func (h *singleClusterGlooResourceHandler) GetProxyYaml(ctx context.Context, request *rpc_edge_v1.GetProxyYamlRequest) (*rpc_edge_v1.GetProxyYamlResponse, error) {
	proxy, err := h.glooClientset.Proxies().GetProxy(ctx, client.ObjectKey{
		Namespace: request.GetProxyRef().GetNamespace(),
		Name:      request.GetProxyRef().GetName(),
	})
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to get proxy")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	content, err := yaml.Marshal(proxy)
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to marshal kube resource into yaml")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	return &rpc_edge_v1.GetProxyYamlResponse{
		YamlData: &rpc_edge_v1.ResourceYaml{
			Yaml: string(content),
		},
	}, nil
}

func (h *singleClusterGlooResourceHandler) GetProxyDetails(ctx context.Context, request *rpc_edge_v1.GetProxyDetailsRequest) (*rpc_edge_v1.GetProxyDetailsResponse, error) {
	ProxyRef := request.GetProxyRef()
	if ProxyRef == nil {
		return nil, eris.Errorf("Proxy ref missing from request: %v", request)
	}
	Proxy, err := h.glooClientset.Proxies().GetProxy(ctx, client.ObjectKey{
		Namespace: ProxyRef.GetNamespace(),
		Name:      ProxyRef.GetName(),
	})
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to get Proxy")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	// find which gloo instance this Proxy belongs to, by finding a gloo instance that is watching
	// the Proxy's namespace
	instanceList, err := h.glooInstanceLister.ListGlooInstances(ctx)
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to list gloo edge instances")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	var glooInstance *rpc_edge_v1.GlooInstance
	for _, instance := range instanceList {
		watchedNamespaces := instance.Spec.GetControlPlane().GetWatchedNamespaces()
		if len(watchedNamespaces) == 0 {
			glooInstance = instance
			break
		}
		for _, ns := range watchedNamespaces {
			if ns == ProxyRef.GetNamespace() {
				glooInstance = instance
				break
			}
		}
		if glooInstance != nil {
			break
		}
	}
	if glooInstance == nil {
		return nil, eris.Errorf("Failed to find a gloo edge instance for namespace %s", Proxy.GetNamespace())
	}
	rpcProxy := &rpc_edge_v1.Proxy{
		Metadata: apiserverutils.ToMetadata(Proxy.ObjectMeta),
		GlooInstance: &skv2_v1.ObjectRef{
			Name:      glooInstance.GetMetadata().GetName(),
			Namespace: glooInstance.GetMetadata().GetNamespace(),
		},
		Spec:   &Proxy.Spec,
		Status: &Proxy.Status,
	}
	rpcProxy.Metadata.ClusterName = glooInstance.GetSpec().GetCluster()
	return &rpc_edge_v1.GetProxyDetailsResponse{
		Proxy: rpcProxy,
	}, nil
}
