// Code generated by skv2. DO NOT EDIT.

package single_cluster_resource_handler

import (
	"context"
	"sort"
	"strings"

	"github.com/ghodss/yaml"
	"github.com/rotisserie/eris"
	"github.com/solo-io/go-utils/contextutils"
	skv2_v1 "github.com/solo-io/skv2/pkg/api/core.skv2.solo.io/v1"
	gateway_solo_io_v1 "github.com/solo-io/solo-apis/pkg/api/gateway.solo.io/v1"
	rpc_edge_v1 "github.com/solo-io/solo-projects/projects/apiserver/pkg/api/rpc.edge.gloo/v1"
	"github.com/solo-io/solo-projects/projects/apiserver/server/apiserverutils"
	"github.com/solo-io/solo-projects/projects/apiserver/server/services/glooinstance_handler"
	"go.uber.org/zap"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

func NewSingleClusterGatewayResourceHandler(
	gatewayClientset gateway_solo_io_v1.Clientset,
	glooInstanceLister glooinstance_handler.SingleClusterGlooInstanceLister,
) rpc_edge_v1.GatewayResourceApiServer {
	return &singleClusterGatewayResourceHandler{
		gatewayClientset:   gatewayClientset,
		glooInstanceLister: glooInstanceLister,
	}
}

type singleClusterGatewayResourceHandler struct {
	gatewayClientset   gateway_solo_io_v1.Clientset
	glooInstanceLister glooinstance_handler.SingleClusterGlooInstanceLister
}

func (h *singleClusterGatewayResourceHandler) ListGateways(ctx context.Context, request *rpc_edge_v1.ListGatewaysRequest) (*rpc_edge_v1.ListGatewaysResponse, error) {
	var rpcGateways []*rpc_edge_v1.Gateway
	if request.GetGlooInstanceRef() == nil || request.GetGlooInstanceRef().GetName() == "" || request.GetGlooInstanceRef().GetNamespace() == "" {
		// List gateways across all gloo edge instances
		instanceList, err := h.glooInstanceLister.ListGlooInstances(ctx)
		if err != nil {
			wrapped := eris.Wrapf(err, "Failed to list gloo edge instances")
			contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
			return nil, wrapped
		}
		for _, instance := range instanceList {
			rpcGatewayList, err := h.listGatewaysForGlooInstance(ctx, instance)
			if err != nil {
				wrapped := eris.Wrapf(err, "Failed to list gateways for gloo edge instance %v", instance)
				contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
				return nil, wrapped
			}
			rpcGateways = append(rpcGateways, rpcGatewayList...)
		}
	} else {
		// List gateways for a specific gloo edge instance
		instance, err := h.glooInstanceLister.GetGlooInstance(ctx, request.GetGlooInstanceRef())
		if err != nil {
			wrapped := eris.Wrap(err, "Failed to get gloo edge instance")
			contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
			return nil, wrapped
		}
		rpcGateways, err = h.listGatewaysForGlooInstance(ctx, instance)
		if err != nil {
			wrapped := eris.Wrapf(err, "Failed to list gateways for gloo edge instance %v", instance)
			contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
			return nil, wrapped
		}
	}

	// Search, Filter
	var filteredGateways []*rpc_edge_v1.Gateway
	qs := request.GetQueryString()
	sf := request.GetStatusFilter()
	if sf != nil || qs != "" {
		for _, d := range rpcGateways {
			if (sf == nil || sf.State == int32(d.Status.State)) && strings.Contains(d.Metadata.Name, qs) {
				filteredGateways = append(filteredGateways, d)
			}
		}
	} else {
		filteredGateways = rpcGateways
	}
	// Sort
	sortOptions := request.GetSortOptions()
	if sortOptions != nil {
		isDescending := sortOptions.GetDescending()
		sortKey := sortOptions.GetSortKey()
		if isDescending == true {
			switch sortKey {
			case rpc_edge_v1.SortOptions_NAME:
				sort.SliceStable(filteredGateways, func(i, j int) bool {
					a := filteredGateways[i]
					b := filteredGateways[j]
					return a.Metadata.Name+a.Metadata.Namespace+string(a.Status.State) > b.Metadata.Name+b.Metadata.Namespace+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_NAMESPACE:
				sort.SliceStable(filteredGateways, func(i, j int) bool {
					a := filteredGateways[i]
					b := filteredGateways[j]
					return a.Metadata.Namespace+a.Metadata.Name+string(a.Status.State) > b.Metadata.Namespace+b.Metadata.Name+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_STATUS:
				sort.SliceStable(filteredGateways, func(i, j int) bool {
					a := filteredGateways[i]
					b := filteredGateways[j]
					return string(a.Status.State)+a.Metadata.Name+a.Metadata.Namespace > string(b.Status.State)+b.Metadata.Name+b.Metadata.Namespace
				})
			}
		} else {
			switch sortKey {
			case rpc_edge_v1.SortOptions_NAME:
				sort.SliceStable(filteredGateways, func(i, j int) bool {
					a := filteredGateways[i]
					b := filteredGateways[j]
					return a.Metadata.Name+a.Metadata.Namespace+string(a.Status.State) < b.Metadata.Name+b.Metadata.Namespace+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_NAMESPACE:
				sort.SliceStable(filteredGateways, func(i, j int) bool {
					a := filteredGateways[i]
					b := filteredGateways[j]
					return a.Metadata.Namespace+a.Metadata.Name+string(a.Status.State) < b.Metadata.Namespace+b.Metadata.Name+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_STATUS:
				sort.SliceStable(filteredGateways, func(i, j int) bool {
					a := filteredGateways[i]
					b := filteredGateways[j]
					return string(a.Status.State)+a.Metadata.Name+a.Metadata.Namespace < string(b.Status.State)+b.Metadata.Name+b.Metadata.Namespace
				})
			}
		}
	}
	// Paginate
	paginatedGateways := filteredGateways
	pagination := request.GetPagination()
	totalCount := int32(len(filteredGateways))
	if pagination.GetLimit() > 0 && pagination.GetOffset() >= 0 {
		start := apiserverutils.Min(pagination.GetOffset(), totalCount)
		end := apiserverutils.Min(pagination.GetOffset()+pagination.GetLimit(), totalCount)
		paginatedGateways = filteredGateways[start:end]
	}
	// Build response
	res := &rpc_edge_v1.ListGatewaysResponse{
		Gateways: paginatedGateways,
		Total:    totalCount,
	}
	return res, nil
}

func (h *singleClusterGatewayResourceHandler) listGatewaysForGlooInstance(ctx context.Context, instance *rpc_edge_v1.GlooInstance) ([]*rpc_edge_v1.Gateway, error) {
	var gatewayList []*gateway_solo_io_v1.Gateway
	watchedNamespaces := instance.Spec.GetControlPlane().GetWatchedNamespaces()
	if len(watchedNamespaces) != 0 {
		for _, ns := range watchedNamespaces {
			list, err := h.gatewayClientset.Gateways().ListGateway(ctx, client.InNamespace(ns))
			if err != nil {
				return nil, err
			}
			for i, _ := range list.Items {
				gatewayList = append(gatewayList, &list.Items[i])
			}
		}
	} else {
		list, err := h.gatewayClientset.Gateways().ListGateway(ctx)
		if err != nil {
			return nil, err
		}
		for i, _ := range list.Items {
			gatewayList = append(gatewayList, &list.Items[i])
		}
	}
	sort.Slice(gatewayList, func(i, j int) bool {
		x := gatewayList[i]
		y := gatewayList[j]
		return x.GetNamespace()+x.GetName() < y.GetNamespace()+y.GetName()
	})

	var rpcGateways []*rpc_edge_v1.Gateway
	glooInstanceRef := &skv2_v1.ObjectRef{
		Name:      instance.GetMetadata().GetName(),
		Namespace: instance.GetMetadata().GetNamespace(),
	}
	for _, gateway := range gatewayList {
		rpcGateways = append(rpcGateways, &rpc_edge_v1.Gateway{
			Metadata:     apiserverutils.ToMetadata(gateway.ObjectMeta),
			GlooInstance: glooInstanceRef,
			Spec:         &gateway.Spec,
			Status:       &gateway.Status,
		})
	}
	return rpcGateways, nil
}

func (h *singleClusterGatewayResourceHandler) GetGatewayYaml(ctx context.Context, request *rpc_edge_v1.GetGatewayYamlRequest) (*rpc_edge_v1.GetGatewayYamlResponse, error) {
	gateway, err := h.gatewayClientset.Gateways().GetGateway(ctx, client.ObjectKey{
		Namespace: request.GetGatewayRef().GetNamespace(),
		Name:      request.GetGatewayRef().GetName(),
	})
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to get gateway")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	content, err := yaml.Marshal(gateway)
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to marshal kube resource into yaml")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	return &rpc_edge_v1.GetGatewayYamlResponse{
		YamlData: &rpc_edge_v1.ResourceYaml{
			Yaml: string(content),
		},
	}, nil
}

func (h *singleClusterGatewayResourceHandler) GetGatewayDetails(ctx context.Context, request *rpc_edge_v1.GetGatewayDetailsRequest) (*rpc_edge_v1.GetGatewayDetailsResponse, error) {
	GatewayRef := request.GetGatewayRef()
	if GatewayRef == nil {
		return nil, eris.Errorf("Gateway ref missing from request: %v", request)
	}
	Gateway, err := h.gatewayClientset.Gateways().GetGateway(ctx, client.ObjectKey{
		Namespace: GatewayRef.GetNamespace(),
		Name:      GatewayRef.GetName(),
	})
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to get Gateway")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	// find which gloo instance this Gateway belongs to, by finding a gloo instance that is watching
	// the Gateway's namespace
	instanceList, err := h.glooInstanceLister.ListGlooInstances(ctx)
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to list gloo edge instances")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	var glooInstance *rpc_edge_v1.GlooInstance
	for _, instance := range instanceList {
		watchedNamespaces := instance.Spec.GetControlPlane().GetWatchedNamespaces()
		if len(watchedNamespaces) == 0 {
			glooInstance = instance
			break
		}
		for _, ns := range watchedNamespaces {
			if ns == GatewayRef.GetNamespace() {
				glooInstance = instance
				break
			}
		}
		if glooInstance != nil {
			break
		}
	}
	if glooInstance == nil {
		return nil, eris.Errorf("Failed to find a gloo edge instance for namespace %s", Gateway.GetNamespace())
	}
	rpcGateway := &rpc_edge_v1.Gateway{
		Metadata: apiserverutils.ToMetadata(Gateway.ObjectMeta),
		GlooInstance: &skv2_v1.ObjectRef{
			Name:      glooInstance.GetMetadata().GetName(),
			Namespace: glooInstance.GetMetadata().GetNamespace(),
		},
		Spec:   &Gateway.Spec,
		Status: &Gateway.Status,
	}
	rpcGateway.Metadata.ClusterName = glooInstance.GetSpec().GetCluster()
	return &rpc_edge_v1.GetGatewayDetailsResponse{
		Gateway: rpcGateway,
	}, nil
}

func (h *singleClusterGatewayResourceHandler) ListMatchableHttpGateways(ctx context.Context, request *rpc_edge_v1.ListMatchableHttpGatewaysRequest) (*rpc_edge_v1.ListMatchableHttpGatewaysResponse, error) {
	var rpcMatchableHttpGateways []*rpc_edge_v1.MatchableHttpGateway
	if request.GetGlooInstanceRef() == nil || request.GetGlooInstanceRef().GetName() == "" || request.GetGlooInstanceRef().GetNamespace() == "" {
		// List matchableHttpGateways across all gloo edge instances
		instanceList, err := h.glooInstanceLister.ListGlooInstances(ctx)
		if err != nil {
			wrapped := eris.Wrapf(err, "Failed to list gloo edge instances")
			contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
			return nil, wrapped
		}
		for _, instance := range instanceList {
			rpcMatchableHttpGatewayList, err := h.listMatchableHttpGatewaysForGlooInstance(ctx, instance)
			if err != nil {
				wrapped := eris.Wrapf(err, "Failed to list matchableHttpGateways for gloo edge instance %v", instance)
				contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
				return nil, wrapped
			}
			rpcMatchableHttpGateways = append(rpcMatchableHttpGateways, rpcMatchableHttpGatewayList...)
		}
	} else {
		// List matchableHttpGateways for a specific gloo edge instance
		instance, err := h.glooInstanceLister.GetGlooInstance(ctx, request.GetGlooInstanceRef())
		if err != nil {
			wrapped := eris.Wrap(err, "Failed to get gloo edge instance")
			contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
			return nil, wrapped
		}
		rpcMatchableHttpGateways, err = h.listMatchableHttpGatewaysForGlooInstance(ctx, instance)
		if err != nil {
			wrapped := eris.Wrapf(err, "Failed to list matchableHttpGateways for gloo edge instance %v", instance)
			contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
			return nil, wrapped
		}
	}

	// Search, Filter
	var filteredMatchableHttpGateways []*rpc_edge_v1.MatchableHttpGateway
	qs := request.GetQueryString()
	sf := request.GetStatusFilter()
	if sf != nil || qs != "" {
		for _, d := range rpcMatchableHttpGateways {
			if (sf == nil || sf.State == int32(d.Status.State)) && strings.Contains(d.Metadata.Name, qs) {
				filteredMatchableHttpGateways = append(filteredMatchableHttpGateways, d)
			}
		}
	} else {
		filteredMatchableHttpGateways = rpcMatchableHttpGateways
	}
	// Sort
	sortOptions := request.GetSortOptions()
	if sortOptions != nil {
		isDescending := sortOptions.GetDescending()
		sortKey := sortOptions.GetSortKey()
		if isDescending == true {
			switch sortKey {
			case rpc_edge_v1.SortOptions_NAME:
				sort.SliceStable(filteredMatchableHttpGateways, func(i, j int) bool {
					a := filteredMatchableHttpGateways[i]
					b := filteredMatchableHttpGateways[j]
					return a.Metadata.Name+a.Metadata.Namespace+string(a.Status.State) > b.Metadata.Name+b.Metadata.Namespace+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_NAMESPACE:
				sort.SliceStable(filteredMatchableHttpGateways, func(i, j int) bool {
					a := filteredMatchableHttpGateways[i]
					b := filteredMatchableHttpGateways[j]
					return a.Metadata.Namespace+a.Metadata.Name+string(a.Status.State) > b.Metadata.Namespace+b.Metadata.Name+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_STATUS:
				sort.SliceStable(filteredMatchableHttpGateways, func(i, j int) bool {
					a := filteredMatchableHttpGateways[i]
					b := filteredMatchableHttpGateways[j]
					return string(a.Status.State)+a.Metadata.Name+a.Metadata.Namespace > string(b.Status.State)+b.Metadata.Name+b.Metadata.Namespace
				})
			}
		} else {
			switch sortKey {
			case rpc_edge_v1.SortOptions_NAME:
				sort.SliceStable(filteredMatchableHttpGateways, func(i, j int) bool {
					a := filteredMatchableHttpGateways[i]
					b := filteredMatchableHttpGateways[j]
					return a.Metadata.Name+a.Metadata.Namespace+string(a.Status.State) < b.Metadata.Name+b.Metadata.Namespace+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_NAMESPACE:
				sort.SliceStable(filteredMatchableHttpGateways, func(i, j int) bool {
					a := filteredMatchableHttpGateways[i]
					b := filteredMatchableHttpGateways[j]
					return a.Metadata.Namespace+a.Metadata.Name+string(a.Status.State) < b.Metadata.Namespace+b.Metadata.Name+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_STATUS:
				sort.SliceStable(filteredMatchableHttpGateways, func(i, j int) bool {
					a := filteredMatchableHttpGateways[i]
					b := filteredMatchableHttpGateways[j]
					return string(a.Status.State)+a.Metadata.Name+a.Metadata.Namespace < string(b.Status.State)+b.Metadata.Name+b.Metadata.Namespace
				})
			}
		}
	}
	// Paginate
	paginatedMatchableHttpGateways := filteredMatchableHttpGateways
	pagination := request.GetPagination()
	totalCount := int32(len(filteredMatchableHttpGateways))
	if pagination.GetLimit() > 0 && pagination.GetOffset() >= 0 {
		start := apiserverutils.Min(pagination.GetOffset(), totalCount)
		end := apiserverutils.Min(pagination.GetOffset()+pagination.GetLimit(), totalCount)
		paginatedMatchableHttpGateways = filteredMatchableHttpGateways[start:end]
	}
	// Build response
	res := &rpc_edge_v1.ListMatchableHttpGatewaysResponse{
		MatchableHttpGateways: paginatedMatchableHttpGateways,
		Total:                 totalCount,
	}
	return res, nil
}

func (h *singleClusterGatewayResourceHandler) listMatchableHttpGatewaysForGlooInstance(ctx context.Context, instance *rpc_edge_v1.GlooInstance) ([]*rpc_edge_v1.MatchableHttpGateway, error) {
	var matchableHttpGatewayList []*gateway_solo_io_v1.MatchableHttpGateway
	watchedNamespaces := instance.Spec.GetControlPlane().GetWatchedNamespaces()
	if len(watchedNamespaces) != 0 {
		for _, ns := range watchedNamespaces {
			list, err := h.gatewayClientset.MatchableHttpGateways().ListMatchableHttpGateway(ctx, client.InNamespace(ns))
			if err != nil {
				return nil, err
			}
			for i, _ := range list.Items {
				matchableHttpGatewayList = append(matchableHttpGatewayList, &list.Items[i])
			}
		}
	} else {
		list, err := h.gatewayClientset.MatchableHttpGateways().ListMatchableHttpGateway(ctx)
		if err != nil {
			return nil, err
		}
		for i, _ := range list.Items {
			matchableHttpGatewayList = append(matchableHttpGatewayList, &list.Items[i])
		}
	}
	sort.Slice(matchableHttpGatewayList, func(i, j int) bool {
		x := matchableHttpGatewayList[i]
		y := matchableHttpGatewayList[j]
		return x.GetNamespace()+x.GetName() < y.GetNamespace()+y.GetName()
	})

	var rpcMatchableHttpGateways []*rpc_edge_v1.MatchableHttpGateway
	glooInstanceRef := &skv2_v1.ObjectRef{
		Name:      instance.GetMetadata().GetName(),
		Namespace: instance.GetMetadata().GetNamespace(),
	}
	for _, matchableHttpGateway := range matchableHttpGatewayList {
		rpcMatchableHttpGateways = append(rpcMatchableHttpGateways, &rpc_edge_v1.MatchableHttpGateway{
			Metadata:     apiserverutils.ToMetadata(matchableHttpGateway.ObjectMeta),
			GlooInstance: glooInstanceRef,
			Spec:         &matchableHttpGateway.Spec,
			Status:       &matchableHttpGateway.Status,
		})
	}
	return rpcMatchableHttpGateways, nil
}

func (h *singleClusterGatewayResourceHandler) GetMatchableHttpGatewayYaml(ctx context.Context, request *rpc_edge_v1.GetMatchableHttpGatewayYamlRequest) (*rpc_edge_v1.GetMatchableHttpGatewayYamlResponse, error) {
	matchableHttpGateway, err := h.gatewayClientset.MatchableHttpGateways().GetMatchableHttpGateway(ctx, client.ObjectKey{
		Namespace: request.GetMatchableHttpGatewayRef().GetNamespace(),
		Name:      request.GetMatchableHttpGatewayRef().GetName(),
	})
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to get matchableHttpGateway")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	content, err := yaml.Marshal(matchableHttpGateway)
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to marshal kube resource into yaml")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	return &rpc_edge_v1.GetMatchableHttpGatewayYamlResponse{
		YamlData: &rpc_edge_v1.ResourceYaml{
			Yaml: string(content),
		},
	}, nil
}

func (h *singleClusterGatewayResourceHandler) GetMatchableHttpGatewayDetails(ctx context.Context, request *rpc_edge_v1.GetMatchableHttpGatewayDetailsRequest) (*rpc_edge_v1.GetMatchableHttpGatewayDetailsResponse, error) {
	MatchableHttpGatewayRef := request.GetMatchableHttpGatewayRef()
	if MatchableHttpGatewayRef == nil {
		return nil, eris.Errorf("MatchableHttpGateway ref missing from request: %v", request)
	}
	MatchableHttpGateway, err := h.gatewayClientset.MatchableHttpGateways().GetMatchableHttpGateway(ctx, client.ObjectKey{
		Namespace: MatchableHttpGatewayRef.GetNamespace(),
		Name:      MatchableHttpGatewayRef.GetName(),
	})
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to get MatchableHttpGateway")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	// find which gloo instance this MatchableHttpGateway belongs to, by finding a gloo instance that is watching
	// the MatchableHttpGateway's namespace
	instanceList, err := h.glooInstanceLister.ListGlooInstances(ctx)
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to list gloo edge instances")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	var glooInstance *rpc_edge_v1.GlooInstance
	for _, instance := range instanceList {
		watchedNamespaces := instance.Spec.GetControlPlane().GetWatchedNamespaces()
		if len(watchedNamespaces) == 0 {
			glooInstance = instance
			break
		}
		for _, ns := range watchedNamespaces {
			if ns == MatchableHttpGatewayRef.GetNamespace() {
				glooInstance = instance
				break
			}
		}
		if glooInstance != nil {
			break
		}
	}
	if glooInstance == nil {
		return nil, eris.Errorf("Failed to find a gloo edge instance for namespace %s", MatchableHttpGateway.GetNamespace())
	}
	rpcMatchableHttpGateway := &rpc_edge_v1.MatchableHttpGateway{
		Metadata: apiserverutils.ToMetadata(MatchableHttpGateway.ObjectMeta),
		GlooInstance: &skv2_v1.ObjectRef{
			Name:      glooInstance.GetMetadata().GetName(),
			Namespace: glooInstance.GetMetadata().GetNamespace(),
		},
		Spec:   &MatchableHttpGateway.Spec,
		Status: &MatchableHttpGateway.Status,
	}
	rpcMatchableHttpGateway.Metadata.ClusterName = glooInstance.GetSpec().GetCluster()
	return &rpc_edge_v1.GetMatchableHttpGatewayDetailsResponse{
		MatchableHttpGateway: rpcMatchableHttpGateway,
	}, nil
}

func (h *singleClusterGatewayResourceHandler) ListMatchableTcpGateways(ctx context.Context, request *rpc_edge_v1.ListMatchableTcpGatewaysRequest) (*rpc_edge_v1.ListMatchableTcpGatewaysResponse, error) {
	var rpcMatchableTcpGateways []*rpc_edge_v1.MatchableTcpGateway
	if request.GetGlooInstanceRef() == nil || request.GetGlooInstanceRef().GetName() == "" || request.GetGlooInstanceRef().GetNamespace() == "" {
		// List matchableTcpGateways across all gloo edge instances
		instanceList, err := h.glooInstanceLister.ListGlooInstances(ctx)
		if err != nil {
			wrapped := eris.Wrapf(err, "Failed to list gloo edge instances")
			contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
			return nil, wrapped
		}
		for _, instance := range instanceList {
			rpcMatchableTcpGatewayList, err := h.listMatchableTcpGatewaysForGlooInstance(ctx, instance)
			if err != nil {
				wrapped := eris.Wrapf(err, "Failed to list matchableTcpGateways for gloo edge instance %v", instance)
				contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
				return nil, wrapped
			}
			rpcMatchableTcpGateways = append(rpcMatchableTcpGateways, rpcMatchableTcpGatewayList...)
		}
	} else {
		// List matchableTcpGateways for a specific gloo edge instance
		instance, err := h.glooInstanceLister.GetGlooInstance(ctx, request.GetGlooInstanceRef())
		if err != nil {
			wrapped := eris.Wrap(err, "Failed to get gloo edge instance")
			contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
			return nil, wrapped
		}
		rpcMatchableTcpGateways, err = h.listMatchableTcpGatewaysForGlooInstance(ctx, instance)
		if err != nil {
			wrapped := eris.Wrapf(err, "Failed to list matchableTcpGateways for gloo edge instance %v", instance)
			contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
			return nil, wrapped
		}
	}

	// Search, Filter
	var filteredMatchableTcpGateways []*rpc_edge_v1.MatchableTcpGateway
	qs := request.GetQueryString()
	sf := request.GetStatusFilter()
	if sf != nil || qs != "" {
		for _, d := range rpcMatchableTcpGateways {
			if (sf == nil || sf.State == int32(d.Status.State)) && strings.Contains(d.Metadata.Name, qs) {
				filteredMatchableTcpGateways = append(filteredMatchableTcpGateways, d)
			}
		}
	} else {
		filteredMatchableTcpGateways = rpcMatchableTcpGateways
	}
	// Sort
	sortOptions := request.GetSortOptions()
	if sortOptions != nil {
		isDescending := sortOptions.GetDescending()
		sortKey := sortOptions.GetSortKey()
		if isDescending == true {
			switch sortKey {
			case rpc_edge_v1.SortOptions_NAME:
				sort.SliceStable(filteredMatchableTcpGateways, func(i, j int) bool {
					a := filteredMatchableTcpGateways[i]
					b := filteredMatchableTcpGateways[j]
					return a.Metadata.Name+a.Metadata.Namespace+string(a.Status.State) > b.Metadata.Name+b.Metadata.Namespace+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_NAMESPACE:
				sort.SliceStable(filteredMatchableTcpGateways, func(i, j int) bool {
					a := filteredMatchableTcpGateways[i]
					b := filteredMatchableTcpGateways[j]
					return a.Metadata.Namespace+a.Metadata.Name+string(a.Status.State) > b.Metadata.Namespace+b.Metadata.Name+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_STATUS:
				sort.SliceStable(filteredMatchableTcpGateways, func(i, j int) bool {
					a := filteredMatchableTcpGateways[i]
					b := filteredMatchableTcpGateways[j]
					return string(a.Status.State)+a.Metadata.Name+a.Metadata.Namespace > string(b.Status.State)+b.Metadata.Name+b.Metadata.Namespace
				})
			}
		} else {
			switch sortKey {
			case rpc_edge_v1.SortOptions_NAME:
				sort.SliceStable(filteredMatchableTcpGateways, func(i, j int) bool {
					a := filteredMatchableTcpGateways[i]
					b := filteredMatchableTcpGateways[j]
					return a.Metadata.Name+a.Metadata.Namespace+string(a.Status.State) < b.Metadata.Name+b.Metadata.Namespace+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_NAMESPACE:
				sort.SliceStable(filteredMatchableTcpGateways, func(i, j int) bool {
					a := filteredMatchableTcpGateways[i]
					b := filteredMatchableTcpGateways[j]
					return a.Metadata.Namespace+a.Metadata.Name+string(a.Status.State) < b.Metadata.Namespace+b.Metadata.Name+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_STATUS:
				sort.SliceStable(filteredMatchableTcpGateways, func(i, j int) bool {
					a := filteredMatchableTcpGateways[i]
					b := filteredMatchableTcpGateways[j]
					return string(a.Status.State)+a.Metadata.Name+a.Metadata.Namespace < string(b.Status.State)+b.Metadata.Name+b.Metadata.Namespace
				})
			}
		}
	}
	// Paginate
	paginatedMatchableTcpGateways := filteredMatchableTcpGateways
	pagination := request.GetPagination()
	totalCount := int32(len(filteredMatchableTcpGateways))
	if pagination.GetLimit() > 0 && pagination.GetOffset() >= 0 {
		start := apiserverutils.Min(pagination.GetOffset(), totalCount)
		end := apiserverutils.Min(pagination.GetOffset()+pagination.GetLimit(), totalCount)
		paginatedMatchableTcpGateways = filteredMatchableTcpGateways[start:end]
	}
	// Build response
	res := &rpc_edge_v1.ListMatchableTcpGatewaysResponse{
		MatchableTcpGateways: paginatedMatchableTcpGateways,
		Total:                totalCount,
	}
	return res, nil
}

func (h *singleClusterGatewayResourceHandler) listMatchableTcpGatewaysForGlooInstance(ctx context.Context, instance *rpc_edge_v1.GlooInstance) ([]*rpc_edge_v1.MatchableTcpGateway, error) {
	var matchableTcpGatewayList []*gateway_solo_io_v1.MatchableTcpGateway
	watchedNamespaces := instance.Spec.GetControlPlane().GetWatchedNamespaces()
	if len(watchedNamespaces) != 0 {
		for _, ns := range watchedNamespaces {
			list, err := h.gatewayClientset.MatchableTcpGateways().ListMatchableTcpGateway(ctx, client.InNamespace(ns))
			if err != nil {
				return nil, err
			}
			for i, _ := range list.Items {
				matchableTcpGatewayList = append(matchableTcpGatewayList, &list.Items[i])
			}
		}
	} else {
		list, err := h.gatewayClientset.MatchableTcpGateways().ListMatchableTcpGateway(ctx)
		if err != nil {
			return nil, err
		}
		for i, _ := range list.Items {
			matchableTcpGatewayList = append(matchableTcpGatewayList, &list.Items[i])
		}
	}
	sort.Slice(matchableTcpGatewayList, func(i, j int) bool {
		x := matchableTcpGatewayList[i]
		y := matchableTcpGatewayList[j]
		return x.GetNamespace()+x.GetName() < y.GetNamespace()+y.GetName()
	})

	var rpcMatchableTcpGateways []*rpc_edge_v1.MatchableTcpGateway
	glooInstanceRef := &skv2_v1.ObjectRef{
		Name:      instance.GetMetadata().GetName(),
		Namespace: instance.GetMetadata().GetNamespace(),
	}
	for _, matchableTcpGateway := range matchableTcpGatewayList {
		rpcMatchableTcpGateways = append(rpcMatchableTcpGateways, &rpc_edge_v1.MatchableTcpGateway{
			Metadata:     apiserverutils.ToMetadata(matchableTcpGateway.ObjectMeta),
			GlooInstance: glooInstanceRef,
			Spec:         &matchableTcpGateway.Spec,
			Status:       &matchableTcpGateway.Status,
		})
	}
	return rpcMatchableTcpGateways, nil
}

func (h *singleClusterGatewayResourceHandler) GetMatchableTcpGatewayYaml(ctx context.Context, request *rpc_edge_v1.GetMatchableTcpGatewayYamlRequest) (*rpc_edge_v1.GetMatchableTcpGatewayYamlResponse, error) {
	matchableTcpGateway, err := h.gatewayClientset.MatchableTcpGateways().GetMatchableTcpGateway(ctx, client.ObjectKey{
		Namespace: request.GetMatchableTcpGatewayRef().GetNamespace(),
		Name:      request.GetMatchableTcpGatewayRef().GetName(),
	})
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to get matchableTcpGateway")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	content, err := yaml.Marshal(matchableTcpGateway)
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to marshal kube resource into yaml")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	return &rpc_edge_v1.GetMatchableTcpGatewayYamlResponse{
		YamlData: &rpc_edge_v1.ResourceYaml{
			Yaml: string(content),
		},
	}, nil
}

func (h *singleClusterGatewayResourceHandler) GetMatchableTcpGatewayDetails(ctx context.Context, request *rpc_edge_v1.GetMatchableTcpGatewayDetailsRequest) (*rpc_edge_v1.GetMatchableTcpGatewayDetailsResponse, error) {
	MatchableTcpGatewayRef := request.GetMatchableTcpGatewayRef()
	if MatchableTcpGatewayRef == nil {
		return nil, eris.Errorf("MatchableTcpGateway ref missing from request: %v", request)
	}
	MatchableTcpGateway, err := h.gatewayClientset.MatchableTcpGateways().GetMatchableTcpGateway(ctx, client.ObjectKey{
		Namespace: MatchableTcpGatewayRef.GetNamespace(),
		Name:      MatchableTcpGatewayRef.GetName(),
	})
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to get MatchableTcpGateway")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	// find which gloo instance this MatchableTcpGateway belongs to, by finding a gloo instance that is watching
	// the MatchableTcpGateway's namespace
	instanceList, err := h.glooInstanceLister.ListGlooInstances(ctx)
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to list gloo edge instances")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	var glooInstance *rpc_edge_v1.GlooInstance
	for _, instance := range instanceList {
		watchedNamespaces := instance.Spec.GetControlPlane().GetWatchedNamespaces()
		if len(watchedNamespaces) == 0 {
			glooInstance = instance
			break
		}
		for _, ns := range watchedNamespaces {
			if ns == MatchableTcpGatewayRef.GetNamespace() {
				glooInstance = instance
				break
			}
		}
		if glooInstance != nil {
			break
		}
	}
	if glooInstance == nil {
		return nil, eris.Errorf("Failed to find a gloo edge instance for namespace %s", MatchableTcpGateway.GetNamespace())
	}
	rpcMatchableTcpGateway := &rpc_edge_v1.MatchableTcpGateway{
		Metadata: apiserverutils.ToMetadata(MatchableTcpGateway.ObjectMeta),
		GlooInstance: &skv2_v1.ObjectRef{
			Name:      glooInstance.GetMetadata().GetName(),
			Namespace: glooInstance.GetMetadata().GetNamespace(),
		},
		Spec:   &MatchableTcpGateway.Spec,
		Status: &MatchableTcpGateway.Status,
	}
	rpcMatchableTcpGateway.Metadata.ClusterName = glooInstance.GetSpec().GetCluster()
	return &rpc_edge_v1.GetMatchableTcpGatewayDetailsResponse{
		MatchableTcpGateway: rpcMatchableTcpGateway,
	}, nil
}

func (h *singleClusterGatewayResourceHandler) ListVirtualServices(ctx context.Context, request *rpc_edge_v1.ListVirtualServicesRequest) (*rpc_edge_v1.ListVirtualServicesResponse, error) {
	var rpcVirtualServices []*rpc_edge_v1.VirtualService
	if request.GetGlooInstanceRef() == nil || request.GetGlooInstanceRef().GetName() == "" || request.GetGlooInstanceRef().GetNamespace() == "" {
		// List virtualServices across all gloo edge instances
		instanceList, err := h.glooInstanceLister.ListGlooInstances(ctx)
		if err != nil {
			wrapped := eris.Wrapf(err, "Failed to list gloo edge instances")
			contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
			return nil, wrapped
		}
		for _, instance := range instanceList {
			rpcVirtualServiceList, err := h.listVirtualServicesForGlooInstance(ctx, instance)
			if err != nil {
				wrapped := eris.Wrapf(err, "Failed to list virtualServices for gloo edge instance %v", instance)
				contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
				return nil, wrapped
			}
			rpcVirtualServices = append(rpcVirtualServices, rpcVirtualServiceList...)
		}
	} else {
		// List virtualServices for a specific gloo edge instance
		instance, err := h.glooInstanceLister.GetGlooInstance(ctx, request.GetGlooInstanceRef())
		if err != nil {
			wrapped := eris.Wrap(err, "Failed to get gloo edge instance")
			contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
			return nil, wrapped
		}
		rpcVirtualServices, err = h.listVirtualServicesForGlooInstance(ctx, instance)
		if err != nil {
			wrapped := eris.Wrapf(err, "Failed to list virtualServices for gloo edge instance %v", instance)
			contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
			return nil, wrapped
		}
	}

	// Search, Filter
	var filteredVirtualServices []*rpc_edge_v1.VirtualService
	qs := request.GetQueryString()
	sf := request.GetStatusFilter()
	if sf != nil || qs != "" {
		for _, d := range rpcVirtualServices {
			if (sf == nil || sf.State == int32(d.Status.State)) && strings.Contains(d.Metadata.Name, qs) {
				filteredVirtualServices = append(filteredVirtualServices, d)
			}
		}
	} else {
		filteredVirtualServices = rpcVirtualServices
	}
	// Sort
	sortOptions := request.GetSortOptions()
	if sortOptions != nil {
		isDescending := sortOptions.GetDescending()
		sortKey := sortOptions.GetSortKey()
		if isDescending == true {
			switch sortKey {
			case rpc_edge_v1.SortOptions_NAME:
				sort.SliceStable(filteredVirtualServices, func(i, j int) bool {
					a := filteredVirtualServices[i]
					b := filteredVirtualServices[j]
					return a.Metadata.Name+a.Metadata.Namespace+string(a.Status.State) > b.Metadata.Name+b.Metadata.Namespace+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_NAMESPACE:
				sort.SliceStable(filteredVirtualServices, func(i, j int) bool {
					a := filteredVirtualServices[i]
					b := filteredVirtualServices[j]
					return a.Metadata.Namespace+a.Metadata.Name+string(a.Status.State) > b.Metadata.Namespace+b.Metadata.Name+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_STATUS:
				sort.SliceStable(filteredVirtualServices, func(i, j int) bool {
					a := filteredVirtualServices[i]
					b := filteredVirtualServices[j]
					return string(a.Status.State)+a.Metadata.Name+a.Metadata.Namespace > string(b.Status.State)+b.Metadata.Name+b.Metadata.Namespace
				})
			}
		} else {
			switch sortKey {
			case rpc_edge_v1.SortOptions_NAME:
				sort.SliceStable(filteredVirtualServices, func(i, j int) bool {
					a := filteredVirtualServices[i]
					b := filteredVirtualServices[j]
					return a.Metadata.Name+a.Metadata.Namespace+string(a.Status.State) < b.Metadata.Name+b.Metadata.Namespace+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_NAMESPACE:
				sort.SliceStable(filteredVirtualServices, func(i, j int) bool {
					a := filteredVirtualServices[i]
					b := filteredVirtualServices[j]
					return a.Metadata.Namespace+a.Metadata.Name+string(a.Status.State) < b.Metadata.Namespace+b.Metadata.Name+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_STATUS:
				sort.SliceStable(filteredVirtualServices, func(i, j int) bool {
					a := filteredVirtualServices[i]
					b := filteredVirtualServices[j]
					return string(a.Status.State)+a.Metadata.Name+a.Metadata.Namespace < string(b.Status.State)+b.Metadata.Name+b.Metadata.Namespace
				})
			}
		}
	}
	// Paginate
	paginatedVirtualServices := filteredVirtualServices
	pagination := request.GetPagination()
	totalCount := int32(len(filteredVirtualServices))
	if pagination.GetLimit() > 0 && pagination.GetOffset() >= 0 {
		start := apiserverutils.Min(pagination.GetOffset(), totalCount)
		end := apiserverutils.Min(pagination.GetOffset()+pagination.GetLimit(), totalCount)
		paginatedVirtualServices = filteredVirtualServices[start:end]
	}
	// Build response
	res := &rpc_edge_v1.ListVirtualServicesResponse{
		VirtualServices: paginatedVirtualServices,
		Total:           totalCount,
	}
	return res, nil
}

func (h *singleClusterGatewayResourceHandler) listVirtualServicesForGlooInstance(ctx context.Context, instance *rpc_edge_v1.GlooInstance) ([]*rpc_edge_v1.VirtualService, error) {
	var virtualServiceList []*gateway_solo_io_v1.VirtualService
	watchedNamespaces := instance.Spec.GetControlPlane().GetWatchedNamespaces()
	if len(watchedNamespaces) != 0 {
		for _, ns := range watchedNamespaces {
			list, err := h.gatewayClientset.VirtualServices().ListVirtualService(ctx, client.InNamespace(ns))
			if err != nil {
				return nil, err
			}
			for i, _ := range list.Items {
				virtualServiceList = append(virtualServiceList, &list.Items[i])
			}
		}
	} else {
		list, err := h.gatewayClientset.VirtualServices().ListVirtualService(ctx)
		if err != nil {
			return nil, err
		}
		for i, _ := range list.Items {
			virtualServiceList = append(virtualServiceList, &list.Items[i])
		}
	}
	sort.Slice(virtualServiceList, func(i, j int) bool {
		x := virtualServiceList[i]
		y := virtualServiceList[j]
		return x.GetNamespace()+x.GetName() < y.GetNamespace()+y.GetName()
	})

	var rpcVirtualServices []*rpc_edge_v1.VirtualService
	glooInstanceRef := &skv2_v1.ObjectRef{
		Name:      instance.GetMetadata().GetName(),
		Namespace: instance.GetMetadata().GetNamespace(),
	}
	for _, virtualService := range virtualServiceList {
		rpcVirtualServices = append(rpcVirtualServices, &rpc_edge_v1.VirtualService{
			Metadata:     apiserverutils.ToMetadata(virtualService.ObjectMeta),
			GlooInstance: glooInstanceRef,
			Spec:         &virtualService.Spec,
			Status:       &virtualService.Status,
		})
	}
	return rpcVirtualServices, nil
}

func (h *singleClusterGatewayResourceHandler) GetVirtualServiceYaml(ctx context.Context, request *rpc_edge_v1.GetVirtualServiceYamlRequest) (*rpc_edge_v1.GetVirtualServiceYamlResponse, error) {
	virtualService, err := h.gatewayClientset.VirtualServices().GetVirtualService(ctx, client.ObjectKey{
		Namespace: request.GetVirtualServiceRef().GetNamespace(),
		Name:      request.GetVirtualServiceRef().GetName(),
	})
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to get virtualService")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	content, err := yaml.Marshal(virtualService)
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to marshal kube resource into yaml")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	return &rpc_edge_v1.GetVirtualServiceYamlResponse{
		YamlData: &rpc_edge_v1.ResourceYaml{
			Yaml: string(content),
		},
	}, nil
}

func (h *singleClusterGatewayResourceHandler) GetVirtualServiceDetails(ctx context.Context, request *rpc_edge_v1.GetVirtualServiceDetailsRequest) (*rpc_edge_v1.GetVirtualServiceDetailsResponse, error) {
	VirtualServiceRef := request.GetVirtualServiceRef()
	if VirtualServiceRef == nil {
		return nil, eris.Errorf("VirtualService ref missing from request: %v", request)
	}
	VirtualService, err := h.gatewayClientset.VirtualServices().GetVirtualService(ctx, client.ObjectKey{
		Namespace: VirtualServiceRef.GetNamespace(),
		Name:      VirtualServiceRef.GetName(),
	})
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to get VirtualService")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	// find which gloo instance this VirtualService belongs to, by finding a gloo instance that is watching
	// the VirtualService's namespace
	instanceList, err := h.glooInstanceLister.ListGlooInstances(ctx)
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to list gloo edge instances")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	var glooInstance *rpc_edge_v1.GlooInstance
	for _, instance := range instanceList {
		watchedNamespaces := instance.Spec.GetControlPlane().GetWatchedNamespaces()
		if len(watchedNamespaces) == 0 {
			glooInstance = instance
			break
		}
		for _, ns := range watchedNamespaces {
			if ns == VirtualServiceRef.GetNamespace() {
				glooInstance = instance
				break
			}
		}
		if glooInstance != nil {
			break
		}
	}
	if glooInstance == nil {
		return nil, eris.Errorf("Failed to find a gloo edge instance for namespace %s", VirtualService.GetNamespace())
	}
	rpcVirtualService := &rpc_edge_v1.VirtualService{
		Metadata: apiserverutils.ToMetadata(VirtualService.ObjectMeta),
		GlooInstance: &skv2_v1.ObjectRef{
			Name:      glooInstance.GetMetadata().GetName(),
			Namespace: glooInstance.GetMetadata().GetNamespace(),
		},
		Spec:   &VirtualService.Spec,
		Status: &VirtualService.Status,
	}
	rpcVirtualService.Metadata.ClusterName = glooInstance.GetSpec().GetCluster()
	return &rpc_edge_v1.GetVirtualServiceDetailsResponse{
		VirtualService: rpcVirtualService,
	}, nil
}

func (h *singleClusterGatewayResourceHandler) ListRouteTables(ctx context.Context, request *rpc_edge_v1.ListRouteTablesRequest) (*rpc_edge_v1.ListRouteTablesResponse, error) {
	var rpcRouteTables []*rpc_edge_v1.RouteTable
	if request.GetGlooInstanceRef() == nil || request.GetGlooInstanceRef().GetName() == "" || request.GetGlooInstanceRef().GetNamespace() == "" {
		// List routeTables across all gloo edge instances
		instanceList, err := h.glooInstanceLister.ListGlooInstances(ctx)
		if err != nil {
			wrapped := eris.Wrapf(err, "Failed to list gloo edge instances")
			contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
			return nil, wrapped
		}
		for _, instance := range instanceList {
			rpcRouteTableList, err := h.listRouteTablesForGlooInstance(ctx, instance)
			if err != nil {
				wrapped := eris.Wrapf(err, "Failed to list routeTables for gloo edge instance %v", instance)
				contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
				return nil, wrapped
			}
			rpcRouteTables = append(rpcRouteTables, rpcRouteTableList...)
		}
	} else {
		// List routeTables for a specific gloo edge instance
		instance, err := h.glooInstanceLister.GetGlooInstance(ctx, request.GetGlooInstanceRef())
		if err != nil {
			wrapped := eris.Wrap(err, "Failed to get gloo edge instance")
			contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
			return nil, wrapped
		}
		rpcRouteTables, err = h.listRouteTablesForGlooInstance(ctx, instance)
		if err != nil {
			wrapped := eris.Wrapf(err, "Failed to list routeTables for gloo edge instance %v", instance)
			contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
			return nil, wrapped
		}
	}

	// Search, Filter
	var filteredRouteTables []*rpc_edge_v1.RouteTable
	qs := request.GetQueryString()
	sf := request.GetStatusFilter()
	if sf != nil || qs != "" {
		for _, d := range rpcRouteTables {
			if (sf == nil || sf.State == int32(d.Status.State)) && strings.Contains(d.Metadata.Name, qs) {
				filteredRouteTables = append(filteredRouteTables, d)
			}
		}
	} else {
		filteredRouteTables = rpcRouteTables
	}
	// Sort
	sortOptions := request.GetSortOptions()
	if sortOptions != nil {
		isDescending := sortOptions.GetDescending()
		sortKey := sortOptions.GetSortKey()
		if isDescending == true {
			switch sortKey {
			case rpc_edge_v1.SortOptions_NAME:
				sort.SliceStable(filteredRouteTables, func(i, j int) bool {
					a := filteredRouteTables[i]
					b := filteredRouteTables[j]
					return a.Metadata.Name+a.Metadata.Namespace+string(a.Status.State) > b.Metadata.Name+b.Metadata.Namespace+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_NAMESPACE:
				sort.SliceStable(filteredRouteTables, func(i, j int) bool {
					a := filteredRouteTables[i]
					b := filteredRouteTables[j]
					return a.Metadata.Namespace+a.Metadata.Name+string(a.Status.State) > b.Metadata.Namespace+b.Metadata.Name+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_STATUS:
				sort.SliceStable(filteredRouteTables, func(i, j int) bool {
					a := filteredRouteTables[i]
					b := filteredRouteTables[j]
					return string(a.Status.State)+a.Metadata.Name+a.Metadata.Namespace > string(b.Status.State)+b.Metadata.Name+b.Metadata.Namespace
				})
			}
		} else {
			switch sortKey {
			case rpc_edge_v1.SortOptions_NAME:
				sort.SliceStable(filteredRouteTables, func(i, j int) bool {
					a := filteredRouteTables[i]
					b := filteredRouteTables[j]
					return a.Metadata.Name+a.Metadata.Namespace+string(a.Status.State) < b.Metadata.Name+b.Metadata.Namespace+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_NAMESPACE:
				sort.SliceStable(filteredRouteTables, func(i, j int) bool {
					a := filteredRouteTables[i]
					b := filteredRouteTables[j]
					return a.Metadata.Namespace+a.Metadata.Name+string(a.Status.State) < b.Metadata.Namespace+b.Metadata.Name+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_STATUS:
				sort.SliceStable(filteredRouteTables, func(i, j int) bool {
					a := filteredRouteTables[i]
					b := filteredRouteTables[j]
					return string(a.Status.State)+a.Metadata.Name+a.Metadata.Namespace < string(b.Status.State)+b.Metadata.Name+b.Metadata.Namespace
				})
			}
		}
	}
	// Paginate
	paginatedRouteTables := filteredRouteTables
	pagination := request.GetPagination()
	totalCount := int32(len(filteredRouteTables))
	if pagination.GetLimit() > 0 && pagination.GetOffset() >= 0 {
		start := apiserverutils.Min(pagination.GetOffset(), totalCount)
		end := apiserverutils.Min(pagination.GetOffset()+pagination.GetLimit(), totalCount)
		paginatedRouteTables = filteredRouteTables[start:end]
	}
	// Build response
	res := &rpc_edge_v1.ListRouteTablesResponse{
		RouteTables: paginatedRouteTables,
		Total:       totalCount,
	}
	return res, nil
}

func (h *singleClusterGatewayResourceHandler) listRouteTablesForGlooInstance(ctx context.Context, instance *rpc_edge_v1.GlooInstance) ([]*rpc_edge_v1.RouteTable, error) {
	var routeTableList []*gateway_solo_io_v1.RouteTable
	watchedNamespaces := instance.Spec.GetControlPlane().GetWatchedNamespaces()
	if len(watchedNamespaces) != 0 {
		for _, ns := range watchedNamespaces {
			list, err := h.gatewayClientset.RouteTables().ListRouteTable(ctx, client.InNamespace(ns))
			if err != nil {
				return nil, err
			}
			for i, _ := range list.Items {
				routeTableList = append(routeTableList, &list.Items[i])
			}
		}
	} else {
		list, err := h.gatewayClientset.RouteTables().ListRouteTable(ctx)
		if err != nil {
			return nil, err
		}
		for i, _ := range list.Items {
			routeTableList = append(routeTableList, &list.Items[i])
		}
	}
	sort.Slice(routeTableList, func(i, j int) bool {
		x := routeTableList[i]
		y := routeTableList[j]
		return x.GetNamespace()+x.GetName() < y.GetNamespace()+y.GetName()
	})

	var rpcRouteTables []*rpc_edge_v1.RouteTable
	glooInstanceRef := &skv2_v1.ObjectRef{
		Name:      instance.GetMetadata().GetName(),
		Namespace: instance.GetMetadata().GetNamespace(),
	}
	for _, routeTable := range routeTableList {
		rpcRouteTables = append(rpcRouteTables, &rpc_edge_v1.RouteTable{
			Metadata:     apiserverutils.ToMetadata(routeTable.ObjectMeta),
			GlooInstance: glooInstanceRef,
			Spec:         &routeTable.Spec,
			Status:       &routeTable.Status,
		})
	}
	return rpcRouteTables, nil
}

func (h *singleClusterGatewayResourceHandler) GetRouteTableYaml(ctx context.Context, request *rpc_edge_v1.GetRouteTableYamlRequest) (*rpc_edge_v1.GetRouteTableYamlResponse, error) {
	routeTable, err := h.gatewayClientset.RouteTables().GetRouteTable(ctx, client.ObjectKey{
		Namespace: request.GetRouteTableRef().GetNamespace(),
		Name:      request.GetRouteTableRef().GetName(),
	})
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to get routeTable")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	content, err := yaml.Marshal(routeTable)
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to marshal kube resource into yaml")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	return &rpc_edge_v1.GetRouteTableYamlResponse{
		YamlData: &rpc_edge_v1.ResourceYaml{
			Yaml: string(content),
		},
	}, nil
}

func (h *singleClusterGatewayResourceHandler) GetRouteTableDetails(ctx context.Context, request *rpc_edge_v1.GetRouteTableDetailsRequest) (*rpc_edge_v1.GetRouteTableDetailsResponse, error) {
	RouteTableRef := request.GetRouteTableRef()
	if RouteTableRef == nil {
		return nil, eris.Errorf("RouteTable ref missing from request: %v", request)
	}
	RouteTable, err := h.gatewayClientset.RouteTables().GetRouteTable(ctx, client.ObjectKey{
		Namespace: RouteTableRef.GetNamespace(),
		Name:      RouteTableRef.GetName(),
	})
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to get RouteTable")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	// find which gloo instance this RouteTable belongs to, by finding a gloo instance that is watching
	// the RouteTable's namespace
	instanceList, err := h.glooInstanceLister.ListGlooInstances(ctx)
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to list gloo edge instances")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	var glooInstance *rpc_edge_v1.GlooInstance
	for _, instance := range instanceList {
		watchedNamespaces := instance.Spec.GetControlPlane().GetWatchedNamespaces()
		if len(watchedNamespaces) == 0 {
			glooInstance = instance
			break
		}
		for _, ns := range watchedNamespaces {
			if ns == RouteTableRef.GetNamespace() {
				glooInstance = instance
				break
			}
		}
		if glooInstance != nil {
			break
		}
	}
	if glooInstance == nil {
		return nil, eris.Errorf("Failed to find a gloo edge instance for namespace %s", RouteTable.GetNamespace())
	}
	rpcRouteTable := &rpc_edge_v1.RouteTable{
		Metadata: apiserverutils.ToMetadata(RouteTable.ObjectMeta),
		GlooInstance: &skv2_v1.ObjectRef{
			Name:      glooInstance.GetMetadata().GetName(),
			Namespace: glooInstance.GetMetadata().GetNamespace(),
		},
		Spec:   &RouteTable.Spec,
		Status: &RouteTable.Status,
	}
	rpcRouteTable.Metadata.ClusterName = glooInstance.GetSpec().GetCluster()
	return &rpc_edge_v1.GetRouteTableDetailsResponse{
		RouteTable: rpcRouteTable,
	}, nil
}
