// Code generated by skv2. DO NOT EDIT.

package gateway_resource_handler

import (
	"context"

	"github.com/solo-io/go-utils/contextutils"
	"github.com/solo-io/go-utils/stringutils"
	corev1 "github.com/solo-io/skv2/pkg/api/core.skv2.solo.io/v1"
	types "github.com/solo-io/solo-apis/pkg/api/gateway.solo.io/v1"
	rpc_edge_v1 "github.com/solo-io/solo-projects/projects/apiserver/pkg/api/rpc.edge.gloo/v1"
	"github.com/solo-io/solo-projects/projects/apiserver/server/apiserverutils"
	"go.uber.org/zap"
)

func GetGatewaySummary(ctx context.Context, gatewayClient types.GatewayClient, watchedNamespaces []string) *rpc_edge_v1.GlooInstance_GlooInstanceSpec_Check_Summary {
	summary := &rpc_edge_v1.GlooInstance_GlooInstanceSpec_Check_Summary{}

	gatewayList, err := gatewayClient.ListGateway(ctx)
	if err != nil {
		contextutils.LoggerFrom(ctx).Warnw("Failed to get Gateway summary", zap.Error(err), zap.Any("watchedNamespaces", watchedNamespaces))
		return summary
	}

	for _, gateway := range gatewayList.Items {
		gateway := gateway

		// If the resource is not in a watched namespace, continue
		if len(watchedNamespaces) > 0 && !stringutils.ContainsString(gateway.Namespace, watchedNamespaces) {
			continue
		}

		summary.Total += 1

		if gateway.Status.GetState() == types.GatewayStatus_Rejected {
			summary.Errors = append(summary.Errors, &rpc_edge_v1.GlooInstance_GlooInstanceSpec_Check_Summary_ResourceReport{
				Ref: &corev1.ObjectRef{
					Name:      gateway.Name,
					Namespace: gateway.Namespace,
				},
				Message: gateway.Status.Reason,
			})
		}

		if gateway.Status.GetState() == types.GatewayStatus_Warning {
			summary.Warnings = append(summary.Warnings, &rpc_edge_v1.GlooInstance_GlooInstanceSpec_Check_Summary_ResourceReport{
				Ref: &corev1.ObjectRef{
					Name:      gateway.Name,
					Namespace: gateway.Namespace,
				},
				Message: gateway.Status.Reason,
			})
		}

	}

	apiserverutils.SortCheckSummaryLists(summary)
	return summary
}

func GetMatchableHttpGatewaySummary(ctx context.Context, matchableHttpGatewayClient types.MatchableHttpGatewayClient, watchedNamespaces []string) *rpc_edge_v1.GlooInstance_GlooInstanceSpec_Check_Summary {
	summary := &rpc_edge_v1.GlooInstance_GlooInstanceSpec_Check_Summary{}

	matchableHttpGatewayList, err := matchableHttpGatewayClient.ListMatchableHttpGateway(ctx)
	if err != nil {
		contextutils.LoggerFrom(ctx).Warnw("Failed to get MatchableHttpGateway summary", zap.Error(err), zap.Any("watchedNamespaces", watchedNamespaces))
		return summary
	}

	for _, matchableHttpGateway := range matchableHttpGatewayList.Items {
		matchableHttpGateway := matchableHttpGateway

		// If the resource is not in a watched namespace, continue
		if len(watchedNamespaces) > 0 && !stringutils.ContainsString(matchableHttpGateway.Namespace, watchedNamespaces) {
			continue
		}

		summary.Total += 1

		if matchableHttpGateway.Status.GetState() == types.MatchableHttpGatewayStatus_Rejected {
			summary.Errors = append(summary.Errors, &rpc_edge_v1.GlooInstance_GlooInstanceSpec_Check_Summary_ResourceReport{
				Ref: &corev1.ObjectRef{
					Name:      matchableHttpGateway.Name,
					Namespace: matchableHttpGateway.Namespace,
				},
				Message: matchableHttpGateway.Status.Reason,
			})
		}

		if matchableHttpGateway.Status.GetState() == types.MatchableHttpGatewayStatus_Warning {
			summary.Warnings = append(summary.Warnings, &rpc_edge_v1.GlooInstance_GlooInstanceSpec_Check_Summary_ResourceReport{
				Ref: &corev1.ObjectRef{
					Name:      matchableHttpGateway.Name,
					Namespace: matchableHttpGateway.Namespace,
				},
				Message: matchableHttpGateway.Status.Reason,
			})
		}

	}

	apiserverutils.SortCheckSummaryLists(summary)
	return summary
}

func GetMatchableTcpGatewaySummary(ctx context.Context, matchableTcpGatewayClient types.MatchableTcpGatewayClient, watchedNamespaces []string) *rpc_edge_v1.GlooInstance_GlooInstanceSpec_Check_Summary {
	summary := &rpc_edge_v1.GlooInstance_GlooInstanceSpec_Check_Summary{}

	matchableTcpGatewayList, err := matchableTcpGatewayClient.ListMatchableTcpGateway(ctx)
	if err != nil {
		contextutils.LoggerFrom(ctx).Warnw("Failed to get MatchableTcpGateway summary", zap.Error(err), zap.Any("watchedNamespaces", watchedNamespaces))
		return summary
	}

	for _, matchableTcpGateway := range matchableTcpGatewayList.Items {
		matchableTcpGateway := matchableTcpGateway

		// If the resource is not in a watched namespace, continue
		if len(watchedNamespaces) > 0 && !stringutils.ContainsString(matchableTcpGateway.Namespace, watchedNamespaces) {
			continue
		}

		summary.Total += 1

		if matchableTcpGateway.Status.GetState() == types.MatchableTcpGatewayStatus_Rejected {
			summary.Errors = append(summary.Errors, &rpc_edge_v1.GlooInstance_GlooInstanceSpec_Check_Summary_ResourceReport{
				Ref: &corev1.ObjectRef{
					Name:      matchableTcpGateway.Name,
					Namespace: matchableTcpGateway.Namespace,
				},
				Message: matchableTcpGateway.Status.Reason,
			})
		}

		if matchableTcpGateway.Status.GetState() == types.MatchableTcpGatewayStatus_Warning {
			summary.Warnings = append(summary.Warnings, &rpc_edge_v1.GlooInstance_GlooInstanceSpec_Check_Summary_ResourceReport{
				Ref: &corev1.ObjectRef{
					Name:      matchableTcpGateway.Name,
					Namespace: matchableTcpGateway.Namespace,
				},
				Message: matchableTcpGateway.Status.Reason,
			})
		}

	}

	apiserverutils.SortCheckSummaryLists(summary)
	return summary
}

func GetVirtualServiceSummary(ctx context.Context, virtualServiceClient types.VirtualServiceClient, watchedNamespaces []string) *rpc_edge_v1.GlooInstance_GlooInstanceSpec_Check_Summary {
	summary := &rpc_edge_v1.GlooInstance_GlooInstanceSpec_Check_Summary{}

	virtualServiceList, err := virtualServiceClient.ListVirtualService(ctx)
	if err != nil {
		contextutils.LoggerFrom(ctx).Warnw("Failed to get VirtualService summary", zap.Error(err), zap.Any("watchedNamespaces", watchedNamespaces))
		return summary
	}

	for _, virtualService := range virtualServiceList.Items {
		virtualService := virtualService

		// If the resource is not in a watched namespace, continue
		if len(watchedNamespaces) > 0 && !stringutils.ContainsString(virtualService.Namespace, watchedNamespaces) {
			continue
		}

		summary.Total += 1

		if virtualService.Status.GetState() == types.VirtualServiceStatus_Rejected {
			summary.Errors = append(summary.Errors, &rpc_edge_v1.GlooInstance_GlooInstanceSpec_Check_Summary_ResourceReport{
				Ref: &corev1.ObjectRef{
					Name:      virtualService.Name,
					Namespace: virtualService.Namespace,
				},
				Message: virtualService.Status.Reason,
			})
		}

		if virtualService.Status.GetState() == types.VirtualServiceStatus_Warning {
			summary.Warnings = append(summary.Warnings, &rpc_edge_v1.GlooInstance_GlooInstanceSpec_Check_Summary_ResourceReport{
				Ref: &corev1.ObjectRef{
					Name:      virtualService.Name,
					Namespace: virtualService.Namespace,
				},
				Message: virtualService.Status.Reason,
			})
		}

	}

	apiserverutils.SortCheckSummaryLists(summary)
	return summary
}

func GetRouteTableSummary(ctx context.Context, routeTableClient types.RouteTableClient, watchedNamespaces []string) *rpc_edge_v1.GlooInstance_GlooInstanceSpec_Check_Summary {
	summary := &rpc_edge_v1.GlooInstance_GlooInstanceSpec_Check_Summary{}

	routeTableList, err := routeTableClient.ListRouteTable(ctx)
	if err != nil {
		contextutils.LoggerFrom(ctx).Warnw("Failed to get RouteTable summary", zap.Error(err), zap.Any("watchedNamespaces", watchedNamespaces))
		return summary
	}

	for _, routeTable := range routeTableList.Items {
		routeTable := routeTable

		// If the resource is not in a watched namespace, continue
		if len(watchedNamespaces) > 0 && !stringutils.ContainsString(routeTable.Namespace, watchedNamespaces) {
			continue
		}

		summary.Total += 1

		if routeTable.Status.GetState() == types.RouteTableStatus_Rejected {
			summary.Errors = append(summary.Errors, &rpc_edge_v1.GlooInstance_GlooInstanceSpec_Check_Summary_ResourceReport{
				Ref: &corev1.ObjectRef{
					Name:      routeTable.Name,
					Namespace: routeTable.Namespace,
				},
				Message: routeTable.Status.Reason,
			})
		}

		if routeTable.Status.GetState() == types.RouteTableStatus_Warning {
			summary.Warnings = append(summary.Warnings, &rpc_edge_v1.GlooInstance_GlooInstanceSpec_Check_Summary_ResourceReport{
				Ref: &corev1.ObjectRef{
					Name:      routeTable.Name,
					Namespace: routeTable.Namespace,
				},
				Message: routeTable.Status.Reason,
			})
		}

	}

	apiserverutils.SortCheckSummaryLists(summary)
	return summary
}
