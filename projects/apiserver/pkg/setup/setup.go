package setup

import (
	"bytes"
	"context"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"math/rand"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/gorilla/websocket"
	"github.com/solo-io/gloo/pkg/utils/setuputils"
	v1 "github.com/solo-io/gloo/projects/gloo/pkg/api/v1"
	"github.com/solo-io/solo-projects/projects/apiserver/pkg/config"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/handler"
	"github.com/rs/cors"
	"github.com/solo-io/go-utils/contextutils"
	"github.com/solo-io/solo-kit/pkg/api/v1/clients/kube"
	"github.com/solo-io/solo-kit/pkg/api/v1/clients/memory"
	"github.com/solo-io/solo-projects/projects/apiserver/pkg/auth"
	apiServer "github.com/solo-io/solo-projects/projects/apiserver/pkg/graphql"
	"github.com/solo-io/solo-projects/projects/apiserver/pkg/graphql/graph"
)

const (
	envDebug                = "DEBUG"
	envEnableQueryRecording = "DEBUG_RECORD_QUERIES"
	maxRecordedQueries      = 100
)

func init() {
	rand.Seed(int64(time.Now().UnixNano()))
}

// Main initializes the api server
func Main() error {
	return setuputils.Main(setuputils.SetupOpts{
		LoggingPrefix: "apiserver",
		SetupFunc:     Setup,
		ExitOnError:   true,
	})
}

func Setup(ctx context.Context,
	kubeCache kube.SharedCache,
	inMemoryCache memory.InMemoryResourceCache,
	settings *v1.Settings) error {

	port := flag.Int("p", 8082, "port to bind")
	flag.Parse()

	debugMode := os.Getenv(envDebug) == "1"
	recordQueries := os.Getenv(envEnableQueryRecording) == "1"

	// fail fast if the environment is not correctly configured
	config.ValidateEnvVars()

	contextutils.LoggerFrom(ctx).Infof("listening on :%v", *port)

	// Serve the query route such that it can be accessed from our UI during development
	corsSettings := cors.New(cors.Options{
		AllowedOrigins:   config.CorsAllowedOrigins,
		AllowedHeaders:   config.CorsAllowedHeaders,
		AllowCredentials: true,
		Debug:            debugMode,
	})

	// Clientset registry
	perTokenClientsets := NewPerTokenClientsets()

	rMap := make(requestMap)
	http.Handle("/querylog", http.HandlerFunc(queryLog(rMap, recordQueries)))
	http.Handle("/querylog/go", http.HandlerFunc(queryLogGo(rMap, recordQueries)))
	http.Handle("/playground", handler.Playground("Solo-ApiServer", "/query"))
	http.Handle("/query",
		recorder(recordQueries,
			rMap,
			gqlHandler(ctx,
				perTokenClientsets,
				settings,
				corsSettings,
				debugMode)))

	return http.ListenAndServe(fmt.Sprintf(":%v", *port), nil)
}

func recorder(recordQueries bool, rMap requestMap, next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if recordQueries {
			readQueryFromBody(rMap, r)
		}
		next.ServeHTTP(w, r)
	})
}

func gqlHandler(ctx context.Context, perTokenClientsets PerTokenClientsets, settings *v1.Settings, corsSettings *cors.Cors, debugMode bool) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {

		var resolvers graph.ResolverRoot
		token := auth.GetToken(w, r)
		/*
		 *	TODO: temporary hack to bypass authentication.
		 *  If SkipAuth is set, ClientsetForToken("") will return a clientset
		 *  that uses the pod service account to call the Kubernetes API.
		 */
		if token == "" && config.SkipAuth == "" {
			resolvers = apiServer.NewUnregisteredResolver()
		} else {

			// get from cache or create anew
			clientset, err := perTokenClientsets.ClientsetForToken(ctx, settings, token)
			if err != nil {
				contextutils.LoggerFrom(ctx).Errorf("failed to create clientset: %v", err)
				http.Error(w, err.Error(), http.StatusInternalServerError)
				return
			}
			resolvers = clientset.NewResolvers()
		}
		corsSettings.Handler(handler.GraphQL(
			graph.NewExecutableSchema(graph.Config{
				Resolvers: resolvers,
			}),
			getResolverMiddleware(debugMode),
			handler.WebsocketUpgrader(websocket.Upgrader{
				CheckOrigin: func(r *http.Request) bool {
					return true
				},
			}),
		)).ServeHTTP(w, r)
	})
}

type requestMap map[string]string

func queryLog(rMap requestMap, recordQueries bool) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		// only expose /querylog when enabled
		if recordQueries {
			fmt.Fprintf(w, "Query Log:\n")
			for k, v := range rMap {
				fmt.Fprintf(w, "key: %v, val: %v\n", k, v)
			}
		} else {
			fmt.Fprintf(w, "This endpoint is not exposed, enable it by setting the env var %v=1.\n", envEnableQueryRecording)
		}
	}
}

func queryLogGo(rMap requestMap, recordQueries bool) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		// only expose /querylog when enabled
		if recordQueries {
			if len(rMap) < 2 {
				fmt.Fprintf(w, "Please record at least 2 queries before collecting the Go output.")
			} else {
				rootRand := rand.Int63()
				fmt.Fprintf(w, "// Code generated by apiserver recorder. DO NOT EDIT.\n")
				fmt.Fprintf(w, "// id: %v\n\n", rootRand)
				fmt.Fprintf(w, "package queries\n\n")
				count := 0
				queryList := []string{}
				for k, v := range rMap {
					var_name := fmt.Sprintf("query_%v_%v", rootRand, count)
					queryList = append(queryList, var_name)
					fmt.Fprintf(w, "// timestamp: %v\n", k)
					fmt.Fprintf(w, "const %v = `%v`\n", var_name, v)
					fmt.Fprintf(w, "\n")
					count++
				}
				fmt.Fprintf(w, "var Queries_%v = []string{\n\t%v,\n}", rootRand, strings.Join(queryList, ",\n\t"))
			}
		} else {
			fmt.Fprintf(w, "This endpoint is not exposed, enable it by setting the env var %v=1.\n", envEnableQueryRecording)
		}
	}
}

func readQueryFromBody(rMap requestMap, r *http.Request) {
	// prevent excessive memory use
	if len(rMap) > maxRecordedQueries {
		return
	}

	p := new(bytes.Buffer)
	if _, err := io.Copy(p, r.Body); err != nil {
		fmt.Println(err)
	}

	// Close the body's original reader and restore it with a new one
	r.Body.Close()
	r.Body = ioutil.NopCloser(bytes.NewBuffer(p.Bytes()))

	// store the request body in our request map
	rMap[fmt.Sprintf("%v", time.Now())] = p.String()
}

func getResolverMiddleware(debugMode bool) handler.Option {
	return handler.ResolverMiddleware(func(ctx context.Context, next graphql.Resolver) (res interface{}, err error) {
		rc := graphql.GetResolverContext(ctx)
		if debugMode {
			// note: many of our queries will produce cyclic objects
			// printing truncated string representations is an easy alternative to cycle detection
			fmt.Println("Entered", rc.Object, rc.Field.Name)
		}
		res, err = next(ctx)
		if debugMode {
			fmt.Println("Left", rc.Object, rc.Field.Name, "=>", res, err)
		}
		return res, err
	})
}
