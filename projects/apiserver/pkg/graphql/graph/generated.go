// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/solo-io/solo-projects/projects/apiserver/pkg/graphql/customtypes"
	"github.com/solo-io/solo-projects/projects/apiserver/pkg/graphql/models"
	"github.com/vektah/gqlparser"
	"github.com/vektah/gqlparser/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	ArtifactMutation() ArtifactMutationResolver
	Mutation() MutationResolver
	Namespace() NamespaceResolver
	Query() QueryResolver
	SecretMutation() SecretMutationResolver
	SettingsMutation() SettingsMutationResolver
	Subscription() SubscriptionResolver
	UpstreamMutation() UpstreamMutationResolver
	VirtualServiceMutation() VirtualServiceMutationResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Artifact struct {
		Data     func(childComplexity int) int
		Metadata func(childComplexity int) int
	}

	ArtifactMutation struct {
		Create func(childComplexity int, artifact models.InputArtifact) int
		Update func(childComplexity int, artifact models.InputArtifact) int
		Delete func(childComplexity int, guid string) int
	}

	AwsDestinationSpec struct {
		LogicalName            func(childComplexity int) int
		InvocationStyle        func(childComplexity int) int
		ResponseTransformation func(childComplexity int) int
	}

	AwsLambdaFunction struct {
		LogicalName  func(childComplexity int) int
		FunctionName func(childComplexity int) int
		Qualifier    func(childComplexity int) int
	}

	AwsSecret struct {
		AccessKey func(childComplexity int) int
		SecretKey func(childComplexity int) int
	}

	AwsUpstreamSpec struct {
		Region    func(childComplexity int) int
		SecretRef func(childComplexity int) int
		Functions func(childComplexity int) int
	}

	AzureDestinationSpec struct {
		FunctionName func(childComplexity int) int
	}

	AzureFunction struct {
		FunctionName func(childComplexity int) int
		AuthLevel    func(childComplexity int) int
	}

	AzureSecret struct {
		ApiKeys func(childComplexity int) int
	}

	AzureUpstreamSpec struct {
		FunctionAppName func(childComplexity int) int
		SecretRef       func(childComplexity int) int
		Functions       func(childComplexity int) int
	}

	GrpcDestinationSpec struct {
		Package    func(childComplexity int) int
		Service    func(childComplexity int) int
		Function   func(childComplexity int) int
		Parameters func(childComplexity int) int
	}

	GrpcService struct {
		PackageName   func(childComplexity int) int
		ServiceName   func(childComplexity int) int
		FunctionNames func(childComplexity int) int
	}

	GrpcServiceSpec struct {
		GrpcServices func(childComplexity int) int
	}

	KeyValueMatcher struct {
		Name    func(childComplexity int) int
		Value   func(childComplexity int) int
		IsRegex func(childComplexity int) int
	}

	KubeUpstreamSpec struct {
		ServiceName      func(childComplexity int) int
		ServiceNamespace func(childComplexity int) int
		ServicePort      func(childComplexity int) int
		Selector         func(childComplexity int) int
		ServiceSpec      func(childComplexity int) int
	}

	MapStringString struct {
		Values func(childComplexity int) int
	}

	Matcher struct {
		PathMatch       func(childComplexity int) int
		PathMatchType   func(childComplexity int) int
		Headers         func(childComplexity int) int
		QueryParameters func(childComplexity int) int
		Methods         func(childComplexity int) int
	}

	Metadata struct {
		Name            func(childComplexity int) int
		Namespace       func(childComplexity int) int
		ResourceVersion func(childComplexity int) int
		Labels          func(childComplexity int) int
		Annotations     func(childComplexity int) int
		Guid            func(childComplexity int) int
	}

	MultiDestination struct {
		Destinations func(childComplexity int) int
	}

	Mutation struct {
		Upstreams       func(childComplexity int) int
		VirtualServices func(childComplexity int) int
		Secrets         func(childComplexity int) int
		Artifacts       func(childComplexity int) int
		Settings        func(childComplexity int) int
	}

	Namespace struct {
		Name            func(childComplexity int) int
		Upstreams       func(childComplexity int) int
		Upstream        func(childComplexity int, name string) int
		VirtualServices func(childComplexity int) int
		VirtualService  func(childComplexity int, name string) int
		Secrets         func(childComplexity int) int
		Secret          func(childComplexity int, name string) int
		Artifacts       func(childComplexity int) int
		Artifact        func(childComplexity int, name string) int
	}

	OauthEndpoint struct {
		Url        func(childComplexity int) int
		ClientName func(childComplexity int) int
	}

	Query struct {
		Version          func(childComplexity int) int
		GetOauthEndpoint func(childComplexity int) int
		AllNamespaces    func(childComplexity int) int
		Namespace        func(childComplexity int, name string) int
		Settings         func(childComplexity int) int
	}

	RateLimit struct {
		Unit            func(childComplexity int) int
		RequestsPerUnit func(childComplexity int) int
	}

	RateLimitConfig struct {
		AuthorizedLimits func(childComplexity int) int
		AnonymousLimits  func(childComplexity int) int
	}

	ResourceRef struct {
		Name      func(childComplexity int) int
		Namespace func(childComplexity int) int
	}

	RestDestinationSpec struct {
		FunctionName func(childComplexity int) int
		Parameters   func(childComplexity int) int
	}

	RestServiceSpec struct {
		Functions func(childComplexity int) int
	}

	Route struct {
		Matcher     func(childComplexity int) int
		Destination func(childComplexity int) int
		Plugins     func(childComplexity int) int
	}

	RoutePlugins struct {
		Empty func(childComplexity int) int
	}

	Secret struct {
		Kind     func(childComplexity int) int
		Metadata func(childComplexity int) int
	}

	SecretMutation struct {
		Create func(childComplexity int, secret models.InputSecret) int
		Update func(childComplexity int, secret models.InputSecret) int
		Delete func(childComplexity int, guid string) int
	}

	Settings struct {
		WatchNamespaces func(childComplexity int) int
		RefreshRate     func(childComplexity int) int
		Metadata        func(childComplexity int) int
	}

	SettingsMutation struct {
		Update func(childComplexity int, settings models.InputSettings) int
	}

	SingleDestination struct {
		Upstream        func(childComplexity int) int
		DestinationSpec func(childComplexity int) int
	}

	SslConfig struct {
		SecretRef func(childComplexity int) int
	}

	StaticHost struct {
		Addr func(childComplexity int) int
		Port func(childComplexity int) int
	}

	StaticUpstreamSpec struct {
		Hosts       func(childComplexity int) int
		ServiceSpec func(childComplexity int) int
		UseTls      func(childComplexity int) int
	}

	Status struct {
		State  func(childComplexity int) int
		Reason func(childComplexity int) int
	}

	Subscription struct {
		Upstreams       func(childComplexity int, namespace string, selector *models.InputMapStringString) int
		VirtualServices func(childComplexity int, namespace string, selector *models.InputMapStringString) int
	}

	TlsSecret struct {
		CertChain  func(childComplexity int) int
		PrivateKey func(childComplexity int) int
		RootCa     func(childComplexity int) int
	}

	Transformation struct {
		FunctionName func(childComplexity int) int
		Body         func(childComplexity int) int
		Headers      func(childComplexity int) int
	}

	TransformationParameters struct {
		Headers func(childComplexity int) int
		Path    func(childComplexity int) int
	}

	Upstream struct {
		Spec     func(childComplexity int) int
		Metadata func(childComplexity int) int
		Status   func(childComplexity int) int
	}

	UpstreamMutation struct {
		Create func(childComplexity int, upstream models.InputUpstream) int
		Update func(childComplexity int, upstream models.InputUpstream) int
		Delete func(childComplexity int, guid string) int
	}

	Value struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	VirtualService struct {
		Metadata        func(childComplexity int) int
		Status          func(childComplexity int) int
		Domains         func(childComplexity int) int
		Routes          func(childComplexity int) int
		SslConfig       func(childComplexity int) int
		RateLimitConfig func(childComplexity int) int
		Plugins         func(childComplexity int) int
	}

	VirtualServiceMutation struct {
		Create      func(childComplexity int, virtualService models.InputVirtualService) int
		Update      func(childComplexity int, virtualServiceId string, resourceVersion string, updates models.InputUpdateVirtualService) int
		Delete      func(childComplexity int, guid string) int
		AddRoute    func(childComplexity int, virtualServiceId string, resourceVersion string, index int, route models.InputRoute) int
		UpdateRoute func(childComplexity int, virtualServiceId string, resourceVersion string, index int, route models.InputRoute) int
		DeleteRoute func(childComplexity int, virtualServiceId string, resourceVersion string, index int) int
		SwapRoutes  func(childComplexity int, virtualServiceId string, resourceVersion string, index1 int, index2 int) int
		ShiftRoutes func(childComplexity int, virtualServiceId string, resourceVersion string, fromIndex int, toIndex int) int
	}

	VirtualServicePlugins struct {
		Empty func(childComplexity int) int
	}

	WeightedDestination struct {
		Destination func(childComplexity int) int
		Weight      func(childComplexity int) int
	}
}

type ArtifactMutationResolver interface {
	Create(ctx context.Context, obj *customtypes.ArtifactMutation, artifact models.InputArtifact) (*models.Artifact, error)
	Update(ctx context.Context, obj *customtypes.ArtifactMutation, artifact models.InputArtifact) (*models.Artifact, error)
	Delete(ctx context.Context, obj *customtypes.ArtifactMutation, guid string) (*models.Artifact, error)
}
type MutationResolver interface {
	Upstreams(ctx context.Context) (customtypes.UpstreamMutation, error)
	VirtualServices(ctx context.Context) (customtypes.VirtualServiceMutation, error)
	Secrets(ctx context.Context) (customtypes.SecretMutation, error)
	Artifacts(ctx context.Context) (customtypes.ArtifactMutation, error)
	Settings(ctx context.Context) (customtypes.SettingsMutation, error)
}
type NamespaceResolver interface {
	Upstreams(ctx context.Context, obj *customtypes.Namespace) ([]*models.Upstream, error)
	Upstream(ctx context.Context, obj *customtypes.Namespace, name string) (*models.Upstream, error)
	VirtualServices(ctx context.Context, obj *customtypes.Namespace) ([]*models.VirtualService, error)
	VirtualService(ctx context.Context, obj *customtypes.Namespace, name string) (*models.VirtualService, error)
	Secrets(ctx context.Context, obj *customtypes.Namespace) ([]*models.Secret, error)
	Secret(ctx context.Context, obj *customtypes.Namespace, name string) (*models.Secret, error)
	Artifacts(ctx context.Context, obj *customtypes.Namespace) ([]*models.Artifact, error)
	Artifact(ctx context.Context, obj *customtypes.Namespace, name string) (*models.Artifact, error)
}
type QueryResolver interface {
	Version(ctx context.Context) (string, error)
	GetOAuthEndpoint(ctx context.Context) (models.OAuthEndpoint, error)
	AllNamespaces(ctx context.Context) ([]customtypes.Namespace, error)
	Namespace(ctx context.Context, name string) (customtypes.Namespace, error)
	Settings(ctx context.Context) (*models.Settings, error)
}
type SecretMutationResolver interface {
	Create(ctx context.Context, obj *customtypes.SecretMutation, secret models.InputSecret) (*models.Secret, error)
	Update(ctx context.Context, obj *customtypes.SecretMutation, secret models.InputSecret) (*models.Secret, error)
	Delete(ctx context.Context, obj *customtypes.SecretMutation, guid string) (*models.Secret, error)
}
type SettingsMutationResolver interface {
	Update(ctx context.Context, obj *customtypes.SettingsMutation, settings models.InputSettings) (*models.Settings, error)
}
type SubscriptionResolver interface {
	Upstreams(ctx context.Context, namespace string, selector *models.InputMapStringString) (<-chan []*models.Upstream, error)
	VirtualServices(ctx context.Context, namespace string, selector *models.InputMapStringString) (<-chan []*models.VirtualService, error)
}
type UpstreamMutationResolver interface {
	Create(ctx context.Context, obj *customtypes.UpstreamMutation, upstream models.InputUpstream) (*models.Upstream, error)
	Update(ctx context.Context, obj *customtypes.UpstreamMutation, upstream models.InputUpstream) (*models.Upstream, error)
	Delete(ctx context.Context, obj *customtypes.UpstreamMutation, guid string) (*models.Upstream, error)
}
type VirtualServiceMutationResolver interface {
	Create(ctx context.Context, obj *customtypes.VirtualServiceMutation, virtualService models.InputVirtualService) (*models.VirtualService, error)
	Update(ctx context.Context, obj *customtypes.VirtualServiceMutation, virtualServiceId string, resourceVersion string, updates models.InputUpdateVirtualService) (*models.VirtualService, error)
	Delete(ctx context.Context, obj *customtypes.VirtualServiceMutation, guid string) (*models.VirtualService, error)
	AddRoute(ctx context.Context, obj *customtypes.VirtualServiceMutation, virtualServiceId string, resourceVersion string, index int, route models.InputRoute) (*models.VirtualService, error)
	UpdateRoute(ctx context.Context, obj *customtypes.VirtualServiceMutation, virtualServiceId string, resourceVersion string, index int, route models.InputRoute) (*models.VirtualService, error)
	DeleteRoute(ctx context.Context, obj *customtypes.VirtualServiceMutation, virtualServiceId string, resourceVersion string, index int) (*models.VirtualService, error)
	SwapRoutes(ctx context.Context, obj *customtypes.VirtualServiceMutation, virtualServiceId string, resourceVersion string, index1 int, index2 int) (*models.VirtualService, error)
	ShiftRoutes(ctx context.Context, obj *customtypes.VirtualServiceMutation, virtualServiceId string, resourceVersion string, fromIndex int, toIndex int) (*models.VirtualService, error)
}

func field_ArtifactMutation_create_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 models.InputArtifact
	if tmp, ok := rawArgs["artifact"]; ok {
		var err error
		arg0, err = UnmarshalInputArtifact(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["artifact"] = arg0
	return args, nil

}

func field_ArtifactMutation_update_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 models.InputArtifact
	if tmp, ok := rawArgs["artifact"]; ok {
		var err error
		arg0, err = UnmarshalInputArtifact(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["artifact"] = arg0
	return args, nil

}

func field_ArtifactMutation_delete_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["guid"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["guid"] = arg0
	return args, nil

}

func field_Namespace_upstream_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_Namespace_virtualService_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_Namespace_secret_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_Namespace_artifact_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_Query_namespace_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_Query___type_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_SecretMutation_create_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 models.InputSecret
	if tmp, ok := rawArgs["secret"]; ok {
		var err error
		arg0, err = UnmarshalInputSecret(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["secret"] = arg0
	return args, nil

}

func field_SecretMutation_update_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 models.InputSecret
	if tmp, ok := rawArgs["secret"]; ok {
		var err error
		arg0, err = UnmarshalInputSecret(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["secret"] = arg0
	return args, nil

}

func field_SecretMutation_delete_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["guid"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["guid"] = arg0
	return args, nil

}

func field_SettingsMutation_update_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 models.InputSettings
	if tmp, ok := rawArgs["settings"]; ok {
		var err error
		arg0, err = UnmarshalInputSettings(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["settings"] = arg0
	return args, nil

}

func field_Subscription_upstreams_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *models.InputMapStringString
	if tmp, ok := rawArgs["selector"]; ok {
		var err error
		var ptr1 models.InputMapStringString
		if tmp != nil {
			ptr1, err = UnmarshalInputMapStringString(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["selector"] = arg1
	return args, nil

}

func field_Subscription_virtualServices_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *models.InputMapStringString
	if tmp, ok := rawArgs["selector"]; ok {
		var err error
		var ptr1 models.InputMapStringString
		if tmp != nil {
			ptr1, err = UnmarshalInputMapStringString(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["selector"] = arg1
	return args, nil

}

func field_UpstreamMutation_create_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 models.InputUpstream
	if tmp, ok := rawArgs["upstream"]; ok {
		var err error
		arg0, err = UnmarshalInputUpstream(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["upstream"] = arg0
	return args, nil

}

func field_UpstreamMutation_update_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 models.InputUpstream
	if tmp, ok := rawArgs["upstream"]; ok {
		var err error
		arg0, err = UnmarshalInputUpstream(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["upstream"] = arg0
	return args, nil

}

func field_UpstreamMutation_delete_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["guid"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["guid"] = arg0
	return args, nil

}

func field_VirtualServiceMutation_create_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 models.InputVirtualService
	if tmp, ok := rawArgs["virtualService"]; ok {
		var err error
		arg0, err = UnmarshalInputVirtualService(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["virtualService"] = arg0
	return args, nil

}

func field_VirtualServiceMutation_update_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["virtualServiceId"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["virtualServiceId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["resourceVersion"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resourceVersion"] = arg1
	var arg2 models.InputUpdateVirtualService
	if tmp, ok := rawArgs["updates"]; ok {
		var err error
		arg2, err = UnmarshalInputUpdateVirtualService(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["updates"] = arg2
	return args, nil

}

func field_VirtualServiceMutation_delete_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["guid"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["guid"] = arg0
	return args, nil

}

func field_VirtualServiceMutation_addRoute_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["virtualServiceId"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["virtualServiceId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["resourceVersion"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resourceVersion"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["index"]; ok {
		var err error
		arg2, err = graphql.UnmarshalInt(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["index"] = arg2
	var arg3 models.InputRoute
	if tmp, ok := rawArgs["route"]; ok {
		var err error
		arg3, err = UnmarshalInputRoute(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["route"] = arg3
	return args, nil

}

func field_VirtualServiceMutation_updateRoute_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["virtualServiceId"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["virtualServiceId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["resourceVersion"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resourceVersion"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["index"]; ok {
		var err error
		arg2, err = graphql.UnmarshalInt(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["index"] = arg2
	var arg3 models.InputRoute
	if tmp, ok := rawArgs["route"]; ok {
		var err error
		arg3, err = UnmarshalInputRoute(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["route"] = arg3
	return args, nil

}

func field_VirtualServiceMutation_deleteRoute_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["virtualServiceId"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["virtualServiceId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["resourceVersion"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resourceVersion"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["index"]; ok {
		var err error
		arg2, err = graphql.UnmarshalInt(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["index"] = arg2
	return args, nil

}

func field_VirtualServiceMutation_swapRoutes_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["virtualServiceId"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["virtualServiceId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["resourceVersion"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resourceVersion"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["index1"]; ok {
		var err error
		arg2, err = graphql.UnmarshalInt(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["index1"] = arg2
	var arg3 int
	if tmp, ok := rawArgs["index2"]; ok {
		var err error
		arg3, err = graphql.UnmarshalInt(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["index2"] = arg3
	return args, nil

}

func field_VirtualServiceMutation_shiftRoutes_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["virtualServiceId"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["virtualServiceId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["resourceVersion"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resourceVersion"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["fromIndex"]; ok {
		var err error
		arg2, err = graphql.UnmarshalInt(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["fromIndex"] = arg2
	var arg3 int
	if tmp, ok := rawArgs["toIndex"]; ok {
		var err error
		arg3, err = graphql.UnmarshalInt(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["toIndex"] = arg3
	return args, nil

}

func field___Type_fields_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil

}

func field___Type_enumValues_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil

}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	switch typeName + "." + field {

	case "Artifact.data":
		if e.complexity.Artifact.Data == nil {
			break
		}

		return e.complexity.Artifact.Data(childComplexity), true

	case "Artifact.metadata":
		if e.complexity.Artifact.Metadata == nil {
			break
		}

		return e.complexity.Artifact.Metadata(childComplexity), true

	case "ArtifactMutation.create":
		if e.complexity.ArtifactMutation.Create == nil {
			break
		}

		args, err := field_ArtifactMutation_create_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ArtifactMutation.Create(childComplexity, args["artifact"].(models.InputArtifact)), true

	case "ArtifactMutation.update":
		if e.complexity.ArtifactMutation.Update == nil {
			break
		}

		args, err := field_ArtifactMutation_update_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ArtifactMutation.Update(childComplexity, args["artifact"].(models.InputArtifact)), true

	case "ArtifactMutation.delete":
		if e.complexity.ArtifactMutation.Delete == nil {
			break
		}

		args, err := field_ArtifactMutation_delete_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ArtifactMutation.Delete(childComplexity, args["guid"].(string)), true

	case "AwsDestinationSpec.logicalName":
		if e.complexity.AwsDestinationSpec.LogicalName == nil {
			break
		}

		return e.complexity.AwsDestinationSpec.LogicalName(childComplexity), true

	case "AwsDestinationSpec.invocationStyle":
		if e.complexity.AwsDestinationSpec.InvocationStyle == nil {
			break
		}

		return e.complexity.AwsDestinationSpec.InvocationStyle(childComplexity), true

	case "AwsDestinationSpec.responseTransformation":
		if e.complexity.AwsDestinationSpec.ResponseTransformation == nil {
			break
		}

		return e.complexity.AwsDestinationSpec.ResponseTransformation(childComplexity), true

	case "AwsLambdaFunction.logicalName":
		if e.complexity.AwsLambdaFunction.LogicalName == nil {
			break
		}

		return e.complexity.AwsLambdaFunction.LogicalName(childComplexity), true

	case "AwsLambdaFunction.functionName":
		if e.complexity.AwsLambdaFunction.FunctionName == nil {
			break
		}

		return e.complexity.AwsLambdaFunction.FunctionName(childComplexity), true

	case "AwsLambdaFunction.qualifier":
		if e.complexity.AwsLambdaFunction.Qualifier == nil {
			break
		}

		return e.complexity.AwsLambdaFunction.Qualifier(childComplexity), true

	case "AwsSecret.accessKey":
		if e.complexity.AwsSecret.AccessKey == nil {
			break
		}

		return e.complexity.AwsSecret.AccessKey(childComplexity), true

	case "AwsSecret.secretKey":
		if e.complexity.AwsSecret.SecretKey == nil {
			break
		}

		return e.complexity.AwsSecret.SecretKey(childComplexity), true

	case "AwsUpstreamSpec.region":
		if e.complexity.AwsUpstreamSpec.Region == nil {
			break
		}

		return e.complexity.AwsUpstreamSpec.Region(childComplexity), true

	case "AwsUpstreamSpec.secretRef":
		if e.complexity.AwsUpstreamSpec.SecretRef == nil {
			break
		}

		return e.complexity.AwsUpstreamSpec.SecretRef(childComplexity), true

	case "AwsUpstreamSpec.functions":
		if e.complexity.AwsUpstreamSpec.Functions == nil {
			break
		}

		return e.complexity.AwsUpstreamSpec.Functions(childComplexity), true

	case "AzureDestinationSpec.functionName":
		if e.complexity.AzureDestinationSpec.FunctionName == nil {
			break
		}

		return e.complexity.AzureDestinationSpec.FunctionName(childComplexity), true

	case "AzureFunction.functionName":
		if e.complexity.AzureFunction.FunctionName == nil {
			break
		}

		return e.complexity.AzureFunction.FunctionName(childComplexity), true

	case "AzureFunction.authLevel":
		if e.complexity.AzureFunction.AuthLevel == nil {
			break
		}

		return e.complexity.AzureFunction.AuthLevel(childComplexity), true

	case "AzureSecret.apiKeys":
		if e.complexity.AzureSecret.ApiKeys == nil {
			break
		}

		return e.complexity.AzureSecret.ApiKeys(childComplexity), true

	case "AzureUpstreamSpec.functionAppName":
		if e.complexity.AzureUpstreamSpec.FunctionAppName == nil {
			break
		}

		return e.complexity.AzureUpstreamSpec.FunctionAppName(childComplexity), true

	case "AzureUpstreamSpec.secretRef":
		if e.complexity.AzureUpstreamSpec.SecretRef == nil {
			break
		}

		return e.complexity.AzureUpstreamSpec.SecretRef(childComplexity), true

	case "AzureUpstreamSpec.functions":
		if e.complexity.AzureUpstreamSpec.Functions == nil {
			break
		}

		return e.complexity.AzureUpstreamSpec.Functions(childComplexity), true

	case "GrpcDestinationSpec.package":
		if e.complexity.GrpcDestinationSpec.Package == nil {
			break
		}

		return e.complexity.GrpcDestinationSpec.Package(childComplexity), true

	case "GrpcDestinationSpec.service":
		if e.complexity.GrpcDestinationSpec.Service == nil {
			break
		}

		return e.complexity.GrpcDestinationSpec.Service(childComplexity), true

	case "GrpcDestinationSpec.function":
		if e.complexity.GrpcDestinationSpec.Function == nil {
			break
		}

		return e.complexity.GrpcDestinationSpec.Function(childComplexity), true

	case "GrpcDestinationSpec.parameters":
		if e.complexity.GrpcDestinationSpec.Parameters == nil {
			break
		}

		return e.complexity.GrpcDestinationSpec.Parameters(childComplexity), true

	case "GrpcService.packageName":
		if e.complexity.GrpcService.PackageName == nil {
			break
		}

		return e.complexity.GrpcService.PackageName(childComplexity), true

	case "GrpcService.serviceName":
		if e.complexity.GrpcService.ServiceName == nil {
			break
		}

		return e.complexity.GrpcService.ServiceName(childComplexity), true

	case "GrpcService.functionNames":
		if e.complexity.GrpcService.FunctionNames == nil {
			break
		}

		return e.complexity.GrpcService.FunctionNames(childComplexity), true

	case "GrpcServiceSpec.grpcServices":
		if e.complexity.GrpcServiceSpec.GrpcServices == nil {
			break
		}

		return e.complexity.GrpcServiceSpec.GrpcServices(childComplexity), true

	case "KeyValueMatcher.name":
		if e.complexity.KeyValueMatcher.Name == nil {
			break
		}

		return e.complexity.KeyValueMatcher.Name(childComplexity), true

	case "KeyValueMatcher.value":
		if e.complexity.KeyValueMatcher.Value == nil {
			break
		}

		return e.complexity.KeyValueMatcher.Value(childComplexity), true

	case "KeyValueMatcher.isRegex":
		if e.complexity.KeyValueMatcher.IsRegex == nil {
			break
		}

		return e.complexity.KeyValueMatcher.IsRegex(childComplexity), true

	case "KubeUpstreamSpec.serviceName":
		if e.complexity.KubeUpstreamSpec.ServiceName == nil {
			break
		}

		return e.complexity.KubeUpstreamSpec.ServiceName(childComplexity), true

	case "KubeUpstreamSpec.serviceNamespace":
		if e.complexity.KubeUpstreamSpec.ServiceNamespace == nil {
			break
		}

		return e.complexity.KubeUpstreamSpec.ServiceNamespace(childComplexity), true

	case "KubeUpstreamSpec.servicePort":
		if e.complexity.KubeUpstreamSpec.ServicePort == nil {
			break
		}

		return e.complexity.KubeUpstreamSpec.ServicePort(childComplexity), true

	case "KubeUpstreamSpec.selector":
		if e.complexity.KubeUpstreamSpec.Selector == nil {
			break
		}

		return e.complexity.KubeUpstreamSpec.Selector(childComplexity), true

	case "KubeUpstreamSpec.serviceSpec":
		if e.complexity.KubeUpstreamSpec.ServiceSpec == nil {
			break
		}

		return e.complexity.KubeUpstreamSpec.ServiceSpec(childComplexity), true

	case "MapStringString.values":
		if e.complexity.MapStringString.Values == nil {
			break
		}

		return e.complexity.MapStringString.Values(childComplexity), true

	case "Matcher.pathMatch":
		if e.complexity.Matcher.PathMatch == nil {
			break
		}

		return e.complexity.Matcher.PathMatch(childComplexity), true

	case "Matcher.pathMatchType":
		if e.complexity.Matcher.PathMatchType == nil {
			break
		}

		return e.complexity.Matcher.PathMatchType(childComplexity), true

	case "Matcher.headers":
		if e.complexity.Matcher.Headers == nil {
			break
		}

		return e.complexity.Matcher.Headers(childComplexity), true

	case "Matcher.queryParameters":
		if e.complexity.Matcher.QueryParameters == nil {
			break
		}

		return e.complexity.Matcher.QueryParameters(childComplexity), true

	case "Matcher.methods":
		if e.complexity.Matcher.Methods == nil {
			break
		}

		return e.complexity.Matcher.Methods(childComplexity), true

	case "Metadata.name":
		if e.complexity.Metadata.Name == nil {
			break
		}

		return e.complexity.Metadata.Name(childComplexity), true

	case "Metadata.namespace":
		if e.complexity.Metadata.Namespace == nil {
			break
		}

		return e.complexity.Metadata.Namespace(childComplexity), true

	case "Metadata.resourceVersion":
		if e.complexity.Metadata.ResourceVersion == nil {
			break
		}

		return e.complexity.Metadata.ResourceVersion(childComplexity), true

	case "Metadata.labels":
		if e.complexity.Metadata.Labels == nil {
			break
		}

		return e.complexity.Metadata.Labels(childComplexity), true

	case "Metadata.annotations":
		if e.complexity.Metadata.Annotations == nil {
			break
		}

		return e.complexity.Metadata.Annotations(childComplexity), true

	case "Metadata.guid":
		if e.complexity.Metadata.Guid == nil {
			break
		}

		return e.complexity.Metadata.Guid(childComplexity), true

	case "MultiDestination.destinations":
		if e.complexity.MultiDestination.Destinations == nil {
			break
		}

		return e.complexity.MultiDestination.Destinations(childComplexity), true

	case "Mutation.upstreams":
		if e.complexity.Mutation.Upstreams == nil {
			break
		}

		return e.complexity.Mutation.Upstreams(childComplexity), true

	case "Mutation.virtualServices":
		if e.complexity.Mutation.VirtualServices == nil {
			break
		}

		return e.complexity.Mutation.VirtualServices(childComplexity), true

	case "Mutation.secrets":
		if e.complexity.Mutation.Secrets == nil {
			break
		}

		return e.complexity.Mutation.Secrets(childComplexity), true

	case "Mutation.artifacts":
		if e.complexity.Mutation.Artifacts == nil {
			break
		}

		return e.complexity.Mutation.Artifacts(childComplexity), true

	case "Mutation.settings":
		if e.complexity.Mutation.Settings == nil {
			break
		}

		return e.complexity.Mutation.Settings(childComplexity), true

	case "Namespace.name":
		if e.complexity.Namespace.Name == nil {
			break
		}

		return e.complexity.Namespace.Name(childComplexity), true

	case "Namespace.upstreams":
		if e.complexity.Namespace.Upstreams == nil {
			break
		}

		return e.complexity.Namespace.Upstreams(childComplexity), true

	case "Namespace.upstream":
		if e.complexity.Namespace.Upstream == nil {
			break
		}

		args, err := field_Namespace_upstream_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Namespace.Upstream(childComplexity, args["name"].(string)), true

	case "Namespace.virtualServices":
		if e.complexity.Namespace.VirtualServices == nil {
			break
		}

		return e.complexity.Namespace.VirtualServices(childComplexity), true

	case "Namespace.virtualService":
		if e.complexity.Namespace.VirtualService == nil {
			break
		}

		args, err := field_Namespace_virtualService_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Namespace.VirtualService(childComplexity, args["name"].(string)), true

	case "Namespace.secrets":
		if e.complexity.Namespace.Secrets == nil {
			break
		}

		return e.complexity.Namespace.Secrets(childComplexity), true

	case "Namespace.secret":
		if e.complexity.Namespace.Secret == nil {
			break
		}

		args, err := field_Namespace_secret_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Namespace.Secret(childComplexity, args["name"].(string)), true

	case "Namespace.artifacts":
		if e.complexity.Namespace.Artifacts == nil {
			break
		}

		return e.complexity.Namespace.Artifacts(childComplexity), true

	case "Namespace.artifact":
		if e.complexity.Namespace.Artifact == nil {
			break
		}

		args, err := field_Namespace_artifact_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Namespace.Artifact(childComplexity, args["name"].(string)), true

	case "OAuthEndpoint.url":
		if e.complexity.OauthEndpoint.Url == nil {
			break
		}

		return e.complexity.OauthEndpoint.Url(childComplexity), true

	case "OAuthEndpoint.clientName":
		if e.complexity.OauthEndpoint.ClientName == nil {
			break
		}

		return e.complexity.OauthEndpoint.ClientName(childComplexity), true

	case "Query.version":
		if e.complexity.Query.Version == nil {
			break
		}

		return e.complexity.Query.Version(childComplexity), true

	case "Query.getOAuthEndpoint":
		if e.complexity.Query.GetOauthEndpoint == nil {
			break
		}

		return e.complexity.Query.GetOauthEndpoint(childComplexity), true

	case "Query.allNamespaces":
		if e.complexity.Query.AllNamespaces == nil {
			break
		}

		return e.complexity.Query.AllNamespaces(childComplexity), true

	case "Query.namespace":
		if e.complexity.Query.Namespace == nil {
			break
		}

		args, err := field_Query_namespace_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Namespace(childComplexity, args["name"].(string)), true

	case "Query.settings":
		if e.complexity.Query.Settings == nil {
			break
		}

		return e.complexity.Query.Settings(childComplexity), true

	case "RateLimit.unit":
		if e.complexity.RateLimit.Unit == nil {
			break
		}

		return e.complexity.RateLimit.Unit(childComplexity), true

	case "RateLimit.requestsPerUnit":
		if e.complexity.RateLimit.RequestsPerUnit == nil {
			break
		}

		return e.complexity.RateLimit.RequestsPerUnit(childComplexity), true

	case "RateLimitConfig.authorizedLimits":
		if e.complexity.RateLimitConfig.AuthorizedLimits == nil {
			break
		}

		return e.complexity.RateLimitConfig.AuthorizedLimits(childComplexity), true

	case "RateLimitConfig.anonymousLimits":
		if e.complexity.RateLimitConfig.AnonymousLimits == nil {
			break
		}

		return e.complexity.RateLimitConfig.AnonymousLimits(childComplexity), true

	case "ResourceRef.name":
		if e.complexity.ResourceRef.Name == nil {
			break
		}

		return e.complexity.ResourceRef.Name(childComplexity), true

	case "ResourceRef.namespace":
		if e.complexity.ResourceRef.Namespace == nil {
			break
		}

		return e.complexity.ResourceRef.Namespace(childComplexity), true

	case "RestDestinationSpec.functionName":
		if e.complexity.RestDestinationSpec.FunctionName == nil {
			break
		}

		return e.complexity.RestDestinationSpec.FunctionName(childComplexity), true

	case "RestDestinationSpec.parameters":
		if e.complexity.RestDestinationSpec.Parameters == nil {
			break
		}

		return e.complexity.RestDestinationSpec.Parameters(childComplexity), true

	case "RestServiceSpec.functions":
		if e.complexity.RestServiceSpec.Functions == nil {
			break
		}

		return e.complexity.RestServiceSpec.Functions(childComplexity), true

	case "Route.matcher":
		if e.complexity.Route.Matcher == nil {
			break
		}

		return e.complexity.Route.Matcher(childComplexity), true

	case "Route.destination":
		if e.complexity.Route.Destination == nil {
			break
		}

		return e.complexity.Route.Destination(childComplexity), true

	case "Route.plugins":
		if e.complexity.Route.Plugins == nil {
			break
		}

		return e.complexity.Route.Plugins(childComplexity), true

	case "RoutePlugins.empty":
		if e.complexity.RoutePlugins.Empty == nil {
			break
		}

		return e.complexity.RoutePlugins.Empty(childComplexity), true

	case "Secret.kind":
		if e.complexity.Secret.Kind == nil {
			break
		}

		return e.complexity.Secret.Kind(childComplexity), true

	case "Secret.metadata":
		if e.complexity.Secret.Metadata == nil {
			break
		}

		return e.complexity.Secret.Metadata(childComplexity), true

	case "SecretMutation.create":
		if e.complexity.SecretMutation.Create == nil {
			break
		}

		args, err := field_SecretMutation_create_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SecretMutation.Create(childComplexity, args["secret"].(models.InputSecret)), true

	case "SecretMutation.update":
		if e.complexity.SecretMutation.Update == nil {
			break
		}

		args, err := field_SecretMutation_update_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SecretMutation.Update(childComplexity, args["secret"].(models.InputSecret)), true

	case "SecretMutation.delete":
		if e.complexity.SecretMutation.Delete == nil {
			break
		}

		args, err := field_SecretMutation_delete_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SecretMutation.Delete(childComplexity, args["guid"].(string)), true

	case "Settings.watchNamespaces":
		if e.complexity.Settings.WatchNamespaces == nil {
			break
		}

		return e.complexity.Settings.WatchNamespaces(childComplexity), true

	case "Settings.refreshRate":
		if e.complexity.Settings.RefreshRate == nil {
			break
		}

		return e.complexity.Settings.RefreshRate(childComplexity), true

	case "Settings.metadata":
		if e.complexity.Settings.Metadata == nil {
			break
		}

		return e.complexity.Settings.Metadata(childComplexity), true

	case "SettingsMutation.update":
		if e.complexity.SettingsMutation.Update == nil {
			break
		}

		args, err := field_SettingsMutation_update_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SettingsMutation.Update(childComplexity, args["settings"].(models.InputSettings)), true

	case "SingleDestination.upstream":
		if e.complexity.SingleDestination.Upstream == nil {
			break
		}

		return e.complexity.SingleDestination.Upstream(childComplexity), true

	case "SingleDestination.destinationSpec":
		if e.complexity.SingleDestination.DestinationSpec == nil {
			break
		}

		return e.complexity.SingleDestination.DestinationSpec(childComplexity), true

	case "SslConfig.secretRef":
		if e.complexity.SslConfig.SecretRef == nil {
			break
		}

		return e.complexity.SslConfig.SecretRef(childComplexity), true

	case "StaticHost.addr":
		if e.complexity.StaticHost.Addr == nil {
			break
		}

		return e.complexity.StaticHost.Addr(childComplexity), true

	case "StaticHost.port":
		if e.complexity.StaticHost.Port == nil {
			break
		}

		return e.complexity.StaticHost.Port(childComplexity), true

	case "StaticUpstreamSpec.hosts":
		if e.complexity.StaticUpstreamSpec.Hosts == nil {
			break
		}

		return e.complexity.StaticUpstreamSpec.Hosts(childComplexity), true

	case "StaticUpstreamSpec.serviceSpec":
		if e.complexity.StaticUpstreamSpec.ServiceSpec == nil {
			break
		}

		return e.complexity.StaticUpstreamSpec.ServiceSpec(childComplexity), true

	case "StaticUpstreamSpec.useTls":
		if e.complexity.StaticUpstreamSpec.UseTls == nil {
			break
		}

		return e.complexity.StaticUpstreamSpec.UseTls(childComplexity), true

	case "Status.state":
		if e.complexity.Status.State == nil {
			break
		}

		return e.complexity.Status.State(childComplexity), true

	case "Status.reason":
		if e.complexity.Status.Reason == nil {
			break
		}

		return e.complexity.Status.Reason(childComplexity), true

	case "Subscription.upstreams":
		if e.complexity.Subscription.Upstreams == nil {
			break
		}

		args, err := field_Subscription_upstreams_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.Upstreams(childComplexity, args["namespace"].(string), args["selector"].(*models.InputMapStringString)), true

	case "Subscription.virtualServices":
		if e.complexity.Subscription.VirtualServices == nil {
			break
		}

		args, err := field_Subscription_virtualServices_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.VirtualServices(childComplexity, args["namespace"].(string), args["selector"].(*models.InputMapStringString)), true

	case "TlsSecret.certChain":
		if e.complexity.TlsSecret.CertChain == nil {
			break
		}

		return e.complexity.TlsSecret.CertChain(childComplexity), true

	case "TlsSecret.privateKey":
		if e.complexity.TlsSecret.PrivateKey == nil {
			break
		}

		return e.complexity.TlsSecret.PrivateKey(childComplexity), true

	case "TlsSecret.rootCa":
		if e.complexity.TlsSecret.RootCa == nil {
			break
		}

		return e.complexity.TlsSecret.RootCa(childComplexity), true

	case "Transformation.functionName":
		if e.complexity.Transformation.FunctionName == nil {
			break
		}

		return e.complexity.Transformation.FunctionName(childComplexity), true

	case "Transformation.body":
		if e.complexity.Transformation.Body == nil {
			break
		}

		return e.complexity.Transformation.Body(childComplexity), true

	case "Transformation.headers":
		if e.complexity.Transformation.Headers == nil {
			break
		}

		return e.complexity.Transformation.Headers(childComplexity), true

	case "TransformationParameters.headers":
		if e.complexity.TransformationParameters.Headers == nil {
			break
		}

		return e.complexity.TransformationParameters.Headers(childComplexity), true

	case "TransformationParameters.path":
		if e.complexity.TransformationParameters.Path == nil {
			break
		}

		return e.complexity.TransformationParameters.Path(childComplexity), true

	case "Upstream.spec":
		if e.complexity.Upstream.Spec == nil {
			break
		}

		return e.complexity.Upstream.Spec(childComplexity), true

	case "Upstream.metadata":
		if e.complexity.Upstream.Metadata == nil {
			break
		}

		return e.complexity.Upstream.Metadata(childComplexity), true

	case "Upstream.status":
		if e.complexity.Upstream.Status == nil {
			break
		}

		return e.complexity.Upstream.Status(childComplexity), true

	case "UpstreamMutation.create":
		if e.complexity.UpstreamMutation.Create == nil {
			break
		}

		args, err := field_UpstreamMutation_create_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpstreamMutation.Create(childComplexity, args["upstream"].(models.InputUpstream)), true

	case "UpstreamMutation.update":
		if e.complexity.UpstreamMutation.Update == nil {
			break
		}

		args, err := field_UpstreamMutation_update_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpstreamMutation.Update(childComplexity, args["upstream"].(models.InputUpstream)), true

	case "UpstreamMutation.delete":
		if e.complexity.UpstreamMutation.Delete == nil {
			break
		}

		args, err := field_UpstreamMutation_delete_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpstreamMutation.Delete(childComplexity, args["guid"].(string)), true

	case "Value.key":
		if e.complexity.Value.Key == nil {
			break
		}

		return e.complexity.Value.Key(childComplexity), true

	case "Value.value":
		if e.complexity.Value.Value == nil {
			break
		}

		return e.complexity.Value.Value(childComplexity), true

	case "VirtualService.metadata":
		if e.complexity.VirtualService.Metadata == nil {
			break
		}

		return e.complexity.VirtualService.Metadata(childComplexity), true

	case "VirtualService.status":
		if e.complexity.VirtualService.Status == nil {
			break
		}

		return e.complexity.VirtualService.Status(childComplexity), true

	case "VirtualService.domains":
		if e.complexity.VirtualService.Domains == nil {
			break
		}

		return e.complexity.VirtualService.Domains(childComplexity), true

	case "VirtualService.routes":
		if e.complexity.VirtualService.Routes == nil {
			break
		}

		return e.complexity.VirtualService.Routes(childComplexity), true

	case "VirtualService.sslConfig":
		if e.complexity.VirtualService.SslConfig == nil {
			break
		}

		return e.complexity.VirtualService.SslConfig(childComplexity), true

	case "VirtualService.rateLimitConfig":
		if e.complexity.VirtualService.RateLimitConfig == nil {
			break
		}

		return e.complexity.VirtualService.RateLimitConfig(childComplexity), true

	case "VirtualService.plugins":
		if e.complexity.VirtualService.Plugins == nil {
			break
		}

		return e.complexity.VirtualService.Plugins(childComplexity), true

	case "VirtualServiceMutation.create":
		if e.complexity.VirtualServiceMutation.Create == nil {
			break
		}

		args, err := field_VirtualServiceMutation_create_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VirtualServiceMutation.Create(childComplexity, args["virtualService"].(models.InputVirtualService)), true

	case "VirtualServiceMutation.update":
		if e.complexity.VirtualServiceMutation.Update == nil {
			break
		}

		args, err := field_VirtualServiceMutation_update_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VirtualServiceMutation.Update(childComplexity, args["virtualServiceId"].(string), args["resourceVersion"].(string), args["updates"].(models.InputUpdateVirtualService)), true

	case "VirtualServiceMutation.delete":
		if e.complexity.VirtualServiceMutation.Delete == nil {
			break
		}

		args, err := field_VirtualServiceMutation_delete_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VirtualServiceMutation.Delete(childComplexity, args["guid"].(string)), true

	case "VirtualServiceMutation.addRoute":
		if e.complexity.VirtualServiceMutation.AddRoute == nil {
			break
		}

		args, err := field_VirtualServiceMutation_addRoute_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VirtualServiceMutation.AddRoute(childComplexity, args["virtualServiceId"].(string), args["resourceVersion"].(string), args["index"].(int), args["route"].(models.InputRoute)), true

	case "VirtualServiceMutation.updateRoute":
		if e.complexity.VirtualServiceMutation.UpdateRoute == nil {
			break
		}

		args, err := field_VirtualServiceMutation_updateRoute_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VirtualServiceMutation.UpdateRoute(childComplexity, args["virtualServiceId"].(string), args["resourceVersion"].(string), args["index"].(int), args["route"].(models.InputRoute)), true

	case "VirtualServiceMutation.deleteRoute":
		if e.complexity.VirtualServiceMutation.DeleteRoute == nil {
			break
		}

		args, err := field_VirtualServiceMutation_deleteRoute_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VirtualServiceMutation.DeleteRoute(childComplexity, args["virtualServiceId"].(string), args["resourceVersion"].(string), args["index"].(int)), true

	case "VirtualServiceMutation.swapRoutes":
		if e.complexity.VirtualServiceMutation.SwapRoutes == nil {
			break
		}

		args, err := field_VirtualServiceMutation_swapRoutes_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VirtualServiceMutation.SwapRoutes(childComplexity, args["virtualServiceId"].(string), args["resourceVersion"].(string), args["index1"].(int), args["index2"].(int)), true

	case "VirtualServiceMutation.shiftRoutes":
		if e.complexity.VirtualServiceMutation.ShiftRoutes == nil {
			break
		}

		args, err := field_VirtualServiceMutation_shiftRoutes_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VirtualServiceMutation.ShiftRoutes(childComplexity, args["virtualServiceId"].(string), args["resourceVersion"].(string), args["fromIndex"].(int), args["toIndex"].(int)), true

	case "VirtualServicePlugins.empty":
		if e.complexity.VirtualServicePlugins.Empty == nil {
			break
		}

		return e.complexity.VirtualServicePlugins.Empty(childComplexity), true

	case "WeightedDestination.destination":
		if e.complexity.WeightedDestination.Destination == nil {
			break
		}

		return e.complexity.WeightedDestination.Destination(childComplexity), true

	case "WeightedDestination.weight":
		if e.complexity.WeightedDestination.Weight == nil {
			break
		}

		return e.complexity.WeightedDestination.Weight(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Query(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Query(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions}
}

func (e *executableSchema) Mutation(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Mutation(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions,
	}
}

func (e *executableSchema) Subscription(ctx context.Context, op *ast.OperationDefinition) func() *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	next := ec._Subscription(ctx, op.SelectionSet)
	if ec.Errors != nil {
		return graphql.OneShot(&graphql.Response{Data: []byte("null"), Errors: ec.Errors})
	}

	var buf bytes.Buffer
	return func() *graphql.Response {
		buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
			buf.Reset()
			data := next()

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)
			return buf.Bytes()
		})

		if buf == nil {
			return nil
		}

		return &graphql.Response{
			Data:       buf,
			Errors:     ec.Errors,
			Extensions: ec.Extensions,
		}
	}
}

type executionContext struct {
	*graphql.RequestContext
	*executableSchema
}

var artifactImplementors = []string{"Artifact"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Artifact(ctx context.Context, sel ast.SelectionSet, obj *models.Artifact) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, artifactImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Artifact")
		case "data":
			out.Values[i] = ec._Artifact_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "metadata":
			out.Values[i] = ec._Artifact_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Artifact_data(ctx context.Context, field graphql.CollectedField, obj *models.Artifact) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Artifact",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Artifact_metadata(ctx context.Context, field graphql.CollectedField, obj *models.Artifact) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Artifact",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Metadata)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Metadata(ctx, field.Selections, &res)
}

var artifactMutationImplementors = []string{"ArtifactMutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ArtifactMutation(ctx context.Context, sel ast.SelectionSet, obj *customtypes.ArtifactMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, artifactMutationImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ArtifactMutation")
		case "create":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ArtifactMutation_create(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "update":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ArtifactMutation_update(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "delete":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ArtifactMutation_delete(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ArtifactMutation_create(ctx context.Context, field graphql.CollectedField, obj *customtypes.ArtifactMutation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_ArtifactMutation_create_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "ArtifactMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ArtifactMutation().Create(rctx, obj, args["artifact"].(models.InputArtifact))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Artifact)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Artifact(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _ArtifactMutation_update(ctx context.Context, field graphql.CollectedField, obj *customtypes.ArtifactMutation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_ArtifactMutation_update_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "ArtifactMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ArtifactMutation().Update(rctx, obj, args["artifact"].(models.InputArtifact))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Artifact)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Artifact(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _ArtifactMutation_delete(ctx context.Context, field graphql.CollectedField, obj *customtypes.ArtifactMutation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_ArtifactMutation_delete_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "ArtifactMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ArtifactMutation().Delete(rctx, obj, args["guid"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Artifact)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Artifact(ctx, field.Selections, res)
}

var awsDestinationSpecImplementors = []string{"AwsDestinationSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AwsDestinationSpec(ctx context.Context, sel ast.SelectionSet, obj *models.AwsDestinationSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, awsDestinationSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AwsDestinationSpec")
		case "logicalName":
			out.Values[i] = ec._AwsDestinationSpec_logicalName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "invocationStyle":
			out.Values[i] = ec._AwsDestinationSpec_invocationStyle(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "responseTransformation":
			out.Values[i] = ec._AwsDestinationSpec_responseTransformation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AwsDestinationSpec_logicalName(ctx context.Context, field graphql.CollectedField, obj *models.AwsDestinationSpec) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AwsDestinationSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LogicalName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AwsDestinationSpec_invocationStyle(ctx context.Context, field graphql.CollectedField, obj *models.AwsDestinationSpec) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AwsDestinationSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InvocationStyle, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.AwsLambdaInvocationStyle)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _AwsDestinationSpec_responseTransformation(ctx context.Context, field graphql.CollectedField, obj *models.AwsDestinationSpec) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AwsDestinationSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResponseTransformation, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

var awsLambdaFunctionImplementors = []string{"AwsLambdaFunction"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AwsLambdaFunction(ctx context.Context, sel ast.SelectionSet, obj *models.AwsLambdaFunction) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, awsLambdaFunctionImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AwsLambdaFunction")
		case "logicalName":
			out.Values[i] = ec._AwsLambdaFunction_logicalName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "functionName":
			out.Values[i] = ec._AwsLambdaFunction_functionName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "qualifier":
			out.Values[i] = ec._AwsLambdaFunction_qualifier(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AwsLambdaFunction_logicalName(ctx context.Context, field graphql.CollectedField, obj *models.AwsLambdaFunction) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AwsLambdaFunction",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LogicalName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AwsLambdaFunction_functionName(ctx context.Context, field graphql.CollectedField, obj *models.AwsLambdaFunction) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AwsLambdaFunction",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FunctionName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AwsLambdaFunction_qualifier(ctx context.Context, field graphql.CollectedField, obj *models.AwsLambdaFunction) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AwsLambdaFunction",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Qualifier, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var awsSecretImplementors = []string{"AwsSecret"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AwsSecret(ctx context.Context, sel ast.SelectionSet, obj *models.AwsSecret) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, awsSecretImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AwsSecret")
		case "accessKey":
			out.Values[i] = ec._AwsSecret_accessKey(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "secretKey":
			out.Values[i] = ec._AwsSecret_secretKey(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AwsSecret_accessKey(ctx context.Context, field graphql.CollectedField, obj *models.AwsSecret) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AwsSecret",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccessKey, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AwsSecret_secretKey(ctx context.Context, field graphql.CollectedField, obj *models.AwsSecret) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AwsSecret",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SecretKey, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var awsUpstreamSpecImplementors = []string{"AwsUpstreamSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AwsUpstreamSpec(ctx context.Context, sel ast.SelectionSet, obj *models.AwsUpstreamSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, awsUpstreamSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AwsUpstreamSpec")
		case "region":
			out.Values[i] = ec._AwsUpstreamSpec_region(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "secretRef":
			out.Values[i] = ec._AwsUpstreamSpec_secretRef(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "functions":
			out.Values[i] = ec._AwsUpstreamSpec_functions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AwsUpstreamSpec_region(ctx context.Context, field graphql.CollectedField, obj *models.AwsUpstreamSpec) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AwsUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Region, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AwsUpstreamSpec_secretRef(ctx context.Context, field graphql.CollectedField, obj *models.AwsUpstreamSpec) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AwsUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SecretRef, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.ResourceRef)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ResourceRef(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _AwsUpstreamSpec_functions(ctx context.Context, field graphql.CollectedField, obj *models.AwsUpstreamSpec) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AwsUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Functions, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.AwsLambdaFunction)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._AwsLambdaFunction(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var azureDestinationSpecImplementors = []string{"AzureDestinationSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AzureDestinationSpec(ctx context.Context, sel ast.SelectionSet, obj *models.AzureDestinationSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, azureDestinationSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AzureDestinationSpec")
		case "functionName":
			out.Values[i] = ec._AzureDestinationSpec_functionName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AzureDestinationSpec_functionName(ctx context.Context, field graphql.CollectedField, obj *models.AzureDestinationSpec) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AzureDestinationSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FunctionName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var azureFunctionImplementors = []string{"AzureFunction"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AzureFunction(ctx context.Context, sel ast.SelectionSet, obj *models.AzureFunction) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, azureFunctionImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AzureFunction")
		case "functionName":
			out.Values[i] = ec._AzureFunction_functionName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "authLevel":
			out.Values[i] = ec._AzureFunction_authLevel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AzureFunction_functionName(ctx context.Context, field graphql.CollectedField, obj *models.AzureFunction) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AzureFunction",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FunctionName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AzureFunction_authLevel(ctx context.Context, field graphql.CollectedField, obj *models.AzureFunction) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AzureFunction",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthLevel, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.AzureFnAuthLevel)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

var azureSecretImplementors = []string{"AzureSecret"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AzureSecret(ctx context.Context, sel ast.SelectionSet, obj *models.AzureSecret) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, azureSecretImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AzureSecret")
		case "apiKeys":
			out.Values[i] = ec._AzureSecret_apiKeys(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AzureSecret_apiKeys(ctx context.Context, field graphql.CollectedField, obj *models.AzureSecret) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AzureSecret",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIKeys, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.MapStringString)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._MapStringString(ctx, field.Selections, res)
}

var azureUpstreamSpecImplementors = []string{"AzureUpstreamSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AzureUpstreamSpec(ctx context.Context, sel ast.SelectionSet, obj *models.AzureUpstreamSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, azureUpstreamSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AzureUpstreamSpec")
		case "functionAppName":
			out.Values[i] = ec._AzureUpstreamSpec_functionAppName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "secretRef":
			out.Values[i] = ec._AzureUpstreamSpec_secretRef(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "functions":
			out.Values[i] = ec._AzureUpstreamSpec_functions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AzureUpstreamSpec_functionAppName(ctx context.Context, field graphql.CollectedField, obj *models.AzureUpstreamSpec) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AzureUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FunctionAppName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AzureUpstreamSpec_secretRef(ctx context.Context, field graphql.CollectedField, obj *models.AzureUpstreamSpec) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AzureUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SecretRef, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.ResourceRef)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ResourceRef(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _AzureUpstreamSpec_functions(ctx context.Context, field graphql.CollectedField, obj *models.AzureUpstreamSpec) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AzureUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Functions, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.AzureFunction)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._AzureFunction(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var grpcDestinationSpecImplementors = []string{"GrpcDestinationSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _GrpcDestinationSpec(ctx context.Context, sel ast.SelectionSet, obj *models.GrpcDestinationSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, grpcDestinationSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GrpcDestinationSpec")
		case "package":
			out.Values[i] = ec._GrpcDestinationSpec_package(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "service":
			out.Values[i] = ec._GrpcDestinationSpec_service(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "function":
			out.Values[i] = ec._GrpcDestinationSpec_function(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "parameters":
			out.Values[i] = ec._GrpcDestinationSpec_parameters(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _GrpcDestinationSpec_package(ctx context.Context, field graphql.CollectedField, obj *models.GrpcDestinationSpec) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "GrpcDestinationSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Package, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _GrpcDestinationSpec_service(ctx context.Context, field graphql.CollectedField, obj *models.GrpcDestinationSpec) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "GrpcDestinationSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Service, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _GrpcDestinationSpec_function(ctx context.Context, field graphql.CollectedField, obj *models.GrpcDestinationSpec) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "GrpcDestinationSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Function, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _GrpcDestinationSpec_parameters(ctx context.Context, field graphql.CollectedField, obj *models.GrpcDestinationSpec) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "GrpcDestinationSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parameters, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.TransformationParameters)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._TransformationParameters(ctx, field.Selections, res)
}

var grpcServiceImplementors = []string{"GrpcService"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _GrpcService(ctx context.Context, sel ast.SelectionSet, obj *models.GrpcService) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, grpcServiceImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GrpcService")
		case "packageName":
			out.Values[i] = ec._GrpcService_packageName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "serviceName":
			out.Values[i] = ec._GrpcService_serviceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "functionNames":
			out.Values[i] = ec._GrpcService_functionNames(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _GrpcService_packageName(ctx context.Context, field graphql.CollectedField, obj *models.GrpcService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "GrpcService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PackageName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _GrpcService_serviceName(ctx context.Context, field graphql.CollectedField, obj *models.GrpcService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "GrpcService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _GrpcService_functionNames(ctx context.Context, field graphql.CollectedField, obj *models.GrpcService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "GrpcService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FunctionNames, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

var grpcServiceSpecImplementors = []string{"GrpcServiceSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _GrpcServiceSpec(ctx context.Context, sel ast.SelectionSet, obj *models.GrpcServiceSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, grpcServiceSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GrpcServiceSpec")
		case "grpcServices":
			out.Values[i] = ec._GrpcServiceSpec_grpcServices(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _GrpcServiceSpec_grpcServices(ctx context.Context, field graphql.CollectedField, obj *models.GrpcServiceSpec) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "GrpcServiceSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GrpcServices, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.GrpcService)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				if res[idx1] == nil {
					return graphql.Null
				}

				return ec._GrpcService(ctx, field.Selections, res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var keyValueMatcherImplementors = []string{"KeyValueMatcher"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _KeyValueMatcher(ctx context.Context, sel ast.SelectionSet, obj *models.KeyValueMatcher) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, keyValueMatcherImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KeyValueMatcher")
		case "name":
			out.Values[i] = ec._KeyValueMatcher_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "value":
			out.Values[i] = ec._KeyValueMatcher_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "isRegex":
			out.Values[i] = ec._KeyValueMatcher_isRegex(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _KeyValueMatcher_name(ctx context.Context, field graphql.CollectedField, obj *models.KeyValueMatcher) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "KeyValueMatcher",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _KeyValueMatcher_value(ctx context.Context, field graphql.CollectedField, obj *models.KeyValueMatcher) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "KeyValueMatcher",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _KeyValueMatcher_isRegex(ctx context.Context, field graphql.CollectedField, obj *models.KeyValueMatcher) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "KeyValueMatcher",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRegex, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

var kubeUpstreamSpecImplementors = []string{"KubeUpstreamSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _KubeUpstreamSpec(ctx context.Context, sel ast.SelectionSet, obj *models.KubeUpstreamSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, kubeUpstreamSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KubeUpstreamSpec")
		case "serviceName":
			out.Values[i] = ec._KubeUpstreamSpec_serviceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "serviceNamespace":
			out.Values[i] = ec._KubeUpstreamSpec_serviceNamespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "servicePort":
			out.Values[i] = ec._KubeUpstreamSpec_servicePort(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "selector":
			out.Values[i] = ec._KubeUpstreamSpec_selector(ctx, field, obj)
		case "serviceSpec":
			out.Values[i] = ec._KubeUpstreamSpec_serviceSpec(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _KubeUpstreamSpec_serviceName(ctx context.Context, field graphql.CollectedField, obj *models.KubeUpstreamSpec) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "KubeUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _KubeUpstreamSpec_serviceNamespace(ctx context.Context, field graphql.CollectedField, obj *models.KubeUpstreamSpec) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "KubeUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceNamespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _KubeUpstreamSpec_servicePort(ctx context.Context, field graphql.CollectedField, obj *models.KubeUpstreamSpec) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "KubeUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServicePort, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _KubeUpstreamSpec_selector(ctx context.Context, field graphql.CollectedField, obj *models.KubeUpstreamSpec) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "KubeUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Selector, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.MapStringString)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._MapStringString(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _KubeUpstreamSpec_serviceSpec(ctx context.Context, field graphql.CollectedField, obj *models.KubeUpstreamSpec) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "KubeUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceSpec, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.ServiceSpec)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ServiceSpec(ctx, field.Selections, &res)
}

var mapStringStringImplementors = []string{"MapStringString"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _MapStringString(ctx context.Context, sel ast.SelectionSet, obj *models.MapStringString) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, mapStringStringImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MapStringString")
		case "values":
			out.Values[i] = ec._MapStringString_values(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _MapStringString_values(ctx context.Context, field graphql.CollectedField, obj *models.MapStringString) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "MapStringString",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Values, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.Value)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Value(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var matcherImplementors = []string{"Matcher"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Matcher(ctx context.Context, sel ast.SelectionSet, obj *models.Matcher) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, matcherImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Matcher")
		case "pathMatch":
			out.Values[i] = ec._Matcher_pathMatch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "pathMatchType":
			out.Values[i] = ec._Matcher_pathMatchType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "headers":
			out.Values[i] = ec._Matcher_headers(ctx, field, obj)
		case "queryParameters":
			out.Values[i] = ec._Matcher_queryParameters(ctx, field, obj)
		case "methods":
			out.Values[i] = ec._Matcher_methods(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Matcher_pathMatch(ctx context.Context, field graphql.CollectedField, obj *models.Matcher) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Matcher",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PathMatch, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Matcher_pathMatchType(ctx context.Context, field graphql.CollectedField, obj *models.Matcher) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Matcher",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PathMatchType, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.PathMatchType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _Matcher_headers(ctx context.Context, field graphql.CollectedField, obj *models.Matcher) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Matcher",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Headers, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.KeyValueMatcher)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._KeyValueMatcher(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Matcher_queryParameters(ctx context.Context, field graphql.CollectedField, obj *models.Matcher) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Matcher",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryParameters, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.KeyValueMatcher)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._KeyValueMatcher(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Matcher_methods(ctx context.Context, field graphql.CollectedField, obj *models.Matcher) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Matcher",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Methods, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

var metadataImplementors = []string{"Metadata"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Metadata(ctx context.Context, sel ast.SelectionSet, obj *models.Metadata) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, metadataImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Metadata")
		case "name":
			out.Values[i] = ec._Metadata_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._Metadata_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "resourceVersion":
			out.Values[i] = ec._Metadata_resourceVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "labels":
			out.Values[i] = ec._Metadata_labels(ctx, field, obj)
		case "annotations":
			out.Values[i] = ec._Metadata_annotations(ctx, field, obj)
		case "guid":
			out.Values[i] = ec._Metadata_guid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Metadata_name(ctx context.Context, field graphql.CollectedField, obj *models.Metadata) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Metadata",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Metadata_namespace(ctx context.Context, field graphql.CollectedField, obj *models.Metadata) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Metadata",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Metadata_resourceVersion(ctx context.Context, field graphql.CollectedField, obj *models.Metadata) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Metadata",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceVersion, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Metadata_labels(ctx context.Context, field graphql.CollectedField, obj *models.Metadata) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Metadata",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.MapStringString)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._MapStringString(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Metadata_annotations(ctx context.Context, field graphql.CollectedField, obj *models.Metadata) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Metadata",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotations, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.MapStringString)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._MapStringString(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Metadata_guid(ctx context.Context, field graphql.CollectedField, obj *models.Metadata) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Metadata",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GUID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var multiDestinationImplementors = []string{"MultiDestination"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _MultiDestination(ctx context.Context, sel ast.SelectionSet, obj *models.MultiDestination) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, multiDestinationImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MultiDestination")
		case "destinations":
			out.Values[i] = ec._MultiDestination_destinations(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _MultiDestination_destinations(ctx context.Context, field graphql.CollectedField, obj *models.MultiDestination) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "MultiDestination",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Destinations, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.WeightedDestination)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._WeightedDestination(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var mutationImplementors = []string{"Mutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, mutationImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Mutation",
	})

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "upstreams":
			out.Values[i] = ec._Mutation_upstreams(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "virtualServices":
			out.Values[i] = ec._Mutation_virtualServices(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "secrets":
			out.Values[i] = ec._Mutation_secrets(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "artifacts":
			out.Values[i] = ec._Mutation_artifacts(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "settings":
			out.Values[i] = ec._Mutation_settings(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_upstreams(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Upstreams(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(customtypes.UpstreamMutation)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._UpstreamMutation(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_virtualServices(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().VirtualServices(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(customtypes.VirtualServiceMutation)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._VirtualServiceMutation(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_secrets(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Secrets(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(customtypes.SecretMutation)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._SecretMutation(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_artifacts(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Artifacts(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(customtypes.ArtifactMutation)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ArtifactMutation(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_settings(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Settings(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(customtypes.SettingsMutation)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._SettingsMutation(ctx, field.Selections, &res)
}

var namespaceImplementors = []string{"Namespace"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Namespace(ctx context.Context, sel ast.SelectionSet, obj *customtypes.Namespace) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, namespaceImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Namespace")
		case "name":
			out.Values[i] = ec._Namespace_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "upstreams":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Namespace_upstreams(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "upstream":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Namespace_upstream(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "virtualServices":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Namespace_virtualServices(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "virtualService":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Namespace_virtualService(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "secrets":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Namespace_secrets(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "secret":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Namespace_secret(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "artifacts":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Namespace_artifacts(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "artifact":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Namespace_artifact(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Namespace_name(ctx context.Context, field graphql.CollectedField, obj *customtypes.Namespace) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Namespace",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Namespace_upstreams(ctx context.Context, field graphql.CollectedField, obj *customtypes.Namespace) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Namespace",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Namespace().Upstreams(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Upstream)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				if res[idx1] == nil {
					return graphql.Null
				}

				return ec._Upstream(ctx, field.Selections, res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Namespace_upstream(ctx context.Context, field graphql.CollectedField, obj *customtypes.Namespace) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Namespace_upstream_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Namespace",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Namespace().Upstream(rctx, obj, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Upstream)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Upstream(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Namespace_virtualServices(ctx context.Context, field graphql.CollectedField, obj *customtypes.Namespace) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Namespace",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Namespace().VirtualServices(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.VirtualService)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				if res[idx1] == nil {
					return graphql.Null
				}

				return ec._VirtualService(ctx, field.Selections, res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Namespace_virtualService(ctx context.Context, field graphql.CollectedField, obj *customtypes.Namespace) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Namespace_virtualService_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Namespace",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Namespace().VirtualService(rctx, obj, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.VirtualService)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._VirtualService(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Namespace_secrets(ctx context.Context, field graphql.CollectedField, obj *customtypes.Namespace) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Namespace",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Namespace().Secrets(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Secret)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				if res[idx1] == nil {
					return graphql.Null
				}

				return ec._Secret(ctx, field.Selections, res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Namespace_secret(ctx context.Context, field graphql.CollectedField, obj *customtypes.Namespace) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Namespace_secret_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Namespace",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Namespace().Secret(rctx, obj, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Secret)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Secret(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Namespace_artifacts(ctx context.Context, field graphql.CollectedField, obj *customtypes.Namespace) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Namespace",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Namespace().Artifacts(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Artifact)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				if res[idx1] == nil {
					return graphql.Null
				}

				return ec._Artifact(ctx, field.Selections, res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Namespace_artifact(ctx context.Context, field graphql.CollectedField, obj *customtypes.Namespace) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Namespace_artifact_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Namespace",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Namespace().Artifact(rctx, obj, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Artifact)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Artifact(ctx, field.Selections, res)
}

var oAuthEndpointImplementors = []string{"OAuthEndpoint"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _OAuthEndpoint(ctx context.Context, sel ast.SelectionSet, obj *models.OAuthEndpoint) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, oAuthEndpointImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OAuthEndpoint")
		case "url":
			out.Values[i] = ec._OAuthEndpoint_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "clientName":
			out.Values[i] = ec._OAuthEndpoint_clientName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _OAuthEndpoint_url(ctx context.Context, field graphql.CollectedField, obj *models.OAuthEndpoint) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "OAuthEndpoint",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _OAuthEndpoint_clientName(ctx context.Context, field graphql.CollectedField, obj *models.OAuthEndpoint) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "OAuthEndpoint",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var queryImplementors = []string{"Query"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, queryImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
	})

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "version":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_version(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "getOAuthEndpoint":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_getOAuthEndpoint(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "allNamespaces":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_allNamespaces(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "namespace":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_namespace(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "settings":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_settings(ctx, field)
				wg.Done()
			}(i, field)
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Query_version(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Version(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_getOAuthEndpoint(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetOAuthEndpoint(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.OAuthEndpoint)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._OAuthEndpoint(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_allNamespaces(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AllNamespaces(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]customtypes.Namespace)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Namespace(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_namespace(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_namespace_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Namespace(rctx, args["name"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(customtypes.Namespace)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Namespace(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_settings(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Settings(rctx)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Settings)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Settings(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query___type_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Schema(ctx, field.Selections, res)
}

var rateLimitImplementors = []string{"RateLimit"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _RateLimit(ctx context.Context, sel ast.SelectionSet, obj *models.RateLimit) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, rateLimitImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RateLimit")
		case "unit":
			out.Values[i] = ec._RateLimit_unit(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "requestsPerUnit":
			out.Values[i] = ec._RateLimit_requestsPerUnit(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _RateLimit_unit(ctx context.Context, field graphql.CollectedField, obj *models.RateLimit) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "RateLimit",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unit, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.TimeUnit)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _RateLimit_requestsPerUnit(ctx context.Context, field graphql.CollectedField, obj *models.RateLimit) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "RateLimit",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestsPerUnit, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(customtypes.UnsignedInt)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

var rateLimitConfigImplementors = []string{"RateLimitConfig"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _RateLimitConfig(ctx context.Context, sel ast.SelectionSet, obj *models.RateLimitConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, rateLimitConfigImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RateLimitConfig")
		case "authorizedLimits":
			out.Values[i] = ec._RateLimitConfig_authorizedLimits(ctx, field, obj)
		case "anonymousLimits":
			out.Values[i] = ec._RateLimitConfig_anonymousLimits(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _RateLimitConfig_authorizedLimits(ctx context.Context, field graphql.CollectedField, obj *models.RateLimitConfig) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "RateLimitConfig",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthorizedLimits, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.RateLimit)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._RateLimit(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _RateLimitConfig_anonymousLimits(ctx context.Context, field graphql.CollectedField, obj *models.RateLimitConfig) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "RateLimitConfig",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AnonymousLimits, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.RateLimit)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._RateLimit(ctx, field.Selections, res)
}

var resourceRefImplementors = []string{"ResourceRef"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ResourceRef(ctx context.Context, sel ast.SelectionSet, obj *models.ResourceRef) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, resourceRefImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceRef")
		case "name":
			out.Values[i] = ec._ResourceRef_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._ResourceRef_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ResourceRef_name(ctx context.Context, field graphql.CollectedField, obj *models.ResourceRef) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ResourceRef",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ResourceRef_namespace(ctx context.Context, field graphql.CollectedField, obj *models.ResourceRef) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ResourceRef",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var restDestinationSpecImplementors = []string{"RestDestinationSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _RestDestinationSpec(ctx context.Context, sel ast.SelectionSet, obj *models.RestDestinationSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, restDestinationSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RestDestinationSpec")
		case "functionName":
			out.Values[i] = ec._RestDestinationSpec_functionName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "parameters":
			out.Values[i] = ec._RestDestinationSpec_parameters(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _RestDestinationSpec_functionName(ctx context.Context, field graphql.CollectedField, obj *models.RestDestinationSpec) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "RestDestinationSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FunctionName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _RestDestinationSpec_parameters(ctx context.Context, field graphql.CollectedField, obj *models.RestDestinationSpec) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "RestDestinationSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parameters, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.TransformationParameters)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._TransformationParameters(ctx, field.Selections, res)
}

var restServiceSpecImplementors = []string{"RestServiceSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _RestServiceSpec(ctx context.Context, sel ast.SelectionSet, obj *models.RestServiceSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, restServiceSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RestServiceSpec")
		case "functions":
			out.Values[i] = ec._RestServiceSpec_functions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _RestServiceSpec_functions(ctx context.Context, field graphql.CollectedField, obj *models.RestServiceSpec) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "RestServiceSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Functions, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.Transformation)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Transformation(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var routeImplementors = []string{"Route"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Route(ctx context.Context, sel ast.SelectionSet, obj *models.Route) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, routeImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Route")
		case "matcher":
			out.Values[i] = ec._Route_matcher(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "destination":
			out.Values[i] = ec._Route_destination(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "plugins":
			out.Values[i] = ec._Route_plugins(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Route_matcher(ctx context.Context, field graphql.CollectedField, obj *models.Route) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Route",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Matcher, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Matcher)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Matcher(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Route_destination(ctx context.Context, field graphql.CollectedField, obj *models.Route) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Route",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Destination, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Destination)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Destination(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Route_plugins(ctx context.Context, field graphql.CollectedField, obj *models.Route) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Route",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Plugins, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.RoutePlugins)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._RoutePlugins(ctx, field.Selections, res)
}

var routePluginsImplementors = []string{"RoutePlugins"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _RoutePlugins(ctx context.Context, sel ast.SelectionSet, obj *models.RoutePlugins) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, routePluginsImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RoutePlugins")
		case "empty":
			out.Values[i] = ec._RoutePlugins_empty(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _RoutePlugins_empty(ctx context.Context, field graphql.CollectedField, obj *models.RoutePlugins) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "RoutePlugins",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Empty, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var secretImplementors = []string{"Secret"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Secret(ctx context.Context, sel ast.SelectionSet, obj *models.Secret) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, secretImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Secret")
		case "kind":
			out.Values[i] = ec._Secret_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "metadata":
			out.Values[i] = ec._Secret_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Secret_kind(ctx context.Context, field graphql.CollectedField, obj *models.Secret) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Secret",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.SecretKind)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._SecretKind(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Secret_metadata(ctx context.Context, field graphql.CollectedField, obj *models.Secret) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Secret",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Metadata)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Metadata(ctx, field.Selections, &res)
}

var secretMutationImplementors = []string{"SecretMutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SecretMutation(ctx context.Context, sel ast.SelectionSet, obj *customtypes.SecretMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, secretMutationImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SecretMutation")
		case "create":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._SecretMutation_create(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "update":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._SecretMutation_update(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "delete":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._SecretMutation_delete(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _SecretMutation_create(ctx context.Context, field graphql.CollectedField, obj *customtypes.SecretMutation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_SecretMutation_create_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "SecretMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SecretMutation().Create(rctx, obj, args["secret"].(models.InputSecret))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Secret)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Secret(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _SecretMutation_update(ctx context.Context, field graphql.CollectedField, obj *customtypes.SecretMutation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_SecretMutation_update_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "SecretMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SecretMutation().Update(rctx, obj, args["secret"].(models.InputSecret))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Secret)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Secret(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _SecretMutation_delete(ctx context.Context, field graphql.CollectedField, obj *customtypes.SecretMutation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_SecretMutation_delete_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "SecretMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SecretMutation().Delete(rctx, obj, args["guid"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Secret)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Secret(ctx, field.Selections, res)
}

var settingsImplementors = []string{"Settings"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Settings(ctx context.Context, sel ast.SelectionSet, obj *models.Settings) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, settingsImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Settings")
		case "watchNamespaces":
			out.Values[i] = ec._Settings_watchNamespaces(ctx, field, obj)
		case "refreshRate":
			out.Values[i] = ec._Settings_refreshRate(ctx, field, obj)
		case "metadata":
			out.Values[i] = ec._Settings_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Settings_watchNamespaces(ctx context.Context, field graphql.CollectedField, obj *models.Settings) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Settings",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WatchNamespaces, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Settings_refreshRate(ctx context.Context, field graphql.CollectedField, obj *models.Settings) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Settings",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RefreshRate, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*customtypes.Duration)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return *res
}

// nolint: vetshadow
func (ec *executionContext) _Settings_metadata(ctx context.Context, field graphql.CollectedField, obj *models.Settings) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Settings",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Metadata)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Metadata(ctx, field.Selections, &res)
}

var settingsMutationImplementors = []string{"SettingsMutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SettingsMutation(ctx context.Context, sel ast.SelectionSet, obj *customtypes.SettingsMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, settingsMutationImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SettingsMutation")
		case "update":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._SettingsMutation_update(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _SettingsMutation_update(ctx context.Context, field graphql.CollectedField, obj *customtypes.SettingsMutation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_SettingsMutation_update_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "SettingsMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SettingsMutation().Update(rctx, obj, args["settings"].(models.InputSettings))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Settings)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Settings(ctx, field.Selections, res)
}

var singleDestinationImplementors = []string{"SingleDestination"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SingleDestination(ctx context.Context, sel ast.SelectionSet, obj *models.SingleDestination) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, singleDestinationImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SingleDestination")
		case "upstream":
			out.Values[i] = ec._SingleDestination_upstream(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "destinationSpec":
			out.Values[i] = ec._SingleDestination_destinationSpec(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _SingleDestination_upstream(ctx context.Context, field graphql.CollectedField, obj *models.SingleDestination) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "SingleDestination",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Upstream, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Upstream)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Upstream(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _SingleDestination_destinationSpec(ctx context.Context, field graphql.CollectedField, obj *models.SingleDestination) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "SingleDestination",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DestinationSpec, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.DestinationSpec)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._DestinationSpec(ctx, field.Selections, &res)
}

var sslConfigImplementors = []string{"SslConfig"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SslConfig(ctx context.Context, sel ast.SelectionSet, obj *models.SslConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, sslConfigImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SslConfig")
		case "secretRef":
			out.Values[i] = ec._SslConfig_secretRef(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _SslConfig_secretRef(ctx context.Context, field graphql.CollectedField, obj *models.SslConfig) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "SslConfig",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SecretRef, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.ResourceRef)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ResourceRef(ctx, field.Selections, &res)
}

var staticHostImplementors = []string{"StaticHost"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _StaticHost(ctx context.Context, sel ast.SelectionSet, obj *models.StaticHost) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, staticHostImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StaticHost")
		case "addr":
			out.Values[i] = ec._StaticHost_addr(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "port":
			out.Values[i] = ec._StaticHost_port(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _StaticHost_addr(ctx context.Context, field graphql.CollectedField, obj *models.StaticHost) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StaticHost",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Addr, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _StaticHost_port(ctx context.Context, field graphql.CollectedField, obj *models.StaticHost) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StaticHost",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Port, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

var staticUpstreamSpecImplementors = []string{"StaticUpstreamSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _StaticUpstreamSpec(ctx context.Context, sel ast.SelectionSet, obj *models.StaticUpstreamSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, staticUpstreamSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StaticUpstreamSpec")
		case "hosts":
			out.Values[i] = ec._StaticUpstreamSpec_hosts(ctx, field, obj)
		case "serviceSpec":
			out.Values[i] = ec._StaticUpstreamSpec_serviceSpec(ctx, field, obj)
		case "useTls":
			out.Values[i] = ec._StaticUpstreamSpec_useTls(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _StaticUpstreamSpec_hosts(ctx context.Context, field graphql.CollectedField, obj *models.StaticUpstreamSpec) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StaticUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hosts, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.StaticHost)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._StaticHost(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _StaticUpstreamSpec_serviceSpec(ctx context.Context, field graphql.CollectedField, obj *models.StaticUpstreamSpec) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StaticUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceSpec, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.ServiceSpec)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ServiceSpec(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _StaticUpstreamSpec_useTls(ctx context.Context, field graphql.CollectedField, obj *models.StaticUpstreamSpec) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StaticUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UseTLS, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

var statusImplementors = []string{"Status"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Status(ctx context.Context, sel ast.SelectionSet, obj *models.Status) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, statusImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Status")
		case "state":
			out.Values[i] = ec._Status_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "reason":
			out.Values[i] = ec._Status_reason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Status_state(ctx context.Context, field graphql.CollectedField, obj *models.Status) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Status",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.State)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _Status_reason(ctx context.Context, field graphql.CollectedField, obj *models.Status) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Status",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var subscriptionImplementors = []string{"Subscription"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func() graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, subscriptionImplementors)
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "upstreams":
		return ec._Subscription_upstreams(ctx, fields[0])
	case "virtualServices":
		return ec._Subscription_virtualServices(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

func (ec *executionContext) _Subscription_upstreams(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Subscription_upstreams_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().Upstreams(rctx, args["namespace"].(string), args["selector"].(*models.InputMapStringString))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			arr1 := make(graphql.Array, len(res))
			var wg sync.WaitGroup

			isLen1 := len(res) == 1
			if !isLen1 {
				wg.Add(len(res))
			}

			for idx1 := range res {
				idx1 := idx1
				rctx := &graphql.ResolverContext{
					Index:  &idx1,
					Result: res[idx1],
				}
				ctx := graphql.WithResolverContext(ctx, rctx)
				f := func(idx1 int) {
					if !isLen1 {
						defer wg.Done()
					}
					arr1[idx1] = func() graphql.Marshaler {

						if res[idx1] == nil {
							return graphql.Null
						}

						return ec._Upstream(ctx, field.Selections, res[idx1])
					}()
				}
				if isLen1 {
					f(idx1)
				} else {
					go f(idx1)
				}

			}
			wg.Wait()
			return arr1
		}())
		return &out
	}
}

func (ec *executionContext) _Subscription_virtualServices(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Subscription_virtualServices_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().VirtualServices(rctx, args["namespace"].(string), args["selector"].(*models.InputMapStringString))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			arr1 := make(graphql.Array, len(res))
			var wg sync.WaitGroup

			isLen1 := len(res) == 1
			if !isLen1 {
				wg.Add(len(res))
			}

			for idx1 := range res {
				idx1 := idx1
				rctx := &graphql.ResolverContext{
					Index:  &idx1,
					Result: res[idx1],
				}
				ctx := graphql.WithResolverContext(ctx, rctx)
				f := func(idx1 int) {
					if !isLen1 {
						defer wg.Done()
					}
					arr1[idx1] = func() graphql.Marshaler {

						if res[idx1] == nil {
							return graphql.Null
						}

						return ec._VirtualService(ctx, field.Selections, res[idx1])
					}()
				}
				if isLen1 {
					f(idx1)
				} else {
					go f(idx1)
				}

			}
			wg.Wait()
			return arr1
		}())
		return &out
	}
}

var tlsSecretImplementors = []string{"TlsSecret"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _TlsSecret(ctx context.Context, sel ast.SelectionSet, obj *models.TlsSecret) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, tlsSecretImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TlsSecret")
		case "certChain":
			out.Values[i] = ec._TlsSecret_certChain(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "privateKey":
			out.Values[i] = ec._TlsSecret_privateKey(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "rootCa":
			out.Values[i] = ec._TlsSecret_rootCa(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _TlsSecret_certChain(ctx context.Context, field graphql.CollectedField, obj *models.TlsSecret) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "TlsSecret",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CertChain, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _TlsSecret_privateKey(ctx context.Context, field graphql.CollectedField, obj *models.TlsSecret) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "TlsSecret",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrivateKey, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _TlsSecret_rootCa(ctx context.Context, field graphql.CollectedField, obj *models.TlsSecret) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "TlsSecret",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RootCa, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var transformationImplementors = []string{"Transformation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Transformation(ctx context.Context, sel ast.SelectionSet, obj *models.Transformation) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, transformationImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Transformation")
		case "functionName":
			out.Values[i] = ec._Transformation_functionName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "body":
			out.Values[i] = ec._Transformation_body(ctx, field, obj)
		case "headers":
			out.Values[i] = ec._Transformation_headers(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Transformation_functionName(ctx context.Context, field graphql.CollectedField, obj *models.Transformation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Transformation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FunctionName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Transformation_body(ctx context.Context, field graphql.CollectedField, obj *models.Transformation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Transformation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Body, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Transformation_headers(ctx context.Context, field graphql.CollectedField, obj *models.Transformation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Transformation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Headers, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.MapStringString)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._MapStringString(ctx, field.Selections, res)
}

var transformationParametersImplementors = []string{"TransformationParameters"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _TransformationParameters(ctx context.Context, sel ast.SelectionSet, obj *models.TransformationParameters) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, transformationParametersImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransformationParameters")
		case "headers":
			out.Values[i] = ec._TransformationParameters_headers(ctx, field, obj)
		case "path":
			out.Values[i] = ec._TransformationParameters_path(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _TransformationParameters_headers(ctx context.Context, field graphql.CollectedField, obj *models.TransformationParameters) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "TransformationParameters",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Headers, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.MapStringString)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._MapStringString(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _TransformationParameters_path(ctx context.Context, field graphql.CollectedField, obj *models.TransformationParameters) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "TransformationParameters",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var upstreamImplementors = []string{"Upstream"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Upstream(ctx context.Context, sel ast.SelectionSet, obj *models.Upstream) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, upstreamImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Upstream")
		case "spec":
			out.Values[i] = ec._Upstream_spec(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "metadata":
			out.Values[i] = ec._Upstream_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._Upstream_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Upstream_spec(ctx context.Context, field graphql.CollectedField, obj *models.Upstream) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Upstream",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Spec, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.UpstreamSpec)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._UpstreamSpec(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Upstream_metadata(ctx context.Context, field graphql.CollectedField, obj *models.Upstream) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Upstream",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Metadata)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Metadata(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Upstream_status(ctx context.Context, field graphql.CollectedField, obj *models.Upstream) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Upstream",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Status)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Status(ctx, field.Selections, &res)
}

var upstreamMutationImplementors = []string{"UpstreamMutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _UpstreamMutation(ctx context.Context, sel ast.SelectionSet, obj *customtypes.UpstreamMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, upstreamMutationImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpstreamMutation")
		case "create":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._UpstreamMutation_create(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "update":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._UpstreamMutation_update(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "delete":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._UpstreamMutation_delete(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _UpstreamMutation_create(ctx context.Context, field graphql.CollectedField, obj *customtypes.UpstreamMutation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_UpstreamMutation_create_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "UpstreamMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UpstreamMutation().Create(rctx, obj, args["upstream"].(models.InputUpstream))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Upstream)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Upstream(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _UpstreamMutation_update(ctx context.Context, field graphql.CollectedField, obj *customtypes.UpstreamMutation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_UpstreamMutation_update_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "UpstreamMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UpstreamMutation().Update(rctx, obj, args["upstream"].(models.InputUpstream))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Upstream)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Upstream(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _UpstreamMutation_delete(ctx context.Context, field graphql.CollectedField, obj *customtypes.UpstreamMutation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_UpstreamMutation_delete_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "UpstreamMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UpstreamMutation().Delete(rctx, obj, args["guid"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Upstream)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Upstream(ctx, field.Selections, res)
}

var valueImplementors = []string{"Value"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Value(ctx context.Context, sel ast.SelectionSet, obj *models.Value) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, valueImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Value")
		case "key":
			out.Values[i] = ec._Value_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "value":
			out.Values[i] = ec._Value_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Value_key(ctx context.Context, field graphql.CollectedField, obj *models.Value) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Value",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Value_value(ctx context.Context, field graphql.CollectedField, obj *models.Value) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Value",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var virtualServiceImplementors = []string{"VirtualService"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _VirtualService(ctx context.Context, sel ast.SelectionSet, obj *models.VirtualService) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, virtualServiceImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VirtualService")
		case "metadata":
			out.Values[i] = ec._VirtualService_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._VirtualService_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "domains":
			out.Values[i] = ec._VirtualService_domains(ctx, field, obj)
		case "routes":
			out.Values[i] = ec._VirtualService_routes(ctx, field, obj)
		case "sslConfig":
			out.Values[i] = ec._VirtualService_sslConfig(ctx, field, obj)
		case "rateLimitConfig":
			out.Values[i] = ec._VirtualService_rateLimitConfig(ctx, field, obj)
		case "plugins":
			out.Values[i] = ec._VirtualService_plugins(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _VirtualService_metadata(ctx context.Context, field graphql.CollectedField, obj *models.VirtualService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "VirtualService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Metadata)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Metadata(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _VirtualService_status(ctx context.Context, field graphql.CollectedField, obj *models.VirtualService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "VirtualService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Status)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Status(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _VirtualService_domains(ctx context.Context, field graphql.CollectedField, obj *models.VirtualService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "VirtualService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Domains, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _VirtualService_routes(ctx context.Context, field graphql.CollectedField, obj *models.VirtualService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "VirtualService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Routes, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.Route)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Route(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _VirtualService_sslConfig(ctx context.Context, field graphql.CollectedField, obj *models.VirtualService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "VirtualService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SslConfig, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.SslConfig)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._SslConfig(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _VirtualService_rateLimitConfig(ctx context.Context, field graphql.CollectedField, obj *models.VirtualService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "VirtualService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RateLimitConfig, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.RateLimitConfig)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._RateLimitConfig(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _VirtualService_plugins(ctx context.Context, field graphql.CollectedField, obj *models.VirtualService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "VirtualService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Plugins, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.VirtualServicePlugins)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._VirtualServicePlugins(ctx, field.Selections, res)
}

var virtualServiceMutationImplementors = []string{"VirtualServiceMutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _VirtualServiceMutation(ctx context.Context, sel ast.SelectionSet, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, virtualServiceMutationImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VirtualServiceMutation")
		case "create":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._VirtualServiceMutation_create(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "update":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._VirtualServiceMutation_update(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "delete":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._VirtualServiceMutation_delete(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "addRoute":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._VirtualServiceMutation_addRoute(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "updateRoute":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._VirtualServiceMutation_updateRoute(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "deleteRoute":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._VirtualServiceMutation_deleteRoute(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "swapRoutes":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._VirtualServiceMutation_swapRoutes(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "shiftRoutes":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._VirtualServiceMutation_shiftRoutes(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _VirtualServiceMutation_create(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_VirtualServiceMutation_create_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "VirtualServiceMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.VirtualServiceMutation().Create(rctx, obj, args["virtualService"].(models.InputVirtualService))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.VirtualService)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._VirtualService(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _VirtualServiceMutation_update(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_VirtualServiceMutation_update_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "VirtualServiceMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.VirtualServiceMutation().Update(rctx, obj, args["virtualServiceId"].(string), args["resourceVersion"].(string), args["updates"].(models.InputUpdateVirtualService))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.VirtualService)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._VirtualService(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _VirtualServiceMutation_delete(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_VirtualServiceMutation_delete_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "VirtualServiceMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.VirtualServiceMutation().Delete(rctx, obj, args["guid"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.VirtualService)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._VirtualService(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _VirtualServiceMutation_addRoute(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_VirtualServiceMutation_addRoute_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "VirtualServiceMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.VirtualServiceMutation().AddRoute(rctx, obj, args["virtualServiceId"].(string), args["resourceVersion"].(string), args["index"].(int), args["route"].(models.InputRoute))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.VirtualService)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._VirtualService(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _VirtualServiceMutation_updateRoute(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_VirtualServiceMutation_updateRoute_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "VirtualServiceMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.VirtualServiceMutation().UpdateRoute(rctx, obj, args["virtualServiceId"].(string), args["resourceVersion"].(string), args["index"].(int), args["route"].(models.InputRoute))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.VirtualService)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._VirtualService(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _VirtualServiceMutation_deleteRoute(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_VirtualServiceMutation_deleteRoute_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "VirtualServiceMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.VirtualServiceMutation().DeleteRoute(rctx, obj, args["virtualServiceId"].(string), args["resourceVersion"].(string), args["index"].(int))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.VirtualService)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._VirtualService(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _VirtualServiceMutation_swapRoutes(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_VirtualServiceMutation_swapRoutes_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "VirtualServiceMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.VirtualServiceMutation().SwapRoutes(rctx, obj, args["virtualServiceId"].(string), args["resourceVersion"].(string), args["index1"].(int), args["index2"].(int))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.VirtualService)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._VirtualService(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _VirtualServiceMutation_shiftRoutes(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_VirtualServiceMutation_shiftRoutes_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "VirtualServiceMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.VirtualServiceMutation().ShiftRoutes(rctx, obj, args["virtualServiceId"].(string), args["resourceVersion"].(string), args["fromIndex"].(int), args["toIndex"].(int))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.VirtualService)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._VirtualService(ctx, field.Selections, res)
}

var virtualServicePluginsImplementors = []string{"VirtualServicePlugins"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _VirtualServicePlugins(ctx context.Context, sel ast.SelectionSet, obj *models.VirtualServicePlugins) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, virtualServicePluginsImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VirtualServicePlugins")
		case "empty":
			out.Values[i] = ec._VirtualServicePlugins_empty(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _VirtualServicePlugins_empty(ctx context.Context, field graphql.CollectedField, obj *models.VirtualServicePlugins) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "VirtualServicePlugins",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Empty, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var weightedDestinationImplementors = []string{"WeightedDestination"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _WeightedDestination(ctx context.Context, sel ast.SelectionSet, obj *models.WeightedDestination) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, weightedDestinationImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WeightedDestination")
		case "destination":
			out.Values[i] = ec._WeightedDestination_destination(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "weight":
			out.Values[i] = ec._WeightedDestination_weight(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _WeightedDestination_destination(ctx context.Context, field graphql.CollectedField, obj *models.WeightedDestination) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "WeightedDestination",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Destination, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.SingleDestination)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._SingleDestination(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _WeightedDestination_weight(ctx context.Context, field graphql.CollectedField, obj *models.WeightedDestination) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "WeightedDestination",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Weight, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

var __DirectiveImplementors = []string{"__Directive"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __DirectiveImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___InputValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var __EnumValueImplementors = []string{"__EnumValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __EnumValueImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __FieldImplementors = []string{"__Field"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __FieldImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___InputValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __InputValueImplementors = []string{"__InputValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __InputValueImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __SchemaImplementors = []string{"__Schema"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __SchemaImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Type(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Directive(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var __TypeImplementors = []string{"__Type"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __TypeImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field___Type_fields_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Field(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Type(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Type(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field___Type_enumValues_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___EnumValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___InputValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) _Destination(ctx context.Context, sel ast.SelectionSet, obj *models.Destination) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case models.MultiDestination:
		return ec._MultiDestination(ctx, sel, &obj)
	case *models.MultiDestination:
		return ec._MultiDestination(ctx, sel, obj)
	case models.SingleDestination:
		return ec._SingleDestination(ctx, sel, &obj)
	case *models.SingleDestination:
		return ec._SingleDestination(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _DestinationSpec(ctx context.Context, sel ast.SelectionSet, obj *models.DestinationSpec) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case models.AwsDestinationSpec:
		return ec._AwsDestinationSpec(ctx, sel, &obj)
	case *models.AwsDestinationSpec:
		return ec._AwsDestinationSpec(ctx, sel, obj)
	case models.AzureDestinationSpec:
		return ec._AzureDestinationSpec(ctx, sel, &obj)
	case *models.AzureDestinationSpec:
		return ec._AzureDestinationSpec(ctx, sel, obj)
	case models.RestDestinationSpec:
		return ec._RestDestinationSpec(ctx, sel, &obj)
	case *models.RestDestinationSpec:
		return ec._RestDestinationSpec(ctx, sel, obj)
	case models.GrpcDestinationSpec:
		return ec._GrpcDestinationSpec(ctx, sel, &obj)
	case *models.GrpcDestinationSpec:
		return ec._GrpcDestinationSpec(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _SecretKind(ctx context.Context, sel ast.SelectionSet, obj *models.SecretKind) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case models.AwsSecret:
		return ec._AwsSecret(ctx, sel, &obj)
	case *models.AwsSecret:
		return ec._AwsSecret(ctx, sel, obj)
	case models.AzureSecret:
		return ec._AzureSecret(ctx, sel, &obj)
	case *models.AzureSecret:
		return ec._AzureSecret(ctx, sel, obj)
	case models.TlsSecret:
		return ec._TlsSecret(ctx, sel, &obj)
	case *models.TlsSecret:
		return ec._TlsSecret(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ServiceSpec(ctx context.Context, sel ast.SelectionSet, obj *models.ServiceSpec) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case models.RestServiceSpec:
		return ec._RestServiceSpec(ctx, sel, &obj)
	case *models.RestServiceSpec:
		return ec._RestServiceSpec(ctx, sel, obj)
	case models.GrpcServiceSpec:
		return ec._GrpcServiceSpec(ctx, sel, &obj)
	case *models.GrpcServiceSpec:
		return ec._GrpcServiceSpec(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UpstreamSpec(ctx context.Context, sel ast.SelectionSet, obj *models.UpstreamSpec) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case models.AwsUpstreamSpec:
		return ec._AwsUpstreamSpec(ctx, sel, &obj)
	case *models.AwsUpstreamSpec:
		return ec._AwsUpstreamSpec(ctx, sel, obj)
	case models.AzureUpstreamSpec:
		return ec._AzureUpstreamSpec(ctx, sel, &obj)
	case *models.AzureUpstreamSpec:
		return ec._AzureUpstreamSpec(ctx, sel, obj)
	case models.KubeUpstreamSpec:
		return ec._KubeUpstreamSpec(ctx, sel, &obj)
	case *models.KubeUpstreamSpec:
		return ec._KubeUpstreamSpec(ctx, sel, obj)
	case models.StaticUpstreamSpec:
		return ec._StaticUpstreamSpec(ctx, sel, &obj)
	case *models.StaticUpstreamSpec:
		return ec._StaticUpstreamSpec(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func UnmarshalInputArtifact(v interface{}) (models.InputArtifact, error) {
	var it models.InputArtifact
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "data":
			var err error
			it.Data, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "metadata":
			var err error
			it.Metadata, err = UnmarshalInputMetadata(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputAwsDestinationSpec(v interface{}) (models.InputAwsDestinationSpec, error) {
	var it models.InputAwsDestinationSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "logicalName":
			var err error
			it.LogicalName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "invocationStyle":
			var err error
			err = (&it.InvocationStyle).UnmarshalGQL(v)
			if err != nil {
				return it, err
			}
		case "responseTransformation":
			var err error
			it.ResponseTransformation, err = graphql.UnmarshalBoolean(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputAwsLambdaFunction(v interface{}) (models.InputAwsLambdaFunction, error) {
	var it models.InputAwsLambdaFunction
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "logicalName":
			var err error
			it.LogicalName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "functionName":
			var err error
			it.FunctionName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "qualifier":
			var err error
			it.Qualifier, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputAwsSecret(v interface{}) (models.InputAwsSecret, error) {
	var it models.InputAwsSecret
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "accessKey":
			var err error
			it.AccessKey, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "secretKey":
			var err error
			it.SecretKey, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputAwsUpstreamSpec(v interface{}) (models.InputAwsUpstreamSpec, error) {
	var it models.InputAwsUpstreamSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "region":
			var err error
			it.Region, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "secretRef":
			var err error
			it.SecretRef, err = UnmarshalInputResourceRef(v)
			if err != nil {
				return it, err
			}
		case "functions":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Functions = make([]models.InputAwsLambdaFunction, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Functions[idx1], err = UnmarshalInputAwsLambdaFunction(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputAzureDestinationSpec(v interface{}) (models.InputAzureDestinationSpec, error) {
	var it models.InputAzureDestinationSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "functionName":
			var err error
			it.FunctionName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputAzureFunction(v interface{}) (models.InputAzureFunction, error) {
	var it models.InputAzureFunction
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "functionName":
			var err error
			it.FunctionName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "authLevel":
			var err error
			it.AuthLevel, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputAzureSecret(v interface{}) (models.InputAzureSecret, error) {
	var it models.InputAzureSecret
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "apiKeys":
			var err error
			it.APIKeys, err = UnmarshalInputMapStringString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputAzureUpstreamSpec(v interface{}) (models.InputAzureUpstreamSpec, error) {
	var it models.InputAzureUpstreamSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "functionAppName":
			var err error
			it.FunctionAppName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "secretRef":
			var err error
			var ptr1 models.InputResourceRef
			if v != nil {
				ptr1, err = UnmarshalInputResourceRef(v)
				it.SecretRef = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "functions":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Functions = make([]models.InputAzureFunction, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Functions[idx1], err = UnmarshalInputAzureFunction(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputDestination(v interface{}) (models.InputDestination, error) {
	var it models.InputDestination
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "singleDestination":
			var err error
			var ptr1 models.InputSingleDestination
			if v != nil {
				ptr1, err = UnmarshalInputSingleDestination(v)
				it.SingleDestination = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "multiDestination":
			var err error
			var ptr1 models.InputMultiDestination
			if v != nil {
				ptr1, err = UnmarshalInputMultiDestination(v)
				it.MultiDestination = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputDestinationSpec(v interface{}) (models.InputDestinationSpec, error) {
	var it models.InputDestinationSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "aws":
			var err error
			var ptr1 models.InputAwsDestinationSpec
			if v != nil {
				ptr1, err = UnmarshalInputAwsDestinationSpec(v)
				it.Aws = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "azure":
			var err error
			var ptr1 models.InputAzureDestinationSpec
			if v != nil {
				ptr1, err = UnmarshalInputAzureDestinationSpec(v)
				it.Azure = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "rest":
			var err error
			var ptr1 models.InputRestDestinationSpec
			if v != nil {
				ptr1, err = UnmarshalInputRestDestinationSpec(v)
				it.Rest = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "grpc":
			var err error
			var ptr1 models.InputGrpcDestinationSpec
			if v != nil {
				ptr1, err = UnmarshalInputGrpcDestinationSpec(v)
				it.Grpc = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputGrpcDestinationSpec(v interface{}) (models.InputGrpcDestinationSpec, error) {
	var it models.InputGrpcDestinationSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "package":
			var err error
			it.Package, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "service":
			var err error
			it.Service, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "function":
			var err error
			it.Function, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputGrpcServiceSpec(v interface{}) (models.InputGrpcServiceSpec, error) {
	var it models.InputGrpcServiceSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "empty":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Empty = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputKeyValueMatcher(v interface{}) (models.InputKeyValueMatcher, error) {
	var it models.InputKeyValueMatcher
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "value":
			var err error
			it.Value, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "isRegex":
			var err error
			it.IsRegex, err = graphql.UnmarshalBoolean(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputKubeUpstreamSpec(v interface{}) (models.InputKubeUpstreamSpec, error) {
	var it models.InputKubeUpstreamSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "serviceName":
			var err error
			it.ServiceName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "serviceNamespace":
			var err error
			it.ServiceNamespace, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "servicePort":
			var err error
			it.ServicePort, err = graphql.UnmarshalInt(v)
			if err != nil {
				return it, err
			}
		case "selector":
			var err error
			var ptr1 models.InputMapStringString
			if v != nil {
				ptr1, err = UnmarshalInputMapStringString(v)
				it.Selector = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "serviceSpec":
			var err error
			var ptr1 models.InputServiceSpec
			if v != nil {
				ptr1, err = UnmarshalInputServiceSpec(v)
				it.ServiceSpec = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputMapStringString(v interface{}) (models.InputMapStringString, error) {
	var it models.InputMapStringString
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "values":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Values = make([]models.InputValue, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Values[idx1], err = UnmarshalInputValue(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputMatcher(v interface{}) (models.InputMatcher, error) {
	var it models.InputMatcher
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "pathMatch":
			var err error
			it.PathMatch, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "pathMatchType":
			var err error
			err = (&it.PathMatchType).UnmarshalGQL(v)
			if err != nil {
				return it, err
			}
		case "headers":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Headers = make([]models.InputKeyValueMatcher, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Headers[idx1], err = UnmarshalInputKeyValueMatcher(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "queryParameters":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.QueryParameters = make([]models.InputKeyValueMatcher, len(rawIf1))
			for idx1 := range rawIf1 {
				it.QueryParameters[idx1], err = UnmarshalInputKeyValueMatcher(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "methods":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Methods = make([]string, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Methods[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputMetadata(v interface{}) (models.InputMetadata, error) {
	var it models.InputMetadata
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "namespace":
			var err error
			it.Namespace, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "resourceVersion":
			var err error
			it.ResourceVersion, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "labels":
			var err error
			var ptr1 models.InputMapStringString
			if v != nil {
				ptr1, err = UnmarshalInputMapStringString(v)
				it.Labels = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "annotations":
			var err error
			var ptr1 models.InputMapStringString
			if v != nil {
				ptr1, err = UnmarshalInputMapStringString(v)
				it.Annotations = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputMultiDestination(v interface{}) (models.InputMultiDestination, error) {
	var it models.InputMultiDestination
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "destinations":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Destinations = make([]models.InputWeightedDestination, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Destinations[idx1], err = UnmarshalInputWeightedDestination(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputRateLimit(v interface{}) (models.InputRateLimit, error) {
	var it models.InputRateLimit
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "unit":
			var err error
			err = (&it.Unit).UnmarshalGQL(v)
			if err != nil {
				return it, err
			}
		case "requestsPerUnit":
			var err error
			err = (&it.RequestsPerUnit).UnmarshalGQL(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputRateLimitConfig(v interface{}) (models.InputRateLimitConfig, error) {
	var it models.InputRateLimitConfig
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "authorizedLimits":
			var err error
			var ptr1 models.InputRateLimit
			if v != nil {
				ptr1, err = UnmarshalInputRateLimit(v)
				it.AuthorizedLimits = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "anonymousLimits":
			var err error
			var ptr1 models.InputRateLimit
			if v != nil {
				ptr1, err = UnmarshalInputRateLimit(v)
				it.AnonymousLimits = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputResourceRef(v interface{}) (models.InputResourceRef, error) {
	var it models.InputResourceRef
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "namespace":
			var err error
			it.Namespace, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputRestDestinationSpec(v interface{}) (models.InputRestDestinationSpec, error) {
	var it models.InputRestDestinationSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "functionName":
			var err error
			it.FunctionName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "parameters":
			var err error
			var ptr1 models.InputTransformationParameters
			if v != nil {
				ptr1, err = UnmarshalInputTransformationParameters(v)
				it.Parameters = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputRestServiceSpec(v interface{}) (models.InputRestServiceSpec, error) {
	var it models.InputRestServiceSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "functions":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Functions = make([]models.InputTransformation, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Functions[idx1], err = UnmarshalInputTransformation(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "inlineSwaggerDoc":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.InlineSwaggerDoc = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputRoute(v interface{}) (models.InputRoute, error) {
	var it models.InputRoute
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "matcher":
			var err error
			it.Matcher, err = UnmarshalInputMatcher(v)
			if err != nil {
				return it, err
			}
		case "destination":
			var err error
			it.Destination, err = UnmarshalInputDestination(v)
			if err != nil {
				return it, err
			}
		case "plugins":
			var err error
			var ptr1 models.InputRoutePlugins
			if v != nil {
				ptr1, err = UnmarshalInputRoutePlugins(v)
				it.Plugins = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputRoutePlugins(v interface{}) (models.InputRoutePlugins, error) {
	var it models.InputRoutePlugins
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "empty":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Empty = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputSecret(v interface{}) (models.InputSecret, error) {
	var it models.InputSecret
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "kind":
			var err error
			it.Kind, err = UnmarshalInputSecretKind(v)
			if err != nil {
				return it, err
			}
		case "metadata":
			var err error
			it.Metadata, err = UnmarshalInputMetadata(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputSecretKind(v interface{}) (models.InputSecretKind, error) {
	var it models.InputSecretKind
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "aws":
			var err error
			var ptr1 models.InputAwsSecret
			if v != nil {
				ptr1, err = UnmarshalInputAwsSecret(v)
				it.Aws = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "azure":
			var err error
			var ptr1 models.InputAzureSecret
			if v != nil {
				ptr1, err = UnmarshalInputAzureSecret(v)
				it.Azure = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "tls":
			var err error
			var ptr1 models.InputTlsSecret
			if v != nil {
				ptr1, err = UnmarshalInputTlsSecret(v)
				it.TLS = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputServiceSpec(v interface{}) (models.InputServiceSpec, error) {
	var it models.InputServiceSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "rest":
			var err error
			var ptr1 models.InputRestServiceSpec
			if v != nil {
				ptr1, err = UnmarshalInputRestServiceSpec(v)
				it.Rest = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "grpc":
			var err error
			var ptr1 models.InputGrpcServiceSpec
			if v != nil {
				ptr1, err = UnmarshalInputGrpcServiceSpec(v)
				it.Grpc = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputSettings(v interface{}) (models.InputSettings, error) {
	var it models.InputSettings
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "watchNamespaces":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.WatchNamespaces = make([]string, len(rawIf1))
			for idx1 := range rawIf1 {
				it.WatchNamespaces[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "refreshRate":
			var err error
			var ptr1 customtypes.Duration
			if v != nil {
				err = (&ptr1).UnmarshalGQL(v)
				it.RefreshRate = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "metadata":
			var err error
			it.Metadata, err = UnmarshalInputMetadata(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputSingleDestination(v interface{}) (models.InputSingleDestination, error) {
	var it models.InputSingleDestination
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "upstream":
			var err error
			it.Upstream, err = UnmarshalInputResourceRef(v)
			if err != nil {
				return it, err
			}
		case "destinationSpec":
			var err error
			var ptr1 models.InputDestinationSpec
			if v != nil {
				ptr1, err = UnmarshalInputDestinationSpec(v)
				it.DestinationSpec = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputSslConfig(v interface{}) (models.InputSslConfig, error) {
	var it models.InputSslConfig
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "secretRef":
			var err error
			it.SecretRef, err = UnmarshalInputResourceRef(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputStaticHost(v interface{}) (models.InputStaticHost, error) {
	var it models.InputStaticHost
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "addr":
			var err error
			it.Addr, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "port":
			var err error
			it.Port, err = graphql.UnmarshalInt(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputStaticUpstreamSpec(v interface{}) (models.InputStaticUpstreamSpec, error) {
	var it models.InputStaticUpstreamSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "hosts":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Hosts = make([]models.InputStaticHost, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Hosts[idx1], err = UnmarshalInputStaticHost(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "serviceSpec":
			var err error
			var ptr1 models.InputServiceSpec
			if v != nil {
				ptr1, err = UnmarshalInputServiceSpec(v)
				it.ServiceSpec = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "useTls":
			var err error
			it.UseTLS, err = graphql.UnmarshalBoolean(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputStatus(v interface{}) (models.InputStatus, error) {
	var it models.InputStatus
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "state":
			var err error
			err = (&it.State).UnmarshalGQL(v)
			if err != nil {
				return it, err
			}
		case "reason":
			var err error
			it.Reason, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputTlsSecret(v interface{}) (models.InputTlsSecret, error) {
	var it models.InputTlsSecret
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "certChain":
			var err error
			it.CertChain, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "privateKey":
			var err error
			it.PrivateKey, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "rootCa":
			var err error
			it.RootCa, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputTransformation(v interface{}) (models.InputTransformation, error) {
	var it models.InputTransformation
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "functionName":
			var err error
			it.FunctionName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "body":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Body = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "headers":
			var err error
			var ptr1 models.InputMapStringString
			if v != nil {
				ptr1, err = UnmarshalInputMapStringString(v)
				it.Headers = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputTransformationParameters(v interface{}) (models.InputTransformationParameters, error) {
	var it models.InputTransformationParameters
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "headers":
			var err error
			var ptr1 models.InputMapStringString
			if v != nil {
				ptr1, err = UnmarshalInputMapStringString(v)
				it.Headers = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "path":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Path = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputUpdateMetadata(v interface{}) (models.InputUpdateMetadata, error) {
	var it models.InputUpdateMetadata
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Name = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "labels":
			var err error
			var ptr1 models.InputMapStringString
			if v != nil {
				ptr1, err = UnmarshalInputMapStringString(v)
				it.Labels = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "annotations":
			var err error
			var ptr1 models.InputMapStringString
			if v != nil {
				ptr1, err = UnmarshalInputMapStringString(v)
				it.Annotations = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputUpdateVirtualService(v interface{}) (models.InputUpdateVirtualService, error) {
	var it models.InputUpdateVirtualService
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "domains":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Domains = make([]string, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Domains[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "sslConfig":
			var err error
			var ptr1 models.InputSslConfig
			if v != nil {
				ptr1, err = UnmarshalInputSslConfig(v)
				it.SslConfig = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "rateLimitConfig":
			var err error
			var ptr1 models.InputRateLimitConfig
			if v != nil {
				ptr1, err = UnmarshalInputRateLimitConfig(v)
				it.RateLimitConfig = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "metadata":
			var err error
			var ptr1 models.InputUpdateMetadata
			if v != nil {
				ptr1, err = UnmarshalInputUpdateMetadata(v)
				it.Metadata = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "plugins":
			var err error
			var ptr1 models.InputVirtualServicePlugins
			if v != nil {
				ptr1, err = UnmarshalInputVirtualServicePlugins(v)
				it.Plugins = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputUpstream(v interface{}) (models.InputUpstream, error) {
	var it models.InputUpstream
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "spec":
			var err error
			it.Spec, err = UnmarshalInputUpstreamSpec(v)
			if err != nil {
				return it, err
			}
		case "metadata":
			var err error
			it.Metadata, err = UnmarshalInputMetadata(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputUpstreamSpec(v interface{}) (models.InputUpstreamSpec, error) {
	var it models.InputUpstreamSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "aws":
			var err error
			var ptr1 models.InputAwsUpstreamSpec
			if v != nil {
				ptr1, err = UnmarshalInputAwsUpstreamSpec(v)
				it.Aws = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "azure":
			var err error
			var ptr1 models.InputAzureUpstreamSpec
			if v != nil {
				ptr1, err = UnmarshalInputAzureUpstreamSpec(v)
				it.Azure = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "kube":
			var err error
			var ptr1 models.InputKubeUpstreamSpec
			if v != nil {
				ptr1, err = UnmarshalInputKubeUpstreamSpec(v)
				it.Kube = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "static":
			var err error
			var ptr1 models.InputStaticUpstreamSpec
			if v != nil {
				ptr1, err = UnmarshalInputStaticUpstreamSpec(v)
				it.Static = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputValue(v interface{}) (models.InputValue, error) {
	var it models.InputValue
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "key":
			var err error
			it.Key, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "value":
			var err error
			it.Value, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputVirtualService(v interface{}) (models.InputVirtualService, error) {
	var it models.InputVirtualService
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "domains":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Domains = make([]string, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Domains[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "routes":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Routes = make([]models.InputRoute, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Routes[idx1], err = UnmarshalInputRoute(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "sslConfig":
			var err error
			var ptr1 models.InputSslConfig
			if v != nil {
				ptr1, err = UnmarshalInputSslConfig(v)
				it.SslConfig = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "rateLimitConfig":
			var err error
			var ptr1 models.InputRateLimitConfig
			if v != nil {
				ptr1, err = UnmarshalInputRateLimitConfig(v)
				it.RateLimitConfig = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "metadata":
			var err error
			it.Metadata, err = UnmarshalInputMetadata(v)
			if err != nil {
				return it, err
			}
		case "plugins":
			var err error
			var ptr1 models.InputVirtualServicePlugins
			if v != nil {
				ptr1, err = UnmarshalInputVirtualServicePlugins(v)
				it.Plugins = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputVirtualServicePlugins(v interface{}) (models.InputVirtualServicePlugins, error) {
	var it models.InputVirtualServicePlugins
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "empty":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Empty = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputWeightedDestination(v interface{}) (models.InputWeightedDestination, error) {
	var it models.InputWeightedDestination
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "destination":
			var err error
			it.Destination, err = UnmarshalInputSingleDestination(v)
			if err != nil {
				return it, err
			}
		case "weight":
			var err error
			it.Weight, err = graphql.UnmarshalInt(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) FieldMiddleware(ctx context.Context, obj interface{}, next graphql.Resolver) (ret interface{}) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	res, err := ec.ResolverMiddleware(ctx, next)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return res
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var parsedSchema = gqlparser.MustLoadSchema(
	&ast.Source{Name: "gql_schemas/artifacts.graphql", Input: `type ArtifactMutation {
  create(artifact: InputArtifact!): Artifact
  update(artifact: InputArtifact!): Artifact
  delete(guid: ID!): Artifact
}
type Artifact {
  data: String!
  metadata: Metadata!
}

input InputArtifact {
  data: String!
  metadata: InputMetadata!
}
`},
	&ast.Source{Name: "gql_schemas/metadata.graphql", Input: `type Metadata {
  name: String!
  namespace: String!
  resourceVersion: String!
  labels: MapStringString
  annotations: MapStringString
  guid: String!
}

type Status {
  state: State!
  reason: String
}

type ResourceRef {
  name: String!
  namespace: String!
}

input InputResourceRef {
  name: String!
  namespace: String!
}

# Scalars / Extra

enum State {
  PENDING
  ACCEPTED
  REJECTED
}

enum AzureFnAuthLevel {
  ANONYMOUS
  FUNCTION
  ADMIN
}

type MapStringString {
  values: [Value!]
}

input InputMapStringString {
  values: [InputValue!]
}

type Value {
  key: String!
  value: String!
}

input InputValue {
  key: String!
  value: String!
}

enum PathMatchType {
  PREFIX
  REGEX
  EXACT
}

enum AwsLambdaInvocationStyle {
  SYNC
  ASYNC
}

scalar Duration
scalar UnsignedInt`},
	&ast.Source{Name: "gql_schemas/oauth.graphql", Input: `type OAuthEndpoint {
  url: String!
  clientName: String!
}
`},
	&ast.Source{Name: "gql_schemas/schema.graphql", Input: `# Top Level
schema {
    query: Query
    mutation: Mutation
}

type Query {
    version: String!
    getOAuthEndpoint: OAuthEndpoint!
    allNamespaces: [Namespace!]!
    namespace(name: String!): Namespace!
    settings: Settings
}

type Mutation {
    upstreams: UpstreamMutation!
    virtualServices: VirtualServiceMutation!
    secrets: SecretMutation!
    artifacts: ArtifactMutation!
    settings: SettingsMutation!
}

type Subscription {
    upstreams(namespace: String!, selector: InputMapStringString): [Upstream]
    virtualServices(
        namespace: String!
        selector: InputMapStringString
    ): [VirtualService]
}

type Namespace {
    name: String!

    upstreams: [Upstream]!
    upstream(name: String!): Upstream

    virtualServices: [VirtualService]!
    virtualService(name: String!): VirtualService

    secrets: [Secret]!
    secret(name: String!): Secret

    artifacts: [Artifact]!
    artifact(name: String!): Artifact
}
`},
	&ast.Source{Name: "gql_schemas/secrets.graphql", Input: `type SecretMutation {
  create(secret: InputSecret!): Secret
  update(secret: InputSecret!): Secret
  delete(guid: ID!): Secret
}

type Secret {
  kind: SecretKind!
  metadata: Metadata!
}

union SecretKind = AwsSecret | AzureSecret | TlsSecret

type AwsSecret {
  accessKey: String!
  secretKey: String!
}

type AzureSecret {
  apiKeys: MapStringString
}

type TlsSecret {
  certChain: String!
  privateKey: String!
  rootCa: String! # note: it is okay to leave this as an empty string
}

input InputSecret {
  kind: InputSecretKind!
  metadata: InputMetadata!
}

input InputSecretKind {
  # oneof: aws, azure, tls
  aws: InputAwsSecret
  azure: InputAzureSecret
  tls: InputTlsSecret
}

input InputAwsSecret {
  accessKey: String!
  secretKey: String!
}

input InputAzureSecret {
  apiKeys: InputMapStringString!
}

input InputTlsSecret {
  certChain: String!
  privateKey: String!
  rootCa: String! # note: it is okay to leave this as an empty string
}
`},
	&ast.Source{Name: "gql_schemas/settings.graphql", Input: `type SettingsMutation {
  update(settings: InputSettings!): Settings
}

type Settings {
  watchNamespaces: [String!]
  refreshRate: Duration
  metadata: Metadata!
}

input InputSettings {
  watchNamespaces: [String!]
  refreshRate: Duration
  metadata: InputMetadata!
}
`},
	&ast.Source{Name: "gql_schemas/upstreams.graphql", Input: `type UpstreamMutation {
  create(upstream: InputUpstream!): Upstream
  update(upstream: InputUpstream!): Upstream
  delete(guid: ID!): Upstream
}

type Upstream {
  spec: UpstreamSpec!
  metadata: Metadata!
  status: Status!
}

union UpstreamSpec =
    AwsUpstreamSpec
  | AzureUpstreamSpec
  | KubeUpstreamSpec
  | StaticUpstreamSpec

type AwsUpstreamSpec {
  region: String!
  secretRef: ResourceRef!
  functions: [AwsLambdaFunction!]
}

type AzureUpstreamSpec {
  functionAppName: String!
  secretRef: ResourceRef!
  functions: [AzureFunction!]
}

type KubeUpstreamSpec {
  serviceName: String!
  serviceNamespace: String!
  servicePort: Int!
  selector: MapStringString
  serviceSpec: ServiceSpec
}

type StaticUpstreamSpec {
  hosts: [StaticHost!]
  serviceSpec: ServiceSpec
  useTls: Boolean!
}

type StaticHost {
  addr: String!
  port: Int!
}

type AwsLambdaFunction {
  logicalName: String!
  functionName: String!
  qualifier: String!
}

type AzureFunction {
  functionName: String!
  authLevel: AzureFnAuthLevel!
}

union ServiceSpec = RestServiceSpec | GrpcServiceSpec

type RestServiceSpec {
  functions: [Transformation!]
}

type Transformation {
  functionName: String!
  body: String
  headers: MapStringString
}

type GrpcServiceSpec {
  grpcServices: [GrpcService]
}

type GrpcService {
  packageName: String!
  serviceName: String!
  functionNames: [String!]
}

# Upstream Mutation
# Upstream Mutation
# Upstream Mutation
# Upstream Mutation

input InputUpstream {
  spec: InputUpstreamSpec!
  metadata: InputMetadata!
}

input InputUpstreamSpec {
  # oneof: aws | azure | kube | static
  aws: InputAwsUpstreamSpec
  azure: InputAzureUpstreamSpec
  kube: InputKubeUpstreamSpec
  static: InputStaticUpstreamSpec
}

input InputAwsUpstreamSpec {
  region: String!
  secretRef: InputResourceRef!
  functions: [InputAwsLambdaFunction!]
}

input InputAzureUpstreamSpec {
  functionAppName: String!
  secretRef: InputResourceRef
  functions: [InputAzureFunction!]
}

input InputKubeUpstreamSpec {
  serviceName: String!
  serviceNamespace: String!
  servicePort: Int!
  selector: InputMapStringString
  serviceSpec: InputServiceSpec
}

input InputStaticUpstreamSpec {
  hosts: [InputStaticHost!]
  serviceSpec: InputServiceSpec
  useTls: Boolean!
}

input InputStaticHost {
  addr: String!
  port: Int!
}

input InputAwsLambdaFunction {
  logicalName: String!
  functionName: String!
  qualifier: String!
}

input InputAzureFunction {
  functionName: String!
  authLevel: String!
}

input InputServiceSpec {
  # oneof: Rest | grpc
  rest: InputRestServiceSpec
  grpc: InputGrpcServiceSpec
}

input InputRestServiceSpec {
  functions: [InputTransformation!]
  inlineSwaggerDoc: String
}

input InputTransformation {
  functionName: String!
  body: String
  headers: InputMapStringString
}

# Not implemented yet
input InputGrpcServiceSpec {
  empty: String
}

input InputMetadata {
  name: String!
  namespace: String!
  resourceVersion: String!
  labels: InputMapStringString
  annotations: InputMapStringString
}

input InputUpdateMetadata {
  name: String
  labels: InputMapStringString
  annotations: InputMapStringString
}

input InputStatus {
  state: State!
  reason: String!
}
`},
	&ast.Source{Name: "gql_schemas/virtualservices.graphql", Input: `type VirtualServiceMutation {
  create(virtualService: InputVirtualService!): VirtualService
  update(
    virtualServiceId: ID!
    resourceVersion: String!
    updates: InputUpdateVirtualService!
  ): VirtualService

  delete(guid: ID!): VirtualService

  addRoute(
    virtualServiceId: ID!
    resourceVersion: String!
    index: Int!
    route: InputRoute!
  ): VirtualService

  updateRoute(
    virtualServiceId: ID!
    resourceVersion: String!
    index: Int!
    route: InputRoute!
  ): VirtualService

  deleteRoute(
    virtualServiceId: ID!
    resourceVersion: String!
    index: Int!
  ): VirtualService

  swapRoutes(
    virtualServiceId: ID!
    resourceVersion: String!
    index1: Int!
    index2: Int!
  ): VirtualService

  shiftRoutes(
    virtualServiceId: ID!
    resourceVersion: String!
    fromIndex: Int!
    toIndex: Int!
  ): VirtualService
}

type VirtualService {
  metadata: Metadata!
  status: Status!
  domains: [String!]
  routes: [Route!]
  sslConfig: SslConfig
  rateLimitConfig: RateLimitConfig
  plugins: VirtualServicePlugins @deprecated(reason: "Use ` + "`" + `rateLimitConfig` + "`" + `.")
}

type Route {
  matcher: Matcher!
  destination: Destination!
  plugins: RoutePlugins
}

type Matcher {
  pathMatch: String!
  pathMatchType: PathMatchType!
  headers: [KeyValueMatcher!]
  queryParameters: [KeyValueMatcher!]
  methods: [String!]
}

union Destination = MultiDestination | SingleDestination

type MultiDestination {
  destinations: [WeightedDestination!]
}

type WeightedDestination {
  destination: SingleDestination!
  weight: Int!
}

type SingleDestination {
  upstream: Upstream!
  destinationSpec: DestinationSpec
}

union DestinationSpec =
    AwsDestinationSpec
  | AzureDestinationSpec
  | RestDestinationSpec
  | GrpcDestinationSpec

type AwsDestinationSpec {
  logicalName: String!
  invocationStyle: AwsLambdaInvocationStyle!
  responseTransformation: Boolean!
}

type AzureDestinationSpec {
  functionName: String!
}

type RestDestinationSpec {
  functionName: String!
  parameters: TransformationParameters
}

type GrpcDestinationSpec {
  package: String!
  service: String!
  function: String!
  parameters: TransformationParameters
}

type RateLimitConfig {
  authorizedLimits: RateLimit
  anonymousLimits: RateLimit
}

type RateLimit {
  unit: TimeUnit!
  requestsPerUnit: UnsignedInt!
}

enum TimeUnit {
  SECOND
  MINUTE
  HOUR
  DAY
}

# not implemented
type VirtualServicePlugins {
  empty: String
}

# not implemented
type RoutePlugins {
  empty: String
}

input InputVirtualService {
  domains: [String!]
  routes: [InputRoute!]
  sslConfig: InputSslConfig
  rateLimitConfig: InputRateLimitConfig
  metadata: InputMetadata!
  plugins: InputVirtualServicePlugins @deprecated(reason: "Use ` + "`" + `rateLimitConfig` + "`" + `.")
}

input InputUpdateVirtualService {
  domains: [String!]
  sslConfig: InputSslConfig
  rateLimitConfig: InputRateLimitConfig
  metadata: InputUpdateMetadata
  plugins: InputVirtualServicePlugins @deprecated(reason: "Use ` + "`" + `rateLimitConfig` + "`" + `.")
}

input InputRoute {
  matcher: InputMatcher!
  destination: InputDestination!
  plugins: InputRoutePlugins
}

input InputMatcher {
  pathMatch: String!
  pathMatchType: PathMatchType!
  headers: [InputKeyValueMatcher!]
  queryParameters: [InputKeyValueMatcher!]
  methods: [String!]
}

input InputRateLimitConfig {
  authorizedLimits: InputRateLimit
  anonymousLimits: InputRateLimit
}

input InputRateLimit {
  unit: TimeUnit!
  requestsPerUnit: UnsignedInt!
}

# not implemented
input InputVirtualServicePlugins {
  empty: String
}

input InputDestination {
  # oneof: MultiDestination, SingleDestination
  singleDestination: InputSingleDestination
  multiDestination: InputMultiDestination
}

input InputKeyValueMatcher {
  name: String!
  value: String!
  isRegex: Boolean!
}

type TransformationParameters {
  headers: MapStringString
  path: String
}

type KeyValueMatcher {
  name: String!
  value: String!
  isRegex: Boolean!
}

type SslConfig {
  secretRef: ResourceRef!
}

input InputSslConfig {
  secretRef: InputResourceRef!
}

input InputSingleDestination {
  upstream: InputResourceRef!
  destinationSpec: InputDestinationSpec
}

input InputDestinationSpec {
  # oneof: aws | azure | rest | grpc
  aws: InputAwsDestinationSpec
  azure: InputAzureDestinationSpec
  rest: InputRestDestinationSpec
  grpc: InputGrpcDestinationSpec
}

input InputMultiDestination {
  destinations: [InputWeightedDestination!]
}

# not implemented
input InputRoutePlugins {
  empty: String
}

input InputWeightedDestination {
  destination: InputSingleDestination!
  weight: Int!
}

input InputAwsDestinationSpec {
  logicalName: String!
  invocationStyle: AwsLambdaInvocationStyle!
  responseTransformation: Boolean!
}

input InputAzureDestinationSpec {
  functionName: String!
}

input InputRestDestinationSpec {
  functionName: String!
  parameters: InputTransformationParameters
}

input InputGrpcDestinationSpec {
  package: String!
  service: String!
  function: String!
}

input InputTransformationParameters {
  headers: InputMapStringString
  path: String
}
`},
)
