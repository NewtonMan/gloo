// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	bytes "bytes"
	context "context"
	fmt "fmt"
	strconv "strconv"
	sync "sync"

	graphql "github.com/99designs/gqlgen/graphql"
	introspection "github.com/99designs/gqlgen/graphql/introspection"
	customtypes "github.com/solo-io/solo-projects/projects/apiserver/pkg/graphql/customtypes"
	models "github.com/solo-io/solo-projects/projects/apiserver/pkg/graphql/models"
	gqlparser "github.com/vektah/gqlparser"
	ast "github.com/vektah/gqlparser/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	ArtifactMutation() ArtifactMutationResolver
	ArtifactQuery() ArtifactQueryResolver
	Mutation() MutationResolver
	Query() QueryResolver
	ResolverMapMutation() ResolverMapMutationResolver
	ResolverMapQuery() ResolverMapQueryResolver
	SchemaMutation() SchemaMutationResolver
	SchemaQuery() SchemaQueryResolver
	SecretMutation() SecretMutationResolver
	SecretQuery() SecretQueryResolver
	SettingsMutation() SettingsMutationResolver
	SettingsQuery() SettingsQueryResolver
	Subscription() SubscriptionResolver
	UpstreamMutation() UpstreamMutationResolver
	UpstreamQuery() UpstreamQueryResolver
	VirtualServiceMutation() VirtualServiceMutationResolver
	VirtualServiceQuery() VirtualServiceQueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Artifact struct {
		Data     func(childComplexity int) int
		Metadata func(childComplexity int) int
	}

	ArtifactMutation struct {
		Create func(childComplexity int, artifact models.InputArtifact) int
		Update func(childComplexity int, artifact models.InputArtifact) int
		Delete func(childComplexity int, name string) int
	}

	ArtifactQuery struct {
		List func(childComplexity int, selector *models.InputMapStringString) int
		Get  func(childComplexity int, name string) int
	}

	AwsDestinationSpec struct {
		LogicalName            func(childComplexity int) int
		InvocationStyle        func(childComplexity int) int
		ResponseTransformation func(childComplexity int) int
	}

	AwsLambdaFunction struct {
		LogicalName  func(childComplexity int) int
		FunctionName func(childComplexity int) int
		Qualifier    func(childComplexity int) int
	}

	AwsSecret struct {
		AccessKey func(childComplexity int) int
		SecretKey func(childComplexity int) int
	}

	AwsUpstreamSpec struct {
		Region    func(childComplexity int) int
		SecretRef func(childComplexity int) int
		Functions func(childComplexity int) int
	}

	AzureDestinationSpec struct {
		FunctionName func(childComplexity int) int
	}

	AzureFunction struct {
		FunctionName func(childComplexity int) int
		AuthLevel    func(childComplexity int) int
	}

	AzureSecret struct {
		ApiKeys func(childComplexity int) int
	}

	AzureUpstreamSpec struct {
		FunctionAppName func(childComplexity int) int
		SecretRef       func(childComplexity int) int
		Functions       func(childComplexity int) int
	}

	FieldResolver struct {
		FieldName func(childComplexity int) int
		Resolver  func(childComplexity int) int
	}

	GlooResolver struct {
		RequestTemplate  func(childComplexity int) int
		ResponseTemplate func(childComplexity int) int
		Destination      func(childComplexity int) int
	}

	GrpcDestinationSpec struct {
		Package    func(childComplexity int) int
		Service    func(childComplexity int) int
		Function   func(childComplexity int) int
		Parameters func(childComplexity int) int
	}

	GrpcService struct {
		PackageName   func(childComplexity int) int
		ServiceName   func(childComplexity int) int
		FunctionNames func(childComplexity int) int
	}

	GrpcServiceSpec struct {
		GrpcServices func(childComplexity int) int
	}

	KeyValueMatcher struct {
		Name    func(childComplexity int) int
		Value   func(childComplexity int) int
		IsRegex func(childComplexity int) int
	}

	KubeUpstreamSpec struct {
		ServiceName      func(childComplexity int) int
		ServiceNamespace func(childComplexity int) int
		ServicePort      func(childComplexity int) int
		Selector         func(childComplexity int) int
		ServiceSpec      func(childComplexity int) int
	}

	MapStringString struct {
		Values func(childComplexity int) int
	}

	Matcher struct {
		PathMatch       func(childComplexity int) int
		PathMatchType   func(childComplexity int) int
		Headers         func(childComplexity int) int
		QueryParameters func(childComplexity int) int
		Methods         func(childComplexity int) int
	}

	Metadata struct {
		Name            func(childComplexity int) int
		Namespace       func(childComplexity int) int
		ResourceVersion func(childComplexity int) int
		Labels          func(childComplexity int) int
		Annotations     func(childComplexity int) int
		Guid            func(childComplexity int) int
	}

	MultiDestination struct {
		Destinations func(childComplexity int) int
	}

	Mutation struct {
		Upstreams       func(childComplexity int, namespace string) int
		VirtualServices func(childComplexity int, namespace string) int
		ResolverMaps    func(childComplexity int, namespace string) int
		Schemas         func(childComplexity int, namespace string) int
		Secrets         func(childComplexity int, namespace string) int
		Artifacts       func(childComplexity int, namespace string) int
		Settings        func(childComplexity int) int
	}

	NodeJsresolver struct {
		Empty func(childComplexity int) int
	}

	OauthEndpoint struct {
		Url        func(childComplexity int) int
		ClientName func(childComplexity int) int
	}

	Query struct {
		Resource         func(childComplexity int, guid string) int
		GetOauthEndpoint func(childComplexity int) int
		Version          func(childComplexity int) int
		Upstreams        func(childComplexity int, namespace string) int
		VirtualServices  func(childComplexity int, namespace string) int
		ResolverMaps     func(childComplexity int, namespace string) int
		Schemas          func(childComplexity int, namespace string) int
		Secrets          func(childComplexity int, namespace string) int
		Artifacts        func(childComplexity int, namespace string) int
		Settings         func(childComplexity int) int
	}

	RequestTemplate struct {
		Verb    func(childComplexity int) int
		Path    func(childComplexity int) int
		Body    func(childComplexity int) int
		Headers func(childComplexity int) int
	}

	ResolverMap struct {
		Types    func(childComplexity int) int
		Metadata func(childComplexity int) int
		Status   func(childComplexity int) int
	}

	ResolverMapMutation struct {
		Create      func(childComplexity int, resolverMap models.InputResolverMap) int
		Update      func(childComplexity int, resolverMap models.InputResolverMap) int
		Delete      func(childComplexity int, name string) int
		SetResolver func(childComplexity int, resolverMapName string, resourceVersion string, typeName string, fieldName string, glooResolver models.InputGlooResolver) int
	}

	ResolverMapQuery struct {
		List func(childComplexity int, selector *models.InputMapStringString) int
		Get  func(childComplexity int, name string) int
	}

	ResourceRef struct {
		Name      func(childComplexity int) int
		Namespace func(childComplexity int) int
	}

	ResponseTemplate struct {
		Body    func(childComplexity int) int
		Headers func(childComplexity int) int
	}

	RestDestinationSpec struct {
		FunctionName func(childComplexity int) int
		Parameters   func(childComplexity int) int
	}

	RestServiceSpec struct {
		Functions func(childComplexity int) int
	}

	Route struct {
		Matcher     func(childComplexity int) int
		Destination func(childComplexity int) int
		Plugins     func(childComplexity int) int
	}

	RoutePlugins struct {
		Empty func(childComplexity int) int
	}

	Schema struct {
		InlineSchema func(childComplexity int) int
		Metadata     func(childComplexity int) int
		Status       func(childComplexity int) int
	}

	SchemaMutation struct {
		Create func(childComplexity int, schema models.InputSchema) int
		Update func(childComplexity int, schema models.InputSchema) int
		Delete func(childComplexity int, name string) int
	}

	SchemaQuery struct {
		List func(childComplexity int, selector *models.InputMapStringString) int
		Get  func(childComplexity int, name string) int
	}

	Secret struct {
		Kind     func(childComplexity int) int
		Metadata func(childComplexity int) int
	}

	SecretMutation struct {
		Create func(childComplexity int, secret models.InputSecret) int
		Update func(childComplexity int, secret models.InputSecret) int
		Delete func(childComplexity int, name string) int
	}

	SecretQuery struct {
		List func(childComplexity int, selector *models.InputMapStringString) int
		Get  func(childComplexity int, name string) int
	}

	Settings struct {
		WatchNamespaces func(childComplexity int) int
		RefreshRate     func(childComplexity int) int
		Metadata        func(childComplexity int) int
	}

	SettingsMutation struct {
		Update func(childComplexity int, settings models.InputSettings) int
	}

	SettingsQuery struct {
		Get func(childComplexity int) int
	}

	SingleDestination struct {
		Upstream        func(childComplexity int) int
		DestinationSpec func(childComplexity int) int
	}

	SqoopDestinationSpec struct {
		Schema     func(childComplexity int) int
		Playground func(childComplexity int) int
	}

	SqoopServiceSpec struct {
		Schemas func(childComplexity int) int
	}

	SslConfig struct {
		SecretRef func(childComplexity int) int
	}

	StaticHost struct {
		Addr func(childComplexity int) int
		Port func(childComplexity int) int
	}

	StaticUpstreamSpec struct {
		Hosts       func(childComplexity int) int
		ServiceSpec func(childComplexity int) int
		UseTls      func(childComplexity int) int
	}

	Status struct {
		State  func(childComplexity int) int
		Reason func(childComplexity int) int
	}

	Subscription struct {
		Upstreams       func(childComplexity int, namespace string, selector *models.InputMapStringString) int
		VirtualServices func(childComplexity int, namespace string, selector *models.InputMapStringString) int
	}

	TemplateResolver struct {
		InlineTemplate func(childComplexity int) int
	}

	TlsSecret struct {
		CertChain  func(childComplexity int) int
		PrivateKey func(childComplexity int) int
		RootCa     func(childComplexity int) int
	}

	Transformation struct {
		FunctionName func(childComplexity int) int
		Body         func(childComplexity int) int
		Headers      func(childComplexity int) int
	}

	TransformationParameters struct {
		Headers func(childComplexity int) int
		Path    func(childComplexity int) int
	}

	TypeResolver struct {
		TypeName func(childComplexity int) int
		Fields   func(childComplexity int) int
	}

	Upstream struct {
		Spec     func(childComplexity int) int
		Metadata func(childComplexity int) int
		Status   func(childComplexity int) int
	}

	UpstreamMutation struct {
		Create func(childComplexity int, upstream models.InputUpstream) int
		Update func(childComplexity int, upstream models.InputUpstream) int
		Delete func(childComplexity int, name string) int
	}

	UpstreamQuery struct {
		List func(childComplexity int, selector *models.InputMapStringString) int
		Get  func(childComplexity int, name string) int
	}

	Value struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	VirtualService struct {
		Domains   func(childComplexity int) int
		Routes    func(childComplexity int) int
		SslConfig func(childComplexity int) int
		Plugins   func(childComplexity int) int
		Metadata  func(childComplexity int) int
		Status    func(childComplexity int) int
	}

	VirtualServiceMutation struct {
		Create      func(childComplexity int, virtualService models.InputVirtualService) int
		Update      func(childComplexity int, name string, resourceVersion string, updates models.InputUpdateVirtualService) int
		Delete      func(childComplexity int, name string) int
		AddRoute    func(childComplexity int, virtualServiceName string, resourceVersion string, index int, route models.InputRoute) int
		UpdateRoute func(childComplexity int, virtualServiceName string, resourceVersion string, index int, route models.InputRoute) int
		DeleteRoute func(childComplexity int, virtualServiceName string, resourceVersion string, index int) int
		SwapRoutes  func(childComplexity int, virtualServiceName string, resourceVersion string, index1 int, index2 int) int
		ShiftRoutes func(childComplexity int, virtualServiceName string, resourceVersion string, fromIndex int, toIndex int) int
	}

	VirtualServicePlugins struct {
		Empty func(childComplexity int) int
	}

	VirtualServiceQuery struct {
		List func(childComplexity int, selector *models.InputMapStringString) int
		Get  func(childComplexity int, name string) int
	}

	WeightedDestination struct {
		Destination func(childComplexity int) int
		Weight      func(childComplexity int) int
	}
}

type ArtifactMutationResolver interface {
	Create(ctx context.Context, obj *customtypes.ArtifactMutation, artifact models.InputArtifact) (*models.Artifact, error)
	Update(ctx context.Context, obj *customtypes.ArtifactMutation, artifact models.InputArtifact) (*models.Artifact, error)
	Delete(ctx context.Context, obj *customtypes.ArtifactMutation, name string) (*models.Artifact, error)
}
type ArtifactQueryResolver interface {
	List(ctx context.Context, obj *customtypes.ArtifactQuery, selector *models.InputMapStringString) ([]*models.Artifact, error)
	Get(ctx context.Context, obj *customtypes.ArtifactQuery, name string) (*models.Artifact, error)
}
type MutationResolver interface {
	Upstreams(ctx context.Context, namespace string) (customtypes.UpstreamMutation, error)
	VirtualServices(ctx context.Context, namespace string) (customtypes.VirtualServiceMutation, error)
	ResolverMaps(ctx context.Context, namespace string) (customtypes.ResolverMapMutation, error)
	Schemas(ctx context.Context, namespace string) (customtypes.SchemaMutation, error)
	Secrets(ctx context.Context, namespace string) (customtypes.SecretMutation, error)
	Artifacts(ctx context.Context, namespace string) (customtypes.ArtifactMutation, error)
	Settings(ctx context.Context) (customtypes.SettingsMutation, error)
}
type QueryResolver interface {
	Resource(ctx context.Context, guid string) (models.Resource, error)
	GetOAuthEndpoint(ctx context.Context) (models.OAuthEndpoint, error)
	Version(ctx context.Context) (string, error)
	Upstreams(ctx context.Context, namespace string) (customtypes.UpstreamQuery, error)
	VirtualServices(ctx context.Context, namespace string) (customtypes.VirtualServiceQuery, error)
	ResolverMaps(ctx context.Context, namespace string) (customtypes.ResolverMapQuery, error)
	Schemas(ctx context.Context, namespace string) (customtypes.SchemaQuery, error)
	Secrets(ctx context.Context, namespace string) (customtypes.SecretQuery, error)
	Artifacts(ctx context.Context, namespace string) (customtypes.ArtifactQuery, error)
	Settings(ctx context.Context) (customtypes.SettingsQuery, error)
}
type ResolverMapMutationResolver interface {
	Create(ctx context.Context, obj *customtypes.ResolverMapMutation, resolverMap models.InputResolverMap) (*models.ResolverMap, error)
	Update(ctx context.Context, obj *customtypes.ResolverMapMutation, resolverMap models.InputResolverMap) (*models.ResolverMap, error)
	Delete(ctx context.Context, obj *customtypes.ResolverMapMutation, name string) (*models.ResolverMap, error)
	SetResolver(ctx context.Context, obj *customtypes.ResolverMapMutation, resolverMapName string, resourceVersion string, typeName string, fieldName string, glooResolver models.InputGlooResolver) (*models.ResolverMap, error)
}
type ResolverMapQueryResolver interface {
	List(ctx context.Context, obj *customtypes.ResolverMapQuery, selector *models.InputMapStringString) ([]*models.ResolverMap, error)
	Get(ctx context.Context, obj *customtypes.ResolverMapQuery, name string) (*models.ResolverMap, error)
}
type SchemaMutationResolver interface {
	Create(ctx context.Context, obj *customtypes.SchemaMutation, schema models.InputSchema) (*models.Schema, error)
	Update(ctx context.Context, obj *customtypes.SchemaMutation, schema models.InputSchema) (*models.Schema, error)
	Delete(ctx context.Context, obj *customtypes.SchemaMutation, name string) (*models.Schema, error)
}
type SchemaQueryResolver interface {
	List(ctx context.Context, obj *customtypes.SchemaQuery, selector *models.InputMapStringString) ([]*models.Schema, error)
	Get(ctx context.Context, obj *customtypes.SchemaQuery, name string) (*models.Schema, error)
}
type SecretMutationResolver interface {
	Create(ctx context.Context, obj *customtypes.SecretMutation, secret models.InputSecret) (*models.Secret, error)
	Update(ctx context.Context, obj *customtypes.SecretMutation, secret models.InputSecret) (*models.Secret, error)
	Delete(ctx context.Context, obj *customtypes.SecretMutation, name string) (*models.Secret, error)
}
type SecretQueryResolver interface {
	List(ctx context.Context, obj *customtypes.SecretQuery, selector *models.InputMapStringString) ([]*models.Secret, error)
	Get(ctx context.Context, obj *customtypes.SecretQuery, name string) (*models.Secret, error)
}
type SettingsMutationResolver interface {
	Update(ctx context.Context, obj *customtypes.SettingsMutation, settings models.InputSettings) (*models.Settings, error)
}
type SettingsQueryResolver interface {
	Get(ctx context.Context, obj *customtypes.SettingsQuery) (*models.Settings, error)
}
type SubscriptionResolver interface {
	Upstreams(ctx context.Context, namespace string, selector *models.InputMapStringString) (<-chan []*models.Upstream, error)
	VirtualServices(ctx context.Context, namespace string, selector *models.InputMapStringString) (<-chan []*models.VirtualService, error)
}
type UpstreamMutationResolver interface {
	Create(ctx context.Context, obj *customtypes.UpstreamMutation, upstream models.InputUpstream) (*models.Upstream, error)
	Update(ctx context.Context, obj *customtypes.UpstreamMutation, upstream models.InputUpstream) (*models.Upstream, error)
	Delete(ctx context.Context, obj *customtypes.UpstreamMutation, name string) (*models.Upstream, error)
}
type UpstreamQueryResolver interface {
	List(ctx context.Context, obj *customtypes.UpstreamQuery, selector *models.InputMapStringString) ([]*models.Upstream, error)
	Get(ctx context.Context, obj *customtypes.UpstreamQuery, name string) (*models.Upstream, error)
}
type VirtualServiceMutationResolver interface {
	Create(ctx context.Context, obj *customtypes.VirtualServiceMutation, virtualService models.InputVirtualService) (*models.VirtualService, error)
	Update(ctx context.Context, obj *customtypes.VirtualServiceMutation, name string, resourceVersion string, updates models.InputUpdateVirtualService) (*models.VirtualService, error)
	Delete(ctx context.Context, obj *customtypes.VirtualServiceMutation, name string) (*models.VirtualService, error)
	AddRoute(ctx context.Context, obj *customtypes.VirtualServiceMutation, virtualServiceName string, resourceVersion string, index int, route models.InputRoute) (*models.VirtualService, error)
	UpdateRoute(ctx context.Context, obj *customtypes.VirtualServiceMutation, virtualServiceName string, resourceVersion string, index int, route models.InputRoute) (*models.VirtualService, error)
	DeleteRoute(ctx context.Context, obj *customtypes.VirtualServiceMutation, virtualServiceName string, resourceVersion string, index int) (*models.VirtualService, error)
	SwapRoutes(ctx context.Context, obj *customtypes.VirtualServiceMutation, virtualServiceName string, resourceVersion string, index1 int, index2 int) (*models.VirtualService, error)
	ShiftRoutes(ctx context.Context, obj *customtypes.VirtualServiceMutation, virtualServiceName string, resourceVersion string, fromIndex int, toIndex int) (*models.VirtualService, error)
}
type VirtualServiceQueryResolver interface {
	List(ctx context.Context, obj *customtypes.VirtualServiceQuery, selector *models.InputMapStringString) ([]*models.VirtualService, error)
	Get(ctx context.Context, obj *customtypes.VirtualServiceQuery, name string) (*models.VirtualService, error)
}

func field_ArtifactMutation_create_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 models.InputArtifact
	if tmp, ok := rawArgs["artifact"]; ok {
		var err error
		arg0, err = UnmarshalInputArtifact(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["artifact"] = arg0
	return args, nil

}

func field_ArtifactMutation_update_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 models.InputArtifact
	if tmp, ok := rawArgs["artifact"]; ok {
		var err error
		arg0, err = UnmarshalInputArtifact(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["artifact"] = arg0
	return args, nil

}

func field_ArtifactMutation_delete_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_ArtifactQuery_list_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *models.InputMapStringString
	if tmp, ok := rawArgs["selector"]; ok {
		var err error
		var ptr1 models.InputMapStringString
		if tmp != nil {
			ptr1, err = UnmarshalInputMapStringString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["selector"] = arg0
	return args, nil

}

func field_ArtifactQuery_get_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_Mutation_upstreams_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Mutation_virtualServices_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Mutation_resolverMaps_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Mutation_schemas_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Mutation_secrets_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Mutation_artifacts_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Query_resource_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["guid"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["guid"] = arg0
	return args, nil

}

func field_Query_upstreams_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Query_virtualServices_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Query_resolverMaps_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Query_schemas_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Query_secrets_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Query_artifacts_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Query___type_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_ResolverMapMutation_create_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 models.InputResolverMap
	if tmp, ok := rawArgs["resolverMap"]; ok {
		var err error
		arg0, err = UnmarshalInputResolverMap(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resolverMap"] = arg0
	return args, nil

}

func field_ResolverMapMutation_update_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 models.InputResolverMap
	if tmp, ok := rawArgs["resolverMap"]; ok {
		var err error
		arg0, err = UnmarshalInputResolverMap(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resolverMap"] = arg0
	return args, nil

}

func field_ResolverMapMutation_delete_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_ResolverMapMutation_setResolver_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["resolverMapName"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resolverMapName"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["resourceVersion"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resourceVersion"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["typeName"]; ok {
		var err error
		arg2, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["typeName"] = arg2
	var arg3 string
	if tmp, ok := rawArgs["fieldName"]; ok {
		var err error
		arg3, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["fieldName"] = arg3
	var arg4 models.InputGlooResolver
	if tmp, ok := rawArgs["glooResolver"]; ok {
		var err error
		arg4, err = UnmarshalInputGlooResolver(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["glooResolver"] = arg4
	return args, nil

}

func field_ResolverMapQuery_list_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *models.InputMapStringString
	if tmp, ok := rawArgs["selector"]; ok {
		var err error
		var ptr1 models.InputMapStringString
		if tmp != nil {
			ptr1, err = UnmarshalInputMapStringString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["selector"] = arg0
	return args, nil

}

func field_ResolverMapQuery_get_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_SchemaMutation_create_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 models.InputSchema
	if tmp, ok := rawArgs["schema"]; ok {
		var err error
		arg0, err = UnmarshalInputSchema(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["schema"] = arg0
	return args, nil

}

func field_SchemaMutation_update_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 models.InputSchema
	if tmp, ok := rawArgs["schema"]; ok {
		var err error
		arg0, err = UnmarshalInputSchema(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["schema"] = arg0
	return args, nil

}

func field_SchemaMutation_delete_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_SchemaQuery_list_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *models.InputMapStringString
	if tmp, ok := rawArgs["selector"]; ok {
		var err error
		var ptr1 models.InputMapStringString
		if tmp != nil {
			ptr1, err = UnmarshalInputMapStringString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["selector"] = arg0
	return args, nil

}

func field_SchemaQuery_get_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_SecretMutation_create_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 models.InputSecret
	if tmp, ok := rawArgs["secret"]; ok {
		var err error
		arg0, err = UnmarshalInputSecret(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["secret"] = arg0
	return args, nil

}

func field_SecretMutation_update_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 models.InputSecret
	if tmp, ok := rawArgs["secret"]; ok {
		var err error
		arg0, err = UnmarshalInputSecret(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["secret"] = arg0
	return args, nil

}

func field_SecretMutation_delete_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_SecretQuery_list_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *models.InputMapStringString
	if tmp, ok := rawArgs["selector"]; ok {
		var err error
		var ptr1 models.InputMapStringString
		if tmp != nil {
			ptr1, err = UnmarshalInputMapStringString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["selector"] = arg0
	return args, nil

}

func field_SecretQuery_get_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_SettingsMutation_update_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 models.InputSettings
	if tmp, ok := rawArgs["settings"]; ok {
		var err error
		arg0, err = UnmarshalInputSettings(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["settings"] = arg0
	return args, nil

}

func field_Subscription_upstreams_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *models.InputMapStringString
	if tmp, ok := rawArgs["selector"]; ok {
		var err error
		var ptr1 models.InputMapStringString
		if tmp != nil {
			ptr1, err = UnmarshalInputMapStringString(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["selector"] = arg1
	return args, nil

}

func field_Subscription_virtualServices_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *models.InputMapStringString
	if tmp, ok := rawArgs["selector"]; ok {
		var err error
		var ptr1 models.InputMapStringString
		if tmp != nil {
			ptr1, err = UnmarshalInputMapStringString(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["selector"] = arg1
	return args, nil

}

func field_UpstreamMutation_create_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 models.InputUpstream
	if tmp, ok := rawArgs["upstream"]; ok {
		var err error
		arg0, err = UnmarshalInputUpstream(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["upstream"] = arg0
	return args, nil

}

func field_UpstreamMutation_update_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 models.InputUpstream
	if tmp, ok := rawArgs["upstream"]; ok {
		var err error
		arg0, err = UnmarshalInputUpstream(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["upstream"] = arg0
	return args, nil

}

func field_UpstreamMutation_delete_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_UpstreamQuery_list_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *models.InputMapStringString
	if tmp, ok := rawArgs["selector"]; ok {
		var err error
		var ptr1 models.InputMapStringString
		if tmp != nil {
			ptr1, err = UnmarshalInputMapStringString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["selector"] = arg0
	return args, nil

}

func field_UpstreamQuery_get_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_VirtualServiceMutation_create_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 models.InputVirtualService
	if tmp, ok := rawArgs["virtualService"]; ok {
		var err error
		arg0, err = UnmarshalInputVirtualService(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["virtualService"] = arg0
	return args, nil

}

func field_VirtualServiceMutation_update_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["resourceVersion"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resourceVersion"] = arg1
	var arg2 models.InputUpdateVirtualService
	if tmp, ok := rawArgs["updates"]; ok {
		var err error
		arg2, err = UnmarshalInputUpdateVirtualService(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["updates"] = arg2
	return args, nil

}

func field_VirtualServiceMutation_delete_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_VirtualServiceMutation_addRoute_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["virtualServiceName"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["virtualServiceName"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["resourceVersion"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resourceVersion"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["index"]; ok {
		var err error
		arg2, err = graphql.UnmarshalInt(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["index"] = arg2
	var arg3 models.InputRoute
	if tmp, ok := rawArgs["route"]; ok {
		var err error
		arg3, err = UnmarshalInputRoute(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["route"] = arg3
	return args, nil

}

func field_VirtualServiceMutation_updateRoute_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["virtualServiceName"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["virtualServiceName"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["resourceVersion"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resourceVersion"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["index"]; ok {
		var err error
		arg2, err = graphql.UnmarshalInt(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["index"] = arg2
	var arg3 models.InputRoute
	if tmp, ok := rawArgs["route"]; ok {
		var err error
		arg3, err = UnmarshalInputRoute(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["route"] = arg3
	return args, nil

}

func field_VirtualServiceMutation_deleteRoute_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["virtualServiceName"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["virtualServiceName"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["resourceVersion"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resourceVersion"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["index"]; ok {
		var err error
		arg2, err = graphql.UnmarshalInt(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["index"] = arg2
	return args, nil

}

func field_VirtualServiceMutation_swapRoutes_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["virtualServiceName"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["virtualServiceName"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["resourceVersion"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resourceVersion"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["index1"]; ok {
		var err error
		arg2, err = graphql.UnmarshalInt(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["index1"] = arg2
	var arg3 int
	if tmp, ok := rawArgs["index2"]; ok {
		var err error
		arg3, err = graphql.UnmarshalInt(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["index2"] = arg3
	return args, nil

}

func field_VirtualServiceMutation_shiftRoutes_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["virtualServiceName"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["virtualServiceName"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["resourceVersion"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resourceVersion"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["fromIndex"]; ok {
		var err error
		arg2, err = graphql.UnmarshalInt(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["fromIndex"] = arg2
	var arg3 int
	if tmp, ok := rawArgs["toIndex"]; ok {
		var err error
		arg3, err = graphql.UnmarshalInt(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["toIndex"] = arg3
	return args, nil

}

func field_VirtualServiceQuery_list_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *models.InputMapStringString
	if tmp, ok := rawArgs["selector"]; ok {
		var err error
		var ptr1 models.InputMapStringString
		if tmp != nil {
			ptr1, err = UnmarshalInputMapStringString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["selector"] = arg0
	return args, nil

}

func field_VirtualServiceQuery_get_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field___Type_fields_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil

}

func field___Type_enumValues_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil

}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	switch typeName + "." + field {

	case "Artifact.data":
		if e.complexity.Artifact.Data == nil {
			break
		}

		return e.complexity.Artifact.Data(childComplexity), true

	case "Artifact.metadata":
		if e.complexity.Artifact.Metadata == nil {
			break
		}

		return e.complexity.Artifact.Metadata(childComplexity), true

	case "ArtifactMutation.create":
		if e.complexity.ArtifactMutation.Create == nil {
			break
		}

		args, err := field_ArtifactMutation_create_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ArtifactMutation.Create(childComplexity, args["artifact"].(models.InputArtifact)), true

	case "ArtifactMutation.update":
		if e.complexity.ArtifactMutation.Update == nil {
			break
		}

		args, err := field_ArtifactMutation_update_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ArtifactMutation.Update(childComplexity, args["artifact"].(models.InputArtifact)), true

	case "ArtifactMutation.delete":
		if e.complexity.ArtifactMutation.Delete == nil {
			break
		}

		args, err := field_ArtifactMutation_delete_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ArtifactMutation.Delete(childComplexity, args["name"].(string)), true

	case "ArtifactQuery.list":
		if e.complexity.ArtifactQuery.List == nil {
			break
		}

		args, err := field_ArtifactQuery_list_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ArtifactQuery.List(childComplexity, args["selector"].(*models.InputMapStringString)), true

	case "ArtifactQuery.get":
		if e.complexity.ArtifactQuery.Get == nil {
			break
		}

		args, err := field_ArtifactQuery_get_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ArtifactQuery.Get(childComplexity, args["name"].(string)), true

	case "AwsDestinationSpec.logicalName":
		if e.complexity.AwsDestinationSpec.LogicalName == nil {
			break
		}

		return e.complexity.AwsDestinationSpec.LogicalName(childComplexity), true

	case "AwsDestinationSpec.invocationStyle":
		if e.complexity.AwsDestinationSpec.InvocationStyle == nil {
			break
		}

		return e.complexity.AwsDestinationSpec.InvocationStyle(childComplexity), true

	case "AwsDestinationSpec.responseTransformation":
		if e.complexity.AwsDestinationSpec.ResponseTransformation == nil {
			break
		}

		return e.complexity.AwsDestinationSpec.ResponseTransformation(childComplexity), true

	case "AwsLambdaFunction.logicalName":
		if e.complexity.AwsLambdaFunction.LogicalName == nil {
			break
		}

		return e.complexity.AwsLambdaFunction.LogicalName(childComplexity), true

	case "AwsLambdaFunction.functionName":
		if e.complexity.AwsLambdaFunction.FunctionName == nil {
			break
		}

		return e.complexity.AwsLambdaFunction.FunctionName(childComplexity), true

	case "AwsLambdaFunction.qualifier":
		if e.complexity.AwsLambdaFunction.Qualifier == nil {
			break
		}

		return e.complexity.AwsLambdaFunction.Qualifier(childComplexity), true

	case "AwsSecret.accessKey":
		if e.complexity.AwsSecret.AccessKey == nil {
			break
		}

		return e.complexity.AwsSecret.AccessKey(childComplexity), true

	case "AwsSecret.secretKey":
		if e.complexity.AwsSecret.SecretKey == nil {
			break
		}

		return e.complexity.AwsSecret.SecretKey(childComplexity), true

	case "AwsUpstreamSpec.region":
		if e.complexity.AwsUpstreamSpec.Region == nil {
			break
		}

		return e.complexity.AwsUpstreamSpec.Region(childComplexity), true

	case "AwsUpstreamSpec.secretRef":
		if e.complexity.AwsUpstreamSpec.SecretRef == nil {
			break
		}

		return e.complexity.AwsUpstreamSpec.SecretRef(childComplexity), true

	case "AwsUpstreamSpec.functions":
		if e.complexity.AwsUpstreamSpec.Functions == nil {
			break
		}

		return e.complexity.AwsUpstreamSpec.Functions(childComplexity), true

	case "AzureDestinationSpec.functionName":
		if e.complexity.AzureDestinationSpec.FunctionName == nil {
			break
		}

		return e.complexity.AzureDestinationSpec.FunctionName(childComplexity), true

	case "AzureFunction.functionName":
		if e.complexity.AzureFunction.FunctionName == nil {
			break
		}

		return e.complexity.AzureFunction.FunctionName(childComplexity), true

	case "AzureFunction.authLevel":
		if e.complexity.AzureFunction.AuthLevel == nil {
			break
		}

		return e.complexity.AzureFunction.AuthLevel(childComplexity), true

	case "AzureSecret.apiKeys":
		if e.complexity.AzureSecret.ApiKeys == nil {
			break
		}

		return e.complexity.AzureSecret.ApiKeys(childComplexity), true

	case "AzureUpstreamSpec.functionAppName":
		if e.complexity.AzureUpstreamSpec.FunctionAppName == nil {
			break
		}

		return e.complexity.AzureUpstreamSpec.FunctionAppName(childComplexity), true

	case "AzureUpstreamSpec.secretRef":
		if e.complexity.AzureUpstreamSpec.SecretRef == nil {
			break
		}

		return e.complexity.AzureUpstreamSpec.SecretRef(childComplexity), true

	case "AzureUpstreamSpec.functions":
		if e.complexity.AzureUpstreamSpec.Functions == nil {
			break
		}

		return e.complexity.AzureUpstreamSpec.Functions(childComplexity), true

	case "FieldResolver.fieldName":
		if e.complexity.FieldResolver.FieldName == nil {
			break
		}

		return e.complexity.FieldResolver.FieldName(childComplexity), true

	case "FieldResolver.resolver":
		if e.complexity.FieldResolver.Resolver == nil {
			break
		}

		return e.complexity.FieldResolver.Resolver(childComplexity), true

	case "GlooResolver.requestTemplate":
		if e.complexity.GlooResolver.RequestTemplate == nil {
			break
		}

		return e.complexity.GlooResolver.RequestTemplate(childComplexity), true

	case "GlooResolver.responseTemplate":
		if e.complexity.GlooResolver.ResponseTemplate == nil {
			break
		}

		return e.complexity.GlooResolver.ResponseTemplate(childComplexity), true

	case "GlooResolver.destination":
		if e.complexity.GlooResolver.Destination == nil {
			break
		}

		return e.complexity.GlooResolver.Destination(childComplexity), true

	case "GrpcDestinationSpec.package":
		if e.complexity.GrpcDestinationSpec.Package == nil {
			break
		}

		return e.complexity.GrpcDestinationSpec.Package(childComplexity), true

	case "GrpcDestinationSpec.service":
		if e.complexity.GrpcDestinationSpec.Service == nil {
			break
		}

		return e.complexity.GrpcDestinationSpec.Service(childComplexity), true

	case "GrpcDestinationSpec.function":
		if e.complexity.GrpcDestinationSpec.Function == nil {
			break
		}

		return e.complexity.GrpcDestinationSpec.Function(childComplexity), true

	case "GrpcDestinationSpec.parameters":
		if e.complexity.GrpcDestinationSpec.Parameters == nil {
			break
		}

		return e.complexity.GrpcDestinationSpec.Parameters(childComplexity), true

	case "GrpcService.packageName":
		if e.complexity.GrpcService.PackageName == nil {
			break
		}

		return e.complexity.GrpcService.PackageName(childComplexity), true

	case "GrpcService.serviceName":
		if e.complexity.GrpcService.ServiceName == nil {
			break
		}

		return e.complexity.GrpcService.ServiceName(childComplexity), true

	case "GrpcService.functionNames":
		if e.complexity.GrpcService.FunctionNames == nil {
			break
		}

		return e.complexity.GrpcService.FunctionNames(childComplexity), true

	case "GrpcServiceSpec.grpcServices":
		if e.complexity.GrpcServiceSpec.GrpcServices == nil {
			break
		}

		return e.complexity.GrpcServiceSpec.GrpcServices(childComplexity), true

	case "KeyValueMatcher.name":
		if e.complexity.KeyValueMatcher.Name == nil {
			break
		}

		return e.complexity.KeyValueMatcher.Name(childComplexity), true

	case "KeyValueMatcher.value":
		if e.complexity.KeyValueMatcher.Value == nil {
			break
		}

		return e.complexity.KeyValueMatcher.Value(childComplexity), true

	case "KeyValueMatcher.isRegex":
		if e.complexity.KeyValueMatcher.IsRegex == nil {
			break
		}

		return e.complexity.KeyValueMatcher.IsRegex(childComplexity), true

	case "KubeUpstreamSpec.serviceName":
		if e.complexity.KubeUpstreamSpec.ServiceName == nil {
			break
		}

		return e.complexity.KubeUpstreamSpec.ServiceName(childComplexity), true

	case "KubeUpstreamSpec.serviceNamespace":
		if e.complexity.KubeUpstreamSpec.ServiceNamespace == nil {
			break
		}

		return e.complexity.KubeUpstreamSpec.ServiceNamespace(childComplexity), true

	case "KubeUpstreamSpec.servicePort":
		if e.complexity.KubeUpstreamSpec.ServicePort == nil {
			break
		}

		return e.complexity.KubeUpstreamSpec.ServicePort(childComplexity), true

	case "KubeUpstreamSpec.selector":
		if e.complexity.KubeUpstreamSpec.Selector == nil {
			break
		}

		return e.complexity.KubeUpstreamSpec.Selector(childComplexity), true

	case "KubeUpstreamSpec.serviceSpec":
		if e.complexity.KubeUpstreamSpec.ServiceSpec == nil {
			break
		}

		return e.complexity.KubeUpstreamSpec.ServiceSpec(childComplexity), true

	case "MapStringString.values":
		if e.complexity.MapStringString.Values == nil {
			break
		}

		return e.complexity.MapStringString.Values(childComplexity), true

	case "Matcher.pathMatch":
		if e.complexity.Matcher.PathMatch == nil {
			break
		}

		return e.complexity.Matcher.PathMatch(childComplexity), true

	case "Matcher.pathMatchType":
		if e.complexity.Matcher.PathMatchType == nil {
			break
		}

		return e.complexity.Matcher.PathMatchType(childComplexity), true

	case "Matcher.headers":
		if e.complexity.Matcher.Headers == nil {
			break
		}

		return e.complexity.Matcher.Headers(childComplexity), true

	case "Matcher.queryParameters":
		if e.complexity.Matcher.QueryParameters == nil {
			break
		}

		return e.complexity.Matcher.QueryParameters(childComplexity), true

	case "Matcher.methods":
		if e.complexity.Matcher.Methods == nil {
			break
		}

		return e.complexity.Matcher.Methods(childComplexity), true

	case "Metadata.name":
		if e.complexity.Metadata.Name == nil {
			break
		}

		return e.complexity.Metadata.Name(childComplexity), true

	case "Metadata.namespace":
		if e.complexity.Metadata.Namespace == nil {
			break
		}

		return e.complexity.Metadata.Namespace(childComplexity), true

	case "Metadata.resourceVersion":
		if e.complexity.Metadata.ResourceVersion == nil {
			break
		}

		return e.complexity.Metadata.ResourceVersion(childComplexity), true

	case "Metadata.labels":
		if e.complexity.Metadata.Labels == nil {
			break
		}

		return e.complexity.Metadata.Labels(childComplexity), true

	case "Metadata.annotations":
		if e.complexity.Metadata.Annotations == nil {
			break
		}

		return e.complexity.Metadata.Annotations(childComplexity), true

	case "Metadata.guid":
		if e.complexity.Metadata.Guid == nil {
			break
		}

		return e.complexity.Metadata.Guid(childComplexity), true

	case "MultiDestination.destinations":
		if e.complexity.MultiDestination.Destinations == nil {
			break
		}

		return e.complexity.MultiDestination.Destinations(childComplexity), true

	case "Mutation.upstreams":
		if e.complexity.Mutation.Upstreams == nil {
			break
		}

		args, err := field_Mutation_upstreams_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Upstreams(childComplexity, args["namespace"].(string)), true

	case "Mutation.virtualServices":
		if e.complexity.Mutation.VirtualServices == nil {
			break
		}

		args, err := field_Mutation_virtualServices_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.VirtualServices(childComplexity, args["namespace"].(string)), true

	case "Mutation.resolverMaps":
		if e.complexity.Mutation.ResolverMaps == nil {
			break
		}

		args, err := field_Mutation_resolverMaps_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ResolverMaps(childComplexity, args["namespace"].(string)), true

	case "Mutation.schemas":
		if e.complexity.Mutation.Schemas == nil {
			break
		}

		args, err := field_Mutation_schemas_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Schemas(childComplexity, args["namespace"].(string)), true

	case "Mutation.secrets":
		if e.complexity.Mutation.Secrets == nil {
			break
		}

		args, err := field_Mutation_secrets_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Secrets(childComplexity, args["namespace"].(string)), true

	case "Mutation.artifacts":
		if e.complexity.Mutation.Artifacts == nil {
			break
		}

		args, err := field_Mutation_artifacts_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Artifacts(childComplexity, args["namespace"].(string)), true

	case "Mutation.settings":
		if e.complexity.Mutation.Settings == nil {
			break
		}

		return e.complexity.Mutation.Settings(childComplexity), true

	case "NodeJSResolver.empty":
		if e.complexity.NodeJsresolver.Empty == nil {
			break
		}

		return e.complexity.NodeJsresolver.Empty(childComplexity), true

	case "OAuthEndpoint.url":
		if e.complexity.OauthEndpoint.Url == nil {
			break
		}

		return e.complexity.OauthEndpoint.Url(childComplexity), true

	case "OAuthEndpoint.clientName":
		if e.complexity.OauthEndpoint.ClientName == nil {
			break
		}

		return e.complexity.OauthEndpoint.ClientName(childComplexity), true

	case "Query.resource":
		if e.complexity.Query.Resource == nil {
			break
		}

		args, err := field_Query_resource_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Resource(childComplexity, args["guid"].(string)), true

	case "Query.getOAuthEndpoint":
		if e.complexity.Query.GetOauthEndpoint == nil {
			break
		}

		return e.complexity.Query.GetOauthEndpoint(childComplexity), true

	case "Query.version":
		if e.complexity.Query.Version == nil {
			break
		}

		return e.complexity.Query.Version(childComplexity), true

	case "Query.upstreams":
		if e.complexity.Query.Upstreams == nil {
			break
		}

		args, err := field_Query_upstreams_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Upstreams(childComplexity, args["namespace"].(string)), true

	case "Query.virtualServices":
		if e.complexity.Query.VirtualServices == nil {
			break
		}

		args, err := field_Query_virtualServices_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.VirtualServices(childComplexity, args["namespace"].(string)), true

	case "Query.resolverMaps":
		if e.complexity.Query.ResolverMaps == nil {
			break
		}

		args, err := field_Query_resolverMaps_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ResolverMaps(childComplexity, args["namespace"].(string)), true

	case "Query.schemas":
		if e.complexity.Query.Schemas == nil {
			break
		}

		args, err := field_Query_schemas_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Schemas(childComplexity, args["namespace"].(string)), true

	case "Query.secrets":
		if e.complexity.Query.Secrets == nil {
			break
		}

		args, err := field_Query_secrets_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Secrets(childComplexity, args["namespace"].(string)), true

	case "Query.artifacts":
		if e.complexity.Query.Artifacts == nil {
			break
		}

		args, err := field_Query_artifacts_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Artifacts(childComplexity, args["namespace"].(string)), true

	case "Query.settings":
		if e.complexity.Query.Settings == nil {
			break
		}

		return e.complexity.Query.Settings(childComplexity), true

	case "RequestTemplate.verb":
		if e.complexity.RequestTemplate.Verb == nil {
			break
		}

		return e.complexity.RequestTemplate.Verb(childComplexity), true

	case "RequestTemplate.path":
		if e.complexity.RequestTemplate.Path == nil {
			break
		}

		return e.complexity.RequestTemplate.Path(childComplexity), true

	case "RequestTemplate.body":
		if e.complexity.RequestTemplate.Body == nil {
			break
		}

		return e.complexity.RequestTemplate.Body(childComplexity), true

	case "RequestTemplate.headers":
		if e.complexity.RequestTemplate.Headers == nil {
			break
		}

		return e.complexity.RequestTemplate.Headers(childComplexity), true

	case "ResolverMap.types":
		if e.complexity.ResolverMap.Types == nil {
			break
		}

		return e.complexity.ResolverMap.Types(childComplexity), true

	case "ResolverMap.metadata":
		if e.complexity.ResolverMap.Metadata == nil {
			break
		}

		return e.complexity.ResolverMap.Metadata(childComplexity), true

	case "ResolverMap.status":
		if e.complexity.ResolverMap.Status == nil {
			break
		}

		return e.complexity.ResolverMap.Status(childComplexity), true

	case "ResolverMapMutation.create":
		if e.complexity.ResolverMapMutation.Create == nil {
			break
		}

		args, err := field_ResolverMapMutation_create_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ResolverMapMutation.Create(childComplexity, args["resolverMap"].(models.InputResolverMap)), true

	case "ResolverMapMutation.update":
		if e.complexity.ResolverMapMutation.Update == nil {
			break
		}

		args, err := field_ResolverMapMutation_update_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ResolverMapMutation.Update(childComplexity, args["resolverMap"].(models.InputResolverMap)), true

	case "ResolverMapMutation.delete":
		if e.complexity.ResolverMapMutation.Delete == nil {
			break
		}

		args, err := field_ResolverMapMutation_delete_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ResolverMapMutation.Delete(childComplexity, args["name"].(string)), true

	case "ResolverMapMutation.setResolver":
		if e.complexity.ResolverMapMutation.SetResolver == nil {
			break
		}

		args, err := field_ResolverMapMutation_setResolver_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ResolverMapMutation.SetResolver(childComplexity, args["resolverMapName"].(string), args["resourceVersion"].(string), args["typeName"].(string), args["fieldName"].(string), args["glooResolver"].(models.InputGlooResolver)), true

	case "ResolverMapQuery.list":
		if e.complexity.ResolverMapQuery.List == nil {
			break
		}

		args, err := field_ResolverMapQuery_list_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ResolverMapQuery.List(childComplexity, args["selector"].(*models.InputMapStringString)), true

	case "ResolverMapQuery.get":
		if e.complexity.ResolverMapQuery.Get == nil {
			break
		}

		args, err := field_ResolverMapQuery_get_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ResolverMapQuery.Get(childComplexity, args["name"].(string)), true

	case "ResourceRef.name":
		if e.complexity.ResourceRef.Name == nil {
			break
		}

		return e.complexity.ResourceRef.Name(childComplexity), true

	case "ResourceRef.namespace":
		if e.complexity.ResourceRef.Namespace == nil {
			break
		}

		return e.complexity.ResourceRef.Namespace(childComplexity), true

	case "ResponseTemplate.body":
		if e.complexity.ResponseTemplate.Body == nil {
			break
		}

		return e.complexity.ResponseTemplate.Body(childComplexity), true

	case "ResponseTemplate.headers":
		if e.complexity.ResponseTemplate.Headers == nil {
			break
		}

		return e.complexity.ResponseTemplate.Headers(childComplexity), true

	case "RestDestinationSpec.functionName":
		if e.complexity.RestDestinationSpec.FunctionName == nil {
			break
		}

		return e.complexity.RestDestinationSpec.FunctionName(childComplexity), true

	case "RestDestinationSpec.parameters":
		if e.complexity.RestDestinationSpec.Parameters == nil {
			break
		}

		return e.complexity.RestDestinationSpec.Parameters(childComplexity), true

	case "RestServiceSpec.functions":
		if e.complexity.RestServiceSpec.Functions == nil {
			break
		}

		return e.complexity.RestServiceSpec.Functions(childComplexity), true

	case "Route.matcher":
		if e.complexity.Route.Matcher == nil {
			break
		}

		return e.complexity.Route.Matcher(childComplexity), true

	case "Route.destination":
		if e.complexity.Route.Destination == nil {
			break
		}

		return e.complexity.Route.Destination(childComplexity), true

	case "Route.plugins":
		if e.complexity.Route.Plugins == nil {
			break
		}

		return e.complexity.Route.Plugins(childComplexity), true

	case "RoutePlugins.empty":
		if e.complexity.RoutePlugins.Empty == nil {
			break
		}

		return e.complexity.RoutePlugins.Empty(childComplexity), true

	case "Schema.inlineSchema":
		if e.complexity.Schema.InlineSchema == nil {
			break
		}

		return e.complexity.Schema.InlineSchema(childComplexity), true

	case "Schema.metadata":
		if e.complexity.Schema.Metadata == nil {
			break
		}

		return e.complexity.Schema.Metadata(childComplexity), true

	case "Schema.status":
		if e.complexity.Schema.Status == nil {
			break
		}

		return e.complexity.Schema.Status(childComplexity), true

	case "SchemaMutation.create":
		if e.complexity.SchemaMutation.Create == nil {
			break
		}

		args, err := field_SchemaMutation_create_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SchemaMutation.Create(childComplexity, args["schema"].(models.InputSchema)), true

	case "SchemaMutation.update":
		if e.complexity.SchemaMutation.Update == nil {
			break
		}

		args, err := field_SchemaMutation_update_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SchemaMutation.Update(childComplexity, args["schema"].(models.InputSchema)), true

	case "SchemaMutation.delete":
		if e.complexity.SchemaMutation.Delete == nil {
			break
		}

		args, err := field_SchemaMutation_delete_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SchemaMutation.Delete(childComplexity, args["name"].(string)), true

	case "SchemaQuery.list":
		if e.complexity.SchemaQuery.List == nil {
			break
		}

		args, err := field_SchemaQuery_list_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SchemaQuery.List(childComplexity, args["selector"].(*models.InputMapStringString)), true

	case "SchemaQuery.get":
		if e.complexity.SchemaQuery.Get == nil {
			break
		}

		args, err := field_SchemaQuery_get_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SchemaQuery.Get(childComplexity, args["name"].(string)), true

	case "Secret.kind":
		if e.complexity.Secret.Kind == nil {
			break
		}

		return e.complexity.Secret.Kind(childComplexity), true

	case "Secret.metadata":
		if e.complexity.Secret.Metadata == nil {
			break
		}

		return e.complexity.Secret.Metadata(childComplexity), true

	case "SecretMutation.create":
		if e.complexity.SecretMutation.Create == nil {
			break
		}

		args, err := field_SecretMutation_create_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SecretMutation.Create(childComplexity, args["secret"].(models.InputSecret)), true

	case "SecretMutation.update":
		if e.complexity.SecretMutation.Update == nil {
			break
		}

		args, err := field_SecretMutation_update_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SecretMutation.Update(childComplexity, args["secret"].(models.InputSecret)), true

	case "SecretMutation.delete":
		if e.complexity.SecretMutation.Delete == nil {
			break
		}

		args, err := field_SecretMutation_delete_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SecretMutation.Delete(childComplexity, args["name"].(string)), true

	case "SecretQuery.list":
		if e.complexity.SecretQuery.List == nil {
			break
		}

		args, err := field_SecretQuery_list_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SecretQuery.List(childComplexity, args["selector"].(*models.InputMapStringString)), true

	case "SecretQuery.get":
		if e.complexity.SecretQuery.Get == nil {
			break
		}

		args, err := field_SecretQuery_get_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SecretQuery.Get(childComplexity, args["name"].(string)), true

	case "Settings.watchNamespaces":
		if e.complexity.Settings.WatchNamespaces == nil {
			break
		}

		return e.complexity.Settings.WatchNamespaces(childComplexity), true

	case "Settings.refreshRate":
		if e.complexity.Settings.RefreshRate == nil {
			break
		}

		return e.complexity.Settings.RefreshRate(childComplexity), true

	case "Settings.metadata":
		if e.complexity.Settings.Metadata == nil {
			break
		}

		return e.complexity.Settings.Metadata(childComplexity), true

	case "SettingsMutation.update":
		if e.complexity.SettingsMutation.Update == nil {
			break
		}

		args, err := field_SettingsMutation_update_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SettingsMutation.Update(childComplexity, args["settings"].(models.InputSettings)), true

	case "SettingsQuery.get":
		if e.complexity.SettingsQuery.Get == nil {
			break
		}

		return e.complexity.SettingsQuery.Get(childComplexity), true

	case "SingleDestination.upstream":
		if e.complexity.SingleDestination.Upstream == nil {
			break
		}

		return e.complexity.SingleDestination.Upstream(childComplexity), true

	case "SingleDestination.destinationSpec":
		if e.complexity.SingleDestination.DestinationSpec == nil {
			break
		}

		return e.complexity.SingleDestination.DestinationSpec(childComplexity), true

	case "SqoopDestinationSpec.schema":
		if e.complexity.SqoopDestinationSpec.Schema == nil {
			break
		}

		return e.complexity.SqoopDestinationSpec.Schema(childComplexity), true

	case "SqoopDestinationSpec.playground":
		if e.complexity.SqoopDestinationSpec.Playground == nil {
			break
		}

		return e.complexity.SqoopDestinationSpec.Playground(childComplexity), true

	case "SqoopServiceSpec.schemas":
		if e.complexity.SqoopServiceSpec.Schemas == nil {
			break
		}

		return e.complexity.SqoopServiceSpec.Schemas(childComplexity), true

	case "SslConfig.secretRef":
		if e.complexity.SslConfig.SecretRef == nil {
			break
		}

		return e.complexity.SslConfig.SecretRef(childComplexity), true

	case "StaticHost.addr":
		if e.complexity.StaticHost.Addr == nil {
			break
		}

		return e.complexity.StaticHost.Addr(childComplexity), true

	case "StaticHost.port":
		if e.complexity.StaticHost.Port == nil {
			break
		}

		return e.complexity.StaticHost.Port(childComplexity), true

	case "StaticUpstreamSpec.hosts":
		if e.complexity.StaticUpstreamSpec.Hosts == nil {
			break
		}

		return e.complexity.StaticUpstreamSpec.Hosts(childComplexity), true

	case "StaticUpstreamSpec.serviceSpec":
		if e.complexity.StaticUpstreamSpec.ServiceSpec == nil {
			break
		}

		return e.complexity.StaticUpstreamSpec.ServiceSpec(childComplexity), true

	case "StaticUpstreamSpec.useTls":
		if e.complexity.StaticUpstreamSpec.UseTls == nil {
			break
		}

		return e.complexity.StaticUpstreamSpec.UseTls(childComplexity), true

	case "Status.state":
		if e.complexity.Status.State == nil {
			break
		}

		return e.complexity.Status.State(childComplexity), true

	case "Status.reason":
		if e.complexity.Status.Reason == nil {
			break
		}

		return e.complexity.Status.Reason(childComplexity), true

	case "Subscription.upstreams":
		if e.complexity.Subscription.Upstreams == nil {
			break
		}

		args, err := field_Subscription_upstreams_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.Upstreams(childComplexity, args["namespace"].(string), args["selector"].(*models.InputMapStringString)), true

	case "Subscription.virtualServices":
		if e.complexity.Subscription.VirtualServices == nil {
			break
		}

		args, err := field_Subscription_virtualServices_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.VirtualServices(childComplexity, args["namespace"].(string), args["selector"].(*models.InputMapStringString)), true

	case "TemplateResolver.inlineTemplate":
		if e.complexity.TemplateResolver.InlineTemplate == nil {
			break
		}

		return e.complexity.TemplateResolver.InlineTemplate(childComplexity), true

	case "TlsSecret.certChain":
		if e.complexity.TlsSecret.CertChain == nil {
			break
		}

		return e.complexity.TlsSecret.CertChain(childComplexity), true

	case "TlsSecret.privateKey":
		if e.complexity.TlsSecret.PrivateKey == nil {
			break
		}

		return e.complexity.TlsSecret.PrivateKey(childComplexity), true

	case "TlsSecret.rootCa":
		if e.complexity.TlsSecret.RootCa == nil {
			break
		}

		return e.complexity.TlsSecret.RootCa(childComplexity), true

	case "Transformation.functionName":
		if e.complexity.Transformation.FunctionName == nil {
			break
		}

		return e.complexity.Transformation.FunctionName(childComplexity), true

	case "Transformation.body":
		if e.complexity.Transformation.Body == nil {
			break
		}

		return e.complexity.Transformation.Body(childComplexity), true

	case "Transformation.headers":
		if e.complexity.Transformation.Headers == nil {
			break
		}

		return e.complexity.Transformation.Headers(childComplexity), true

	case "TransformationParameters.headers":
		if e.complexity.TransformationParameters.Headers == nil {
			break
		}

		return e.complexity.TransformationParameters.Headers(childComplexity), true

	case "TransformationParameters.path":
		if e.complexity.TransformationParameters.Path == nil {
			break
		}

		return e.complexity.TransformationParameters.Path(childComplexity), true

	case "TypeResolver.typeName":
		if e.complexity.TypeResolver.TypeName == nil {
			break
		}

		return e.complexity.TypeResolver.TypeName(childComplexity), true

	case "TypeResolver.fields":
		if e.complexity.TypeResolver.Fields == nil {
			break
		}

		return e.complexity.TypeResolver.Fields(childComplexity), true

	case "Upstream.spec":
		if e.complexity.Upstream.Spec == nil {
			break
		}

		return e.complexity.Upstream.Spec(childComplexity), true

	case "Upstream.metadata":
		if e.complexity.Upstream.Metadata == nil {
			break
		}

		return e.complexity.Upstream.Metadata(childComplexity), true

	case "Upstream.status":
		if e.complexity.Upstream.Status == nil {
			break
		}

		return e.complexity.Upstream.Status(childComplexity), true

	case "UpstreamMutation.create":
		if e.complexity.UpstreamMutation.Create == nil {
			break
		}

		args, err := field_UpstreamMutation_create_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpstreamMutation.Create(childComplexity, args["upstream"].(models.InputUpstream)), true

	case "UpstreamMutation.update":
		if e.complexity.UpstreamMutation.Update == nil {
			break
		}

		args, err := field_UpstreamMutation_update_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpstreamMutation.Update(childComplexity, args["upstream"].(models.InputUpstream)), true

	case "UpstreamMutation.delete":
		if e.complexity.UpstreamMutation.Delete == nil {
			break
		}

		args, err := field_UpstreamMutation_delete_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpstreamMutation.Delete(childComplexity, args["name"].(string)), true

	case "UpstreamQuery.list":
		if e.complexity.UpstreamQuery.List == nil {
			break
		}

		args, err := field_UpstreamQuery_list_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpstreamQuery.List(childComplexity, args["selector"].(*models.InputMapStringString)), true

	case "UpstreamQuery.get":
		if e.complexity.UpstreamQuery.Get == nil {
			break
		}

		args, err := field_UpstreamQuery_get_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpstreamQuery.Get(childComplexity, args["name"].(string)), true

	case "Value.key":
		if e.complexity.Value.Key == nil {
			break
		}

		return e.complexity.Value.Key(childComplexity), true

	case "Value.value":
		if e.complexity.Value.Value == nil {
			break
		}

		return e.complexity.Value.Value(childComplexity), true

	case "VirtualService.domains":
		if e.complexity.VirtualService.Domains == nil {
			break
		}

		return e.complexity.VirtualService.Domains(childComplexity), true

	case "VirtualService.routes":
		if e.complexity.VirtualService.Routes == nil {
			break
		}

		return e.complexity.VirtualService.Routes(childComplexity), true

	case "VirtualService.sslConfig":
		if e.complexity.VirtualService.SslConfig == nil {
			break
		}

		return e.complexity.VirtualService.SslConfig(childComplexity), true

	case "VirtualService.plugins":
		if e.complexity.VirtualService.Plugins == nil {
			break
		}

		return e.complexity.VirtualService.Plugins(childComplexity), true

	case "VirtualService.metadata":
		if e.complexity.VirtualService.Metadata == nil {
			break
		}

		return e.complexity.VirtualService.Metadata(childComplexity), true

	case "VirtualService.status":
		if e.complexity.VirtualService.Status == nil {
			break
		}

		return e.complexity.VirtualService.Status(childComplexity), true

	case "VirtualServiceMutation.create":
		if e.complexity.VirtualServiceMutation.Create == nil {
			break
		}

		args, err := field_VirtualServiceMutation_create_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VirtualServiceMutation.Create(childComplexity, args["virtualService"].(models.InputVirtualService)), true

	case "VirtualServiceMutation.update":
		if e.complexity.VirtualServiceMutation.Update == nil {
			break
		}

		args, err := field_VirtualServiceMutation_update_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VirtualServiceMutation.Update(childComplexity, args["name"].(string), args["resourceVersion"].(string), args["updates"].(models.InputUpdateVirtualService)), true

	case "VirtualServiceMutation.delete":
		if e.complexity.VirtualServiceMutation.Delete == nil {
			break
		}

		args, err := field_VirtualServiceMutation_delete_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VirtualServiceMutation.Delete(childComplexity, args["name"].(string)), true

	case "VirtualServiceMutation.addRoute":
		if e.complexity.VirtualServiceMutation.AddRoute == nil {
			break
		}

		args, err := field_VirtualServiceMutation_addRoute_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VirtualServiceMutation.AddRoute(childComplexity, args["virtualServiceName"].(string), args["resourceVersion"].(string), args["index"].(int), args["route"].(models.InputRoute)), true

	case "VirtualServiceMutation.updateRoute":
		if e.complexity.VirtualServiceMutation.UpdateRoute == nil {
			break
		}

		args, err := field_VirtualServiceMutation_updateRoute_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VirtualServiceMutation.UpdateRoute(childComplexity, args["virtualServiceName"].(string), args["resourceVersion"].(string), args["index"].(int), args["route"].(models.InputRoute)), true

	case "VirtualServiceMutation.deleteRoute":
		if e.complexity.VirtualServiceMutation.DeleteRoute == nil {
			break
		}

		args, err := field_VirtualServiceMutation_deleteRoute_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VirtualServiceMutation.DeleteRoute(childComplexity, args["virtualServiceName"].(string), args["resourceVersion"].(string), args["index"].(int)), true

	case "VirtualServiceMutation.swapRoutes":
		if e.complexity.VirtualServiceMutation.SwapRoutes == nil {
			break
		}

		args, err := field_VirtualServiceMutation_swapRoutes_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VirtualServiceMutation.SwapRoutes(childComplexity, args["virtualServiceName"].(string), args["resourceVersion"].(string), args["index1"].(int), args["index2"].(int)), true

	case "VirtualServiceMutation.shiftRoutes":
		if e.complexity.VirtualServiceMutation.ShiftRoutes == nil {
			break
		}

		args, err := field_VirtualServiceMutation_shiftRoutes_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VirtualServiceMutation.ShiftRoutes(childComplexity, args["virtualServiceName"].(string), args["resourceVersion"].(string), args["fromIndex"].(int), args["toIndex"].(int)), true

	case "VirtualServicePlugins.empty":
		if e.complexity.VirtualServicePlugins.Empty == nil {
			break
		}

		return e.complexity.VirtualServicePlugins.Empty(childComplexity), true

	case "VirtualServiceQuery.list":
		if e.complexity.VirtualServiceQuery.List == nil {
			break
		}

		args, err := field_VirtualServiceQuery_list_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VirtualServiceQuery.List(childComplexity, args["selector"].(*models.InputMapStringString)), true

	case "VirtualServiceQuery.get":
		if e.complexity.VirtualServiceQuery.Get == nil {
			break
		}

		args, err := field_VirtualServiceQuery_get_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VirtualServiceQuery.Get(childComplexity, args["name"].(string)), true

	case "WeightedDestination.destination":
		if e.complexity.WeightedDestination.Destination == nil {
			break
		}

		return e.complexity.WeightedDestination.Destination(childComplexity), true

	case "WeightedDestination.weight":
		if e.complexity.WeightedDestination.Weight == nil {
			break
		}

		return e.complexity.WeightedDestination.Weight(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Query(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Query(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions}
}

func (e *executableSchema) Mutation(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Mutation(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions,
	}
}

func (e *executableSchema) Subscription(ctx context.Context, op *ast.OperationDefinition) func() *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	next := ec._Subscription(ctx, op.SelectionSet)
	if ec.Errors != nil {
		return graphql.OneShot(&graphql.Response{Data: []byte("null"), Errors: ec.Errors})
	}

	var buf bytes.Buffer
	return func() *graphql.Response {
		buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
			buf.Reset()
			data := next()

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)
			return buf.Bytes()
		})

		if buf == nil {
			return nil
		}

		return &graphql.Response{
			Data:       buf,
			Errors:     ec.Errors,
			Extensions: ec.Extensions,
		}
	}
}

type executionContext struct {
	*graphql.RequestContext
	*executableSchema
}

var artifactImplementors = []string{"Artifact"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Artifact(ctx context.Context, sel ast.SelectionSet, obj *models.Artifact) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, artifactImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Artifact")
		case "data":
			out.Values[i] = ec._Artifact_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "metadata":
			out.Values[i] = ec._Artifact_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Artifact_data(ctx context.Context, field graphql.CollectedField, obj *models.Artifact) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Artifact",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Artifact_metadata(ctx context.Context, field graphql.CollectedField, obj *models.Artifact) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Artifact",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Metadata)
	rctx.Result = res

	return ec._Metadata(ctx, field.Selections, &res)
}

var artifactMutationImplementors = []string{"ArtifactMutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ArtifactMutation(ctx context.Context, sel ast.SelectionSet, obj *customtypes.ArtifactMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, artifactMutationImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ArtifactMutation")
		case "create":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ArtifactMutation_create(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "update":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ArtifactMutation_update(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "delete":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ArtifactMutation_delete(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ArtifactMutation_create(ctx context.Context, field graphql.CollectedField, obj *customtypes.ArtifactMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_ArtifactMutation_create_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "ArtifactMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ArtifactMutation().Create(rctx, obj, args["artifact"].(models.InputArtifact))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Artifact)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._Artifact(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _ArtifactMutation_update(ctx context.Context, field graphql.CollectedField, obj *customtypes.ArtifactMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_ArtifactMutation_update_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "ArtifactMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ArtifactMutation().Update(rctx, obj, args["artifact"].(models.InputArtifact))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Artifact)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._Artifact(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _ArtifactMutation_delete(ctx context.Context, field graphql.CollectedField, obj *customtypes.ArtifactMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_ArtifactMutation_delete_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "ArtifactMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ArtifactMutation().Delete(rctx, obj, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Artifact)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._Artifact(ctx, field.Selections, res)
}

var artifactQueryImplementors = []string{"ArtifactQuery"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ArtifactQuery(ctx context.Context, sel ast.SelectionSet, obj *customtypes.ArtifactQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, artifactQueryImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ArtifactQuery")
		case "list":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ArtifactQuery_list(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "get":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ArtifactQuery_get(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ArtifactQuery_list(ctx context.Context, field graphql.CollectedField, obj *customtypes.ArtifactQuery) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_ArtifactQuery_list_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "ArtifactQuery",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ArtifactQuery().List(rctx, obj, args["selector"].(*models.InputMapStringString))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Artifact)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				if res[idx1] == nil {
					return graphql.Null
				}

				return ec._Artifact(ctx, field.Selections, res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _ArtifactQuery_get(ctx context.Context, field graphql.CollectedField, obj *customtypes.ArtifactQuery) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_ArtifactQuery_get_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "ArtifactQuery",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ArtifactQuery().Get(rctx, obj, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Artifact)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._Artifact(ctx, field.Selections, res)
}

var awsDestinationSpecImplementors = []string{"AwsDestinationSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AwsDestinationSpec(ctx context.Context, sel ast.SelectionSet, obj *models.AwsDestinationSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, awsDestinationSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AwsDestinationSpec")
		case "logicalName":
			out.Values[i] = ec._AwsDestinationSpec_logicalName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "invocationStyle":
			out.Values[i] = ec._AwsDestinationSpec_invocationStyle(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "responseTransformation":
			out.Values[i] = ec._AwsDestinationSpec_responseTransformation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AwsDestinationSpec_logicalName(ctx context.Context, field graphql.CollectedField, obj *models.AwsDestinationSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AwsDestinationSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LogicalName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AwsDestinationSpec_invocationStyle(ctx context.Context, field graphql.CollectedField, obj *models.AwsDestinationSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AwsDestinationSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InvocationStyle, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.AwsLambdaInvocationStyle)
	rctx.Result = res
	return res
}

// nolint: vetshadow
func (ec *executionContext) _AwsDestinationSpec_responseTransformation(ctx context.Context, field graphql.CollectedField, obj *models.AwsDestinationSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AwsDestinationSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResponseTransformation, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	return graphql.MarshalBoolean(res)
}

var awsLambdaFunctionImplementors = []string{"AwsLambdaFunction"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AwsLambdaFunction(ctx context.Context, sel ast.SelectionSet, obj *models.AwsLambdaFunction) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, awsLambdaFunctionImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AwsLambdaFunction")
		case "logicalName":
			out.Values[i] = ec._AwsLambdaFunction_logicalName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "functionName":
			out.Values[i] = ec._AwsLambdaFunction_functionName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "qualifier":
			out.Values[i] = ec._AwsLambdaFunction_qualifier(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AwsLambdaFunction_logicalName(ctx context.Context, field graphql.CollectedField, obj *models.AwsLambdaFunction) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AwsLambdaFunction",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LogicalName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AwsLambdaFunction_functionName(ctx context.Context, field graphql.CollectedField, obj *models.AwsLambdaFunction) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AwsLambdaFunction",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FunctionName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AwsLambdaFunction_qualifier(ctx context.Context, field graphql.CollectedField, obj *models.AwsLambdaFunction) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AwsLambdaFunction",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Qualifier, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

var awsSecretImplementors = []string{"AwsSecret"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AwsSecret(ctx context.Context, sel ast.SelectionSet, obj *models.AwsSecret) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, awsSecretImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AwsSecret")
		case "accessKey":
			out.Values[i] = ec._AwsSecret_accessKey(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "secretKey":
			out.Values[i] = ec._AwsSecret_secretKey(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AwsSecret_accessKey(ctx context.Context, field graphql.CollectedField, obj *models.AwsSecret) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AwsSecret",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccessKey, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AwsSecret_secretKey(ctx context.Context, field graphql.CollectedField, obj *models.AwsSecret) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AwsSecret",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SecretKey, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

var awsUpstreamSpecImplementors = []string{"AwsUpstreamSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AwsUpstreamSpec(ctx context.Context, sel ast.SelectionSet, obj *models.AwsUpstreamSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, awsUpstreamSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AwsUpstreamSpec")
		case "region":
			out.Values[i] = ec._AwsUpstreamSpec_region(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "secretRef":
			out.Values[i] = ec._AwsUpstreamSpec_secretRef(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "functions":
			out.Values[i] = ec._AwsUpstreamSpec_functions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AwsUpstreamSpec_region(ctx context.Context, field graphql.CollectedField, obj *models.AwsUpstreamSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AwsUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Region, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AwsUpstreamSpec_secretRef(ctx context.Context, field graphql.CollectedField, obj *models.AwsUpstreamSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AwsUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SecretRef, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.ResourceRef)
	rctx.Result = res

	return ec._ResourceRef(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _AwsUpstreamSpec_functions(ctx context.Context, field graphql.CollectedField, obj *models.AwsUpstreamSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AwsUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Functions, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.AwsLambdaFunction)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._AwsLambdaFunction(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var azureDestinationSpecImplementors = []string{"AzureDestinationSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AzureDestinationSpec(ctx context.Context, sel ast.SelectionSet, obj *models.AzureDestinationSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, azureDestinationSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AzureDestinationSpec")
		case "functionName":
			out.Values[i] = ec._AzureDestinationSpec_functionName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AzureDestinationSpec_functionName(ctx context.Context, field graphql.CollectedField, obj *models.AzureDestinationSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AzureDestinationSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FunctionName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

var azureFunctionImplementors = []string{"AzureFunction"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AzureFunction(ctx context.Context, sel ast.SelectionSet, obj *models.AzureFunction) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, azureFunctionImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AzureFunction")
		case "functionName":
			out.Values[i] = ec._AzureFunction_functionName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "authLevel":
			out.Values[i] = ec._AzureFunction_authLevel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AzureFunction_functionName(ctx context.Context, field graphql.CollectedField, obj *models.AzureFunction) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AzureFunction",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FunctionName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AzureFunction_authLevel(ctx context.Context, field graphql.CollectedField, obj *models.AzureFunction) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AzureFunction",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthLevel, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.AzureFnAuthLevel)
	rctx.Result = res
	return res
}

var azureSecretImplementors = []string{"AzureSecret"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AzureSecret(ctx context.Context, sel ast.SelectionSet, obj *models.AzureSecret) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, azureSecretImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AzureSecret")
		case "apiKeys":
			out.Values[i] = ec._AzureSecret_apiKeys(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AzureSecret_apiKeys(ctx context.Context, field graphql.CollectedField, obj *models.AzureSecret) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AzureSecret",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIKeys, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.MapStringString)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._MapStringString(ctx, field.Selections, res)
}

var azureUpstreamSpecImplementors = []string{"AzureUpstreamSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AzureUpstreamSpec(ctx context.Context, sel ast.SelectionSet, obj *models.AzureUpstreamSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, azureUpstreamSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AzureUpstreamSpec")
		case "functionAppName":
			out.Values[i] = ec._AzureUpstreamSpec_functionAppName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "secretRef":
			out.Values[i] = ec._AzureUpstreamSpec_secretRef(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "functions":
			out.Values[i] = ec._AzureUpstreamSpec_functions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AzureUpstreamSpec_functionAppName(ctx context.Context, field graphql.CollectedField, obj *models.AzureUpstreamSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AzureUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FunctionAppName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AzureUpstreamSpec_secretRef(ctx context.Context, field graphql.CollectedField, obj *models.AzureUpstreamSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AzureUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SecretRef, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.ResourceRef)
	rctx.Result = res

	return ec._ResourceRef(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _AzureUpstreamSpec_functions(ctx context.Context, field graphql.CollectedField, obj *models.AzureUpstreamSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AzureUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Functions, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.AzureFunction)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._AzureFunction(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var fieldResolverImplementors = []string{"FieldResolver"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _FieldResolver(ctx context.Context, sel ast.SelectionSet, obj *models.FieldResolver) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, fieldResolverImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FieldResolver")
		case "fieldName":
			out.Values[i] = ec._FieldResolver_fieldName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "resolver":
			out.Values[i] = ec._FieldResolver_resolver(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _FieldResolver_fieldName(ctx context.Context, field graphql.CollectedField, obj *models.FieldResolver) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "FieldResolver",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FieldName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _FieldResolver_resolver(ctx context.Context, field graphql.CollectedField, obj *models.FieldResolver) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "FieldResolver",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resolver, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.Resolver)
	rctx.Result = res

	return ec._Resolver(ctx, field.Selections, &res)
}

var glooResolverImplementors = []string{"GlooResolver"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _GlooResolver(ctx context.Context, sel ast.SelectionSet, obj *models.GlooResolver) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, glooResolverImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GlooResolver")
		case "requestTemplate":
			out.Values[i] = ec._GlooResolver_requestTemplate(ctx, field, obj)
		case "responseTemplate":
			out.Values[i] = ec._GlooResolver_responseTemplate(ctx, field, obj)
		case "destination":
			out.Values[i] = ec._GlooResolver_destination(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _GlooResolver_requestTemplate(ctx context.Context, field graphql.CollectedField, obj *models.GlooResolver) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "GlooResolver",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestTemplate, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.RequestTemplate)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._RequestTemplate(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _GlooResolver_responseTemplate(ctx context.Context, field graphql.CollectedField, obj *models.GlooResolver) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "GlooResolver",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResponseTemplate, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ResponseTemplate)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._ResponseTemplate(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _GlooResolver_destination(ctx context.Context, field graphql.CollectedField, obj *models.GlooResolver) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "GlooResolver",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Destination, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Destination)
	rctx.Result = res

	return ec._Destination(ctx, field.Selections, &res)
}

var grpcDestinationSpecImplementors = []string{"GrpcDestinationSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _GrpcDestinationSpec(ctx context.Context, sel ast.SelectionSet, obj *models.GrpcDestinationSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, grpcDestinationSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GrpcDestinationSpec")
		case "package":
			out.Values[i] = ec._GrpcDestinationSpec_package(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "service":
			out.Values[i] = ec._GrpcDestinationSpec_service(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "function":
			out.Values[i] = ec._GrpcDestinationSpec_function(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "parameters":
			out.Values[i] = ec._GrpcDestinationSpec_parameters(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _GrpcDestinationSpec_package(ctx context.Context, field graphql.CollectedField, obj *models.GrpcDestinationSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "GrpcDestinationSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Package, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _GrpcDestinationSpec_service(ctx context.Context, field graphql.CollectedField, obj *models.GrpcDestinationSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "GrpcDestinationSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Service, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _GrpcDestinationSpec_function(ctx context.Context, field graphql.CollectedField, obj *models.GrpcDestinationSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "GrpcDestinationSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Function, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _GrpcDestinationSpec_parameters(ctx context.Context, field graphql.CollectedField, obj *models.GrpcDestinationSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "GrpcDestinationSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parameters, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.TransformationParameters)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._TransformationParameters(ctx, field.Selections, res)
}

var grpcServiceImplementors = []string{"GrpcService"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _GrpcService(ctx context.Context, sel ast.SelectionSet, obj *models.GrpcService) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, grpcServiceImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GrpcService")
		case "packageName":
			out.Values[i] = ec._GrpcService_packageName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "serviceName":
			out.Values[i] = ec._GrpcService_serviceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "functionNames":
			out.Values[i] = ec._GrpcService_functionNames(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _GrpcService_packageName(ctx context.Context, field graphql.CollectedField, obj *models.GrpcService) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "GrpcService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PackageName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _GrpcService_serviceName(ctx context.Context, field graphql.CollectedField, obj *models.GrpcService) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "GrpcService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _GrpcService_functionNames(ctx context.Context, field graphql.CollectedField, obj *models.GrpcService) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "GrpcService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FunctionNames, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

var grpcServiceSpecImplementors = []string{"GrpcServiceSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _GrpcServiceSpec(ctx context.Context, sel ast.SelectionSet, obj *models.GrpcServiceSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, grpcServiceSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GrpcServiceSpec")
		case "grpcServices":
			out.Values[i] = ec._GrpcServiceSpec_grpcServices(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _GrpcServiceSpec_grpcServices(ctx context.Context, field graphql.CollectedField, obj *models.GrpcServiceSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "GrpcServiceSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GrpcServices, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.GrpcService)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				if res[idx1] == nil {
					return graphql.Null
				}

				return ec._GrpcService(ctx, field.Selections, res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var keyValueMatcherImplementors = []string{"KeyValueMatcher"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _KeyValueMatcher(ctx context.Context, sel ast.SelectionSet, obj *models.KeyValueMatcher) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, keyValueMatcherImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KeyValueMatcher")
		case "name":
			out.Values[i] = ec._KeyValueMatcher_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "value":
			out.Values[i] = ec._KeyValueMatcher_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "isRegex":
			out.Values[i] = ec._KeyValueMatcher_isRegex(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _KeyValueMatcher_name(ctx context.Context, field graphql.CollectedField, obj *models.KeyValueMatcher) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "KeyValueMatcher",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _KeyValueMatcher_value(ctx context.Context, field graphql.CollectedField, obj *models.KeyValueMatcher) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "KeyValueMatcher",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _KeyValueMatcher_isRegex(ctx context.Context, field graphql.CollectedField, obj *models.KeyValueMatcher) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "KeyValueMatcher",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRegex, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	return graphql.MarshalBoolean(res)
}

var kubeUpstreamSpecImplementors = []string{"KubeUpstreamSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _KubeUpstreamSpec(ctx context.Context, sel ast.SelectionSet, obj *models.KubeUpstreamSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, kubeUpstreamSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KubeUpstreamSpec")
		case "serviceName":
			out.Values[i] = ec._KubeUpstreamSpec_serviceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "serviceNamespace":
			out.Values[i] = ec._KubeUpstreamSpec_serviceNamespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "servicePort":
			out.Values[i] = ec._KubeUpstreamSpec_servicePort(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "selector":
			out.Values[i] = ec._KubeUpstreamSpec_selector(ctx, field, obj)
		case "serviceSpec":
			out.Values[i] = ec._KubeUpstreamSpec_serviceSpec(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _KubeUpstreamSpec_serviceName(ctx context.Context, field graphql.CollectedField, obj *models.KubeUpstreamSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "KubeUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _KubeUpstreamSpec_serviceNamespace(ctx context.Context, field graphql.CollectedField, obj *models.KubeUpstreamSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "KubeUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceNamespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _KubeUpstreamSpec_servicePort(ctx context.Context, field graphql.CollectedField, obj *models.KubeUpstreamSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "KubeUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServicePort, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _KubeUpstreamSpec_selector(ctx context.Context, field graphql.CollectedField, obj *models.KubeUpstreamSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "KubeUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Selector, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.MapStringString)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._MapStringString(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _KubeUpstreamSpec_serviceSpec(ctx context.Context, field graphql.CollectedField, obj *models.KubeUpstreamSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "KubeUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceSpec, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.ServiceSpec)
	rctx.Result = res

	return ec._ServiceSpec(ctx, field.Selections, &res)
}

var mapStringStringImplementors = []string{"MapStringString"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _MapStringString(ctx context.Context, sel ast.SelectionSet, obj *models.MapStringString) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, mapStringStringImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MapStringString")
		case "values":
			out.Values[i] = ec._MapStringString_values(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _MapStringString_values(ctx context.Context, field graphql.CollectedField, obj *models.MapStringString) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "MapStringString",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Values, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.Value)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Value(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var matcherImplementors = []string{"Matcher"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Matcher(ctx context.Context, sel ast.SelectionSet, obj *models.Matcher) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, matcherImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Matcher")
		case "pathMatch":
			out.Values[i] = ec._Matcher_pathMatch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "pathMatchType":
			out.Values[i] = ec._Matcher_pathMatchType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "headers":
			out.Values[i] = ec._Matcher_headers(ctx, field, obj)
		case "queryParameters":
			out.Values[i] = ec._Matcher_queryParameters(ctx, field, obj)
		case "methods":
			out.Values[i] = ec._Matcher_methods(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Matcher_pathMatch(ctx context.Context, field graphql.CollectedField, obj *models.Matcher) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Matcher",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PathMatch, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Matcher_pathMatchType(ctx context.Context, field graphql.CollectedField, obj *models.Matcher) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Matcher",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PathMatchType, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.PathMatchType)
	rctx.Result = res
	return res
}

// nolint: vetshadow
func (ec *executionContext) _Matcher_headers(ctx context.Context, field graphql.CollectedField, obj *models.Matcher) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Matcher",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Headers, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.KeyValueMatcher)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._KeyValueMatcher(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Matcher_queryParameters(ctx context.Context, field graphql.CollectedField, obj *models.Matcher) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Matcher",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryParameters, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.KeyValueMatcher)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._KeyValueMatcher(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Matcher_methods(ctx context.Context, field graphql.CollectedField, obj *models.Matcher) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Matcher",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Methods, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

var metadataImplementors = []string{"Metadata"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Metadata(ctx context.Context, sel ast.SelectionSet, obj *models.Metadata) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, metadataImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Metadata")
		case "name":
			out.Values[i] = ec._Metadata_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._Metadata_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "resourceVersion":
			out.Values[i] = ec._Metadata_resourceVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "labels":
			out.Values[i] = ec._Metadata_labels(ctx, field, obj)
		case "annotations":
			out.Values[i] = ec._Metadata_annotations(ctx, field, obj)
		case "guid":
			out.Values[i] = ec._Metadata_guid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Metadata_name(ctx context.Context, field graphql.CollectedField, obj *models.Metadata) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Metadata",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Metadata_namespace(ctx context.Context, field graphql.CollectedField, obj *models.Metadata) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Metadata",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Metadata_resourceVersion(ctx context.Context, field graphql.CollectedField, obj *models.Metadata) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Metadata",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceVersion, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Metadata_labels(ctx context.Context, field graphql.CollectedField, obj *models.Metadata) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Metadata",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.MapStringString)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._MapStringString(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Metadata_annotations(ctx context.Context, field graphql.CollectedField, obj *models.Metadata) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Metadata",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotations, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.MapStringString)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._MapStringString(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Metadata_guid(ctx context.Context, field graphql.CollectedField, obj *models.Metadata) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Metadata",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GUID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

var multiDestinationImplementors = []string{"MultiDestination"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _MultiDestination(ctx context.Context, sel ast.SelectionSet, obj *models.MultiDestination) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, multiDestinationImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MultiDestination")
		case "destinations":
			out.Values[i] = ec._MultiDestination_destinations(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _MultiDestination_destinations(ctx context.Context, field graphql.CollectedField, obj *models.MultiDestination) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "MultiDestination",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Destinations, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.WeightedDestination)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._WeightedDestination(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var mutationImplementors = []string{"Mutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, mutationImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Mutation",
	})

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "upstreams":
			out.Values[i] = ec._Mutation_upstreams(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "virtualServices":
			out.Values[i] = ec._Mutation_virtualServices(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "resolverMaps":
			out.Values[i] = ec._Mutation_resolverMaps(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "schemas":
			out.Values[i] = ec._Mutation_schemas(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "secrets":
			out.Values[i] = ec._Mutation_secrets(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "artifacts":
			out.Values[i] = ec._Mutation_artifacts(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "settings":
			out.Values[i] = ec._Mutation_settings(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_upstreams(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_upstreams_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Upstreams(rctx, args["namespace"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(customtypes.UpstreamMutation)
	rctx.Result = res

	return ec._UpstreamMutation(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_virtualServices(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_virtualServices_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().VirtualServices(rctx, args["namespace"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(customtypes.VirtualServiceMutation)
	rctx.Result = res

	return ec._VirtualServiceMutation(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_resolverMaps(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_resolverMaps_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ResolverMaps(rctx, args["namespace"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(customtypes.ResolverMapMutation)
	rctx.Result = res

	return ec._ResolverMapMutation(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_schemas(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_schemas_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Schemas(rctx, args["namespace"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(customtypes.SchemaMutation)
	rctx.Result = res

	return ec._SchemaMutation(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_secrets(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_secrets_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Secrets(rctx, args["namespace"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(customtypes.SecretMutation)
	rctx.Result = res

	return ec._SecretMutation(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_artifacts(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_artifacts_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Artifacts(rctx, args["namespace"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(customtypes.ArtifactMutation)
	rctx.Result = res

	return ec._ArtifactMutation(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_settings(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Settings(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(customtypes.SettingsMutation)
	rctx.Result = res

	return ec._SettingsMutation(ctx, field.Selections, &res)
}

var nodeJSResolverImplementors = []string{"NodeJSResolver"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _NodeJSResolver(ctx context.Context, sel ast.SelectionSet, obj *models.NodeJSResolver) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, nodeJSResolverImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NodeJSResolver")
		case "empty":
			out.Values[i] = ec._NodeJSResolver_empty(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _NodeJSResolver_empty(ctx context.Context, field graphql.CollectedField, obj *models.NodeJSResolver) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "NodeJSResolver",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Empty, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var oAuthEndpointImplementors = []string{"OAuthEndpoint"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _OAuthEndpoint(ctx context.Context, sel ast.SelectionSet, obj *models.OAuthEndpoint) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, oAuthEndpointImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OAuthEndpoint")
		case "url":
			out.Values[i] = ec._OAuthEndpoint_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "clientName":
			out.Values[i] = ec._OAuthEndpoint_clientName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _OAuthEndpoint_url(ctx context.Context, field graphql.CollectedField, obj *models.OAuthEndpoint) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "OAuthEndpoint",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _OAuthEndpoint_clientName(ctx context.Context, field graphql.CollectedField, obj *models.OAuthEndpoint) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "OAuthEndpoint",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

var queryImplementors = []string{"Query"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, queryImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
	})

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "resource":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_resource(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "getOAuthEndpoint":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_getOAuthEndpoint(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "version":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_version(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "upstreams":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_upstreams(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "virtualServices":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_virtualServices(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "resolverMaps":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_resolverMaps(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "schemas":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_schemas(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "secrets":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_secrets(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "artifacts":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_artifacts(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "settings":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_settings(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Query_resource(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_resource_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Resource(rctx, args["guid"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Resource)
	rctx.Result = res

	return ec._Resource(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_getOAuthEndpoint(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetOAuthEndpoint(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.OAuthEndpoint)
	rctx.Result = res

	return ec._OAuthEndpoint(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_version(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Version(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_upstreams(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_upstreams_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Upstreams(rctx, args["namespace"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(customtypes.UpstreamQuery)
	rctx.Result = res

	return ec._UpstreamQuery(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_virtualServices(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_virtualServices_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().VirtualServices(rctx, args["namespace"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(customtypes.VirtualServiceQuery)
	rctx.Result = res

	return ec._VirtualServiceQuery(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_resolverMaps(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_resolverMaps_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ResolverMaps(rctx, args["namespace"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(customtypes.ResolverMapQuery)
	rctx.Result = res

	return ec._ResolverMapQuery(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_schemas(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_schemas_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Schemas(rctx, args["namespace"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(customtypes.SchemaQuery)
	rctx.Result = res

	return ec._SchemaQuery(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_secrets(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_secrets_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Secrets(rctx, args["namespace"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(customtypes.SecretQuery)
	rctx.Result = res

	return ec._SecretQuery(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_artifacts(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_artifacts_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Artifacts(rctx, args["namespace"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(customtypes.ArtifactQuery)
	rctx.Result = res

	return ec._ArtifactQuery(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_settings(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Settings(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(customtypes.SettingsQuery)
	rctx.Result = res

	return ec._SettingsQuery(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query___type_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec.___Schema(ctx, field.Selections, res)
}

var requestTemplateImplementors = []string{"RequestTemplate"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _RequestTemplate(ctx context.Context, sel ast.SelectionSet, obj *models.RequestTemplate) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, requestTemplateImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RequestTemplate")
		case "verb":
			out.Values[i] = ec._RequestTemplate_verb(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "path":
			out.Values[i] = ec._RequestTemplate_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "body":
			out.Values[i] = ec._RequestTemplate_body(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "headers":
			out.Values[i] = ec._RequestTemplate_headers(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _RequestTemplate_verb(ctx context.Context, field graphql.CollectedField, obj *models.RequestTemplate) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "RequestTemplate",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Verb, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _RequestTemplate_path(ctx context.Context, field graphql.CollectedField, obj *models.RequestTemplate) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "RequestTemplate",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _RequestTemplate_body(ctx context.Context, field graphql.CollectedField, obj *models.RequestTemplate) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "RequestTemplate",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Body, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _RequestTemplate_headers(ctx context.Context, field graphql.CollectedField, obj *models.RequestTemplate) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "RequestTemplate",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Headers, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.MapStringString)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._MapStringString(ctx, field.Selections, res)
}

var resolverMapImplementors = []string{"ResolverMap"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ResolverMap(ctx context.Context, sel ast.SelectionSet, obj *models.ResolverMap) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, resolverMapImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResolverMap")
		case "types":
			out.Values[i] = ec._ResolverMap_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "metadata":
			out.Values[i] = ec._ResolverMap_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._ResolverMap_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ResolverMap_types(ctx context.Context, field graphql.CollectedField, obj *models.ResolverMap) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "ResolverMap",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.TypeResolver)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._TypeResolver(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _ResolverMap_metadata(ctx context.Context, field graphql.CollectedField, obj *models.ResolverMap) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "ResolverMap",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Metadata)
	rctx.Result = res

	return ec._Metadata(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _ResolverMap_status(ctx context.Context, field graphql.CollectedField, obj *models.ResolverMap) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "ResolverMap",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Status)
	rctx.Result = res

	return ec._Status(ctx, field.Selections, &res)
}

var resolverMapMutationImplementors = []string{"ResolverMapMutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ResolverMapMutation(ctx context.Context, sel ast.SelectionSet, obj *customtypes.ResolverMapMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, resolverMapMutationImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResolverMapMutation")
		case "create":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ResolverMapMutation_create(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "update":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ResolverMapMutation_update(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "delete":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ResolverMapMutation_delete(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "setResolver":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ResolverMapMutation_setResolver(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ResolverMapMutation_create(ctx context.Context, field graphql.CollectedField, obj *customtypes.ResolverMapMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_ResolverMapMutation_create_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "ResolverMapMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ResolverMapMutation().Create(rctx, obj, args["resolverMap"].(models.InputResolverMap))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ResolverMap)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._ResolverMap(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _ResolverMapMutation_update(ctx context.Context, field graphql.CollectedField, obj *customtypes.ResolverMapMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_ResolverMapMutation_update_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "ResolverMapMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ResolverMapMutation().Update(rctx, obj, args["resolverMap"].(models.InputResolverMap))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ResolverMap)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._ResolverMap(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _ResolverMapMutation_delete(ctx context.Context, field graphql.CollectedField, obj *customtypes.ResolverMapMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_ResolverMapMutation_delete_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "ResolverMapMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ResolverMapMutation().Delete(rctx, obj, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ResolverMap)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._ResolverMap(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _ResolverMapMutation_setResolver(ctx context.Context, field graphql.CollectedField, obj *customtypes.ResolverMapMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_ResolverMapMutation_setResolver_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "ResolverMapMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ResolverMapMutation().SetResolver(rctx, obj, args["resolverMapName"].(string), args["resourceVersion"].(string), args["typeName"].(string), args["fieldName"].(string), args["glooResolver"].(models.InputGlooResolver))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ResolverMap)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._ResolverMap(ctx, field.Selections, res)
}

var resolverMapQueryImplementors = []string{"ResolverMapQuery"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ResolverMapQuery(ctx context.Context, sel ast.SelectionSet, obj *customtypes.ResolverMapQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, resolverMapQueryImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResolverMapQuery")
		case "list":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ResolverMapQuery_list(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "get":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ResolverMapQuery_get(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ResolverMapQuery_list(ctx context.Context, field graphql.CollectedField, obj *customtypes.ResolverMapQuery) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_ResolverMapQuery_list_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "ResolverMapQuery",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ResolverMapQuery().List(rctx, obj, args["selector"].(*models.InputMapStringString))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.ResolverMap)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				if res[idx1] == nil {
					return graphql.Null
				}

				return ec._ResolverMap(ctx, field.Selections, res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _ResolverMapQuery_get(ctx context.Context, field graphql.CollectedField, obj *customtypes.ResolverMapQuery) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_ResolverMapQuery_get_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "ResolverMapQuery",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ResolverMapQuery().Get(rctx, obj, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ResolverMap)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._ResolverMap(ctx, field.Selections, res)
}

var resourceRefImplementors = []string{"ResourceRef"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ResourceRef(ctx context.Context, sel ast.SelectionSet, obj *models.ResourceRef) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, resourceRefImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceRef")
		case "name":
			out.Values[i] = ec._ResourceRef_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._ResourceRef_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ResourceRef_name(ctx context.Context, field graphql.CollectedField, obj *models.ResourceRef) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "ResourceRef",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ResourceRef_namespace(ctx context.Context, field graphql.CollectedField, obj *models.ResourceRef) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "ResourceRef",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

var responseTemplateImplementors = []string{"ResponseTemplate"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ResponseTemplate(ctx context.Context, sel ast.SelectionSet, obj *models.ResponseTemplate) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, responseTemplateImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResponseTemplate")
		case "body":
			out.Values[i] = ec._ResponseTemplate_body(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "headers":
			out.Values[i] = ec._ResponseTemplate_headers(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ResponseTemplate_body(ctx context.Context, field graphql.CollectedField, obj *models.ResponseTemplate) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "ResponseTemplate",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Body, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ResponseTemplate_headers(ctx context.Context, field graphql.CollectedField, obj *models.ResponseTemplate) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "ResponseTemplate",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Headers, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.MapStringString)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._MapStringString(ctx, field.Selections, res)
}

var restDestinationSpecImplementors = []string{"RestDestinationSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _RestDestinationSpec(ctx context.Context, sel ast.SelectionSet, obj *models.RestDestinationSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, restDestinationSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RestDestinationSpec")
		case "functionName":
			out.Values[i] = ec._RestDestinationSpec_functionName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "parameters":
			out.Values[i] = ec._RestDestinationSpec_parameters(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _RestDestinationSpec_functionName(ctx context.Context, field graphql.CollectedField, obj *models.RestDestinationSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "RestDestinationSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FunctionName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _RestDestinationSpec_parameters(ctx context.Context, field graphql.CollectedField, obj *models.RestDestinationSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "RestDestinationSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parameters, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.TransformationParameters)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._TransformationParameters(ctx, field.Selections, res)
}

var restServiceSpecImplementors = []string{"RestServiceSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _RestServiceSpec(ctx context.Context, sel ast.SelectionSet, obj *models.RestServiceSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, restServiceSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RestServiceSpec")
		case "functions":
			out.Values[i] = ec._RestServiceSpec_functions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _RestServiceSpec_functions(ctx context.Context, field graphql.CollectedField, obj *models.RestServiceSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "RestServiceSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Functions, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.Transformation)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Transformation(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var routeImplementors = []string{"Route"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Route(ctx context.Context, sel ast.SelectionSet, obj *models.Route) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, routeImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Route")
		case "matcher":
			out.Values[i] = ec._Route_matcher(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "destination":
			out.Values[i] = ec._Route_destination(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "plugins":
			out.Values[i] = ec._Route_plugins(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Route_matcher(ctx context.Context, field graphql.CollectedField, obj *models.Route) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Route",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Matcher, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Matcher)
	rctx.Result = res

	return ec._Matcher(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Route_destination(ctx context.Context, field graphql.CollectedField, obj *models.Route) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Route",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Destination, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Destination)
	rctx.Result = res

	return ec._Destination(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Route_plugins(ctx context.Context, field graphql.CollectedField, obj *models.Route) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Route",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Plugins, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.RoutePlugins)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._RoutePlugins(ctx, field.Selections, res)
}

var routePluginsImplementors = []string{"RoutePlugins"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _RoutePlugins(ctx context.Context, sel ast.SelectionSet, obj *models.RoutePlugins) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, routePluginsImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RoutePlugins")
		case "empty":
			out.Values[i] = ec._RoutePlugins_empty(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _RoutePlugins_empty(ctx context.Context, field graphql.CollectedField, obj *models.RoutePlugins) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "RoutePlugins",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Empty, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var schemaImplementors = []string{"Schema"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Schema(ctx context.Context, sel ast.SelectionSet, obj *models.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, schemaImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Schema")
		case "inlineSchema":
			out.Values[i] = ec._Schema_inlineSchema(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "metadata":
			out.Values[i] = ec._Schema_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._Schema_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Schema_inlineSchema(ctx context.Context, field graphql.CollectedField, obj *models.Schema) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InlineSchema, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Schema_metadata(ctx context.Context, field graphql.CollectedField, obj *models.Schema) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Metadata)
	rctx.Result = res

	return ec._Metadata(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Schema_status(ctx context.Context, field graphql.CollectedField, obj *models.Schema) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Status)
	rctx.Result = res

	return ec._Status(ctx, field.Selections, &res)
}

var schemaMutationImplementors = []string{"SchemaMutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SchemaMutation(ctx context.Context, sel ast.SelectionSet, obj *customtypes.SchemaMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, schemaMutationImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SchemaMutation")
		case "create":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._SchemaMutation_create(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "update":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._SchemaMutation_update(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "delete":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._SchemaMutation_delete(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _SchemaMutation_create(ctx context.Context, field graphql.CollectedField, obj *customtypes.SchemaMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_SchemaMutation_create_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "SchemaMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SchemaMutation().Create(rctx, obj, args["schema"].(models.InputSchema))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Schema)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._Schema(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _SchemaMutation_update(ctx context.Context, field graphql.CollectedField, obj *customtypes.SchemaMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_SchemaMutation_update_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "SchemaMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SchemaMutation().Update(rctx, obj, args["schema"].(models.InputSchema))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Schema)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._Schema(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _SchemaMutation_delete(ctx context.Context, field graphql.CollectedField, obj *customtypes.SchemaMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_SchemaMutation_delete_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "SchemaMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SchemaMutation().Delete(rctx, obj, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Schema)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._Schema(ctx, field.Selections, res)
}

var schemaQueryImplementors = []string{"SchemaQuery"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SchemaQuery(ctx context.Context, sel ast.SelectionSet, obj *customtypes.SchemaQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, schemaQueryImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SchemaQuery")
		case "list":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._SchemaQuery_list(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "get":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._SchemaQuery_get(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _SchemaQuery_list(ctx context.Context, field graphql.CollectedField, obj *customtypes.SchemaQuery) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_SchemaQuery_list_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "SchemaQuery",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SchemaQuery().List(rctx, obj, args["selector"].(*models.InputMapStringString))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Schema)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				if res[idx1] == nil {
					return graphql.Null
				}

				return ec._Schema(ctx, field.Selections, res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _SchemaQuery_get(ctx context.Context, field graphql.CollectedField, obj *customtypes.SchemaQuery) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_SchemaQuery_get_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "SchemaQuery",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SchemaQuery().Get(rctx, obj, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Schema)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._Schema(ctx, field.Selections, res)
}

var secretImplementors = []string{"Secret"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Secret(ctx context.Context, sel ast.SelectionSet, obj *models.Secret) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, secretImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Secret")
		case "kind":
			out.Values[i] = ec._Secret_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "metadata":
			out.Values[i] = ec._Secret_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Secret_kind(ctx context.Context, field graphql.CollectedField, obj *models.Secret) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Secret",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.SecretKind)
	rctx.Result = res

	return ec._SecretKind(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Secret_metadata(ctx context.Context, field graphql.CollectedField, obj *models.Secret) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Secret",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Metadata)
	rctx.Result = res

	return ec._Metadata(ctx, field.Selections, &res)
}

var secretMutationImplementors = []string{"SecretMutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SecretMutation(ctx context.Context, sel ast.SelectionSet, obj *customtypes.SecretMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, secretMutationImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SecretMutation")
		case "create":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._SecretMutation_create(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "update":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._SecretMutation_update(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "delete":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._SecretMutation_delete(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _SecretMutation_create(ctx context.Context, field graphql.CollectedField, obj *customtypes.SecretMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_SecretMutation_create_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "SecretMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SecretMutation().Create(rctx, obj, args["secret"].(models.InputSecret))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Secret)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._Secret(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _SecretMutation_update(ctx context.Context, field graphql.CollectedField, obj *customtypes.SecretMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_SecretMutation_update_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "SecretMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SecretMutation().Update(rctx, obj, args["secret"].(models.InputSecret))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Secret)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._Secret(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _SecretMutation_delete(ctx context.Context, field graphql.CollectedField, obj *customtypes.SecretMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_SecretMutation_delete_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "SecretMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SecretMutation().Delete(rctx, obj, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Secret)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._Secret(ctx, field.Selections, res)
}

var secretQueryImplementors = []string{"SecretQuery"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SecretQuery(ctx context.Context, sel ast.SelectionSet, obj *customtypes.SecretQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, secretQueryImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SecretQuery")
		case "list":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._SecretQuery_list(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "get":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._SecretQuery_get(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _SecretQuery_list(ctx context.Context, field graphql.CollectedField, obj *customtypes.SecretQuery) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_SecretQuery_list_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "SecretQuery",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SecretQuery().List(rctx, obj, args["selector"].(*models.InputMapStringString))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Secret)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				if res[idx1] == nil {
					return graphql.Null
				}

				return ec._Secret(ctx, field.Selections, res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _SecretQuery_get(ctx context.Context, field graphql.CollectedField, obj *customtypes.SecretQuery) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_SecretQuery_get_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "SecretQuery",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SecretQuery().Get(rctx, obj, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Secret)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._Secret(ctx, field.Selections, res)
}

var settingsImplementors = []string{"Settings"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Settings(ctx context.Context, sel ast.SelectionSet, obj *models.Settings) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, settingsImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Settings")
		case "watchNamespaces":
			out.Values[i] = ec._Settings_watchNamespaces(ctx, field, obj)
		case "refreshRate":
			out.Values[i] = ec._Settings_refreshRate(ctx, field, obj)
		case "metadata":
			out.Values[i] = ec._Settings_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Settings_watchNamespaces(ctx context.Context, field graphql.CollectedField, obj *models.Settings) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Settings",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WatchNamespaces, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Settings_refreshRate(ctx context.Context, field graphql.CollectedField, obj *models.Settings) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Settings",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RefreshRate, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*customtypes.Duration)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}
	return *res
}

// nolint: vetshadow
func (ec *executionContext) _Settings_metadata(ctx context.Context, field graphql.CollectedField, obj *models.Settings) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Settings",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Metadata)
	rctx.Result = res

	return ec._Metadata(ctx, field.Selections, &res)
}

var settingsMutationImplementors = []string{"SettingsMutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SettingsMutation(ctx context.Context, sel ast.SelectionSet, obj *customtypes.SettingsMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, settingsMutationImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SettingsMutation")
		case "update":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._SettingsMutation_update(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _SettingsMutation_update(ctx context.Context, field graphql.CollectedField, obj *customtypes.SettingsMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_SettingsMutation_update_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "SettingsMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SettingsMutation().Update(rctx, obj, args["settings"].(models.InputSettings))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Settings)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._Settings(ctx, field.Selections, res)
}

var settingsQueryImplementors = []string{"SettingsQuery"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SettingsQuery(ctx context.Context, sel ast.SelectionSet, obj *customtypes.SettingsQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, settingsQueryImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SettingsQuery")
		case "get":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._SettingsQuery_get(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _SettingsQuery_get(ctx context.Context, field graphql.CollectedField, obj *customtypes.SettingsQuery) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "SettingsQuery",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SettingsQuery().Get(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Settings)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._Settings(ctx, field.Selections, res)
}

var singleDestinationImplementors = []string{"SingleDestination"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SingleDestination(ctx context.Context, sel ast.SelectionSet, obj *models.SingleDestination) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, singleDestinationImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SingleDestination")
		case "upstream":
			out.Values[i] = ec._SingleDestination_upstream(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "destinationSpec":
			out.Values[i] = ec._SingleDestination_destinationSpec(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _SingleDestination_upstream(ctx context.Context, field graphql.CollectedField, obj *models.SingleDestination) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "SingleDestination",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Upstream, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Upstream)
	rctx.Result = res

	return ec._Upstream(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _SingleDestination_destinationSpec(ctx context.Context, field graphql.CollectedField, obj *models.SingleDestination) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "SingleDestination",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DestinationSpec, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.DestinationSpec)
	rctx.Result = res

	return ec._DestinationSpec(ctx, field.Selections, &res)
}

var sqoopDestinationSpecImplementors = []string{"SqoopDestinationSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SqoopDestinationSpec(ctx context.Context, sel ast.SelectionSet, obj *models.SqoopDestinationSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, sqoopDestinationSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqoopDestinationSpec")
		case "schema":
			out.Values[i] = ec._SqoopDestinationSpec_schema(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "playground":
			out.Values[i] = ec._SqoopDestinationSpec_playground(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _SqoopDestinationSpec_schema(ctx context.Context, field graphql.CollectedField, obj *models.SqoopDestinationSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "SqoopDestinationSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Schema, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Schema)
	rctx.Result = res

	return ec._Schema(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _SqoopDestinationSpec_playground(ctx context.Context, field graphql.CollectedField, obj *models.SqoopDestinationSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "SqoopDestinationSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Playground, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	return graphql.MarshalBoolean(res)
}

var sqoopServiceSpecImplementors = []string{"SqoopServiceSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SqoopServiceSpec(ctx context.Context, sel ast.SelectionSet, obj *models.SqoopServiceSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, sqoopServiceSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqoopServiceSpec")
		case "schemas":
			out.Values[i] = ec._SqoopServiceSpec_schemas(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _SqoopServiceSpec_schemas(ctx context.Context, field graphql.CollectedField, obj *models.SqoopServiceSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "SqoopServiceSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Schemas, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Schema)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				if res[idx1] == nil {
					return graphql.Null
				}

				return ec._Schema(ctx, field.Selections, res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var sslConfigImplementors = []string{"SslConfig"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SslConfig(ctx context.Context, sel ast.SelectionSet, obj *models.SslConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, sslConfigImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SslConfig")
		case "secretRef":
			out.Values[i] = ec._SslConfig_secretRef(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _SslConfig_secretRef(ctx context.Context, field graphql.CollectedField, obj *models.SslConfig) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "SslConfig",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SecretRef, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.ResourceRef)
	rctx.Result = res

	return ec._ResourceRef(ctx, field.Selections, &res)
}

var staticHostImplementors = []string{"StaticHost"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _StaticHost(ctx context.Context, sel ast.SelectionSet, obj *models.StaticHost) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, staticHostImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StaticHost")
		case "addr":
			out.Values[i] = ec._StaticHost_addr(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "port":
			out.Values[i] = ec._StaticHost_port(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _StaticHost_addr(ctx context.Context, field graphql.CollectedField, obj *models.StaticHost) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "StaticHost",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Addr, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _StaticHost_port(ctx context.Context, field graphql.CollectedField, obj *models.StaticHost) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "StaticHost",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Port, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	return graphql.MarshalInt(res)
}

var staticUpstreamSpecImplementors = []string{"StaticUpstreamSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _StaticUpstreamSpec(ctx context.Context, sel ast.SelectionSet, obj *models.StaticUpstreamSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, staticUpstreamSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StaticUpstreamSpec")
		case "hosts":
			out.Values[i] = ec._StaticUpstreamSpec_hosts(ctx, field, obj)
		case "serviceSpec":
			out.Values[i] = ec._StaticUpstreamSpec_serviceSpec(ctx, field, obj)
		case "useTls":
			out.Values[i] = ec._StaticUpstreamSpec_useTls(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _StaticUpstreamSpec_hosts(ctx context.Context, field graphql.CollectedField, obj *models.StaticUpstreamSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "StaticUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hosts, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.StaticHost)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._StaticHost(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _StaticUpstreamSpec_serviceSpec(ctx context.Context, field graphql.CollectedField, obj *models.StaticUpstreamSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "StaticUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceSpec, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.ServiceSpec)
	rctx.Result = res

	return ec._ServiceSpec(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _StaticUpstreamSpec_useTls(ctx context.Context, field graphql.CollectedField, obj *models.StaticUpstreamSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "StaticUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UseTLS, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	return graphql.MarshalBoolean(res)
}

var statusImplementors = []string{"Status"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Status(ctx context.Context, sel ast.SelectionSet, obj *models.Status) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, statusImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Status")
		case "state":
			out.Values[i] = ec._Status_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "reason":
			out.Values[i] = ec._Status_reason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Status_state(ctx context.Context, field graphql.CollectedField, obj *models.Status) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Status",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.State)
	rctx.Result = res
	return res
}

// nolint: vetshadow
func (ec *executionContext) _Status_reason(ctx context.Context, field graphql.CollectedField, obj *models.Status) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Status",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var subscriptionImplementors = []string{"Subscription"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func() graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, subscriptionImplementors)
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "upstreams":
		return ec._Subscription_upstreams(ctx, fields[0])
	case "virtualServices":
		return ec._Subscription_virtualServices(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

func (ec *executionContext) _Subscription_upstreams(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Subscription_upstreams_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	rctx := ctx // FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	results, err := ec.resolvers.Subscription().Upstreams(rctx, args["namespace"].(string), args["selector"].(*models.InputMapStringString))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			arr1 := make(graphql.Array, len(res))
			var wg sync.WaitGroup

			isLen1 := len(res) == 1
			if !isLen1 {
				wg.Add(len(res))
			}

			for idx1 := range res {
				idx1 := idx1
				rctx := &graphql.ResolverContext{
					Index:  &idx1,
					Result: res[idx1],
				}
				ctx := graphql.WithResolverContext(ctx, rctx)
				f := func(idx1 int) {
					if !isLen1 {
						defer wg.Done()
					}
					arr1[idx1] = func() graphql.Marshaler {

						if res[idx1] == nil {
							return graphql.Null
						}

						return ec._Upstream(ctx, field.Selections, res[idx1])
					}()
				}
				if isLen1 {
					f(idx1)
				} else {
					go f(idx1)
				}

			}
			wg.Wait()
			return arr1
		}())
		return &out
	}
}

func (ec *executionContext) _Subscription_virtualServices(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Subscription_virtualServices_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	rctx := ctx // FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	results, err := ec.resolvers.Subscription().VirtualServices(rctx, args["namespace"].(string), args["selector"].(*models.InputMapStringString))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			arr1 := make(graphql.Array, len(res))
			var wg sync.WaitGroup

			isLen1 := len(res) == 1
			if !isLen1 {
				wg.Add(len(res))
			}

			for idx1 := range res {
				idx1 := idx1
				rctx := &graphql.ResolverContext{
					Index:  &idx1,
					Result: res[idx1],
				}
				ctx := graphql.WithResolverContext(ctx, rctx)
				f := func(idx1 int) {
					if !isLen1 {
						defer wg.Done()
					}
					arr1[idx1] = func() graphql.Marshaler {

						if res[idx1] == nil {
							return graphql.Null
						}

						return ec._VirtualService(ctx, field.Selections, res[idx1])
					}()
				}
				if isLen1 {
					f(idx1)
				} else {
					go f(idx1)
				}

			}
			wg.Wait()
			return arr1
		}())
		return &out
	}
}

var templateResolverImplementors = []string{"TemplateResolver"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _TemplateResolver(ctx context.Context, sel ast.SelectionSet, obj *models.TemplateResolver) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, templateResolverImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TemplateResolver")
		case "inlineTemplate":
			out.Values[i] = ec._TemplateResolver_inlineTemplate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _TemplateResolver_inlineTemplate(ctx context.Context, field graphql.CollectedField, obj *models.TemplateResolver) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "TemplateResolver",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InlineTemplate, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var tlsSecretImplementors = []string{"TlsSecret"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _TlsSecret(ctx context.Context, sel ast.SelectionSet, obj *models.TlsSecret) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, tlsSecretImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TlsSecret")
		case "certChain":
			out.Values[i] = ec._TlsSecret_certChain(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "privateKey":
			out.Values[i] = ec._TlsSecret_privateKey(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "rootCa":
			out.Values[i] = ec._TlsSecret_rootCa(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _TlsSecret_certChain(ctx context.Context, field graphql.CollectedField, obj *models.TlsSecret) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "TlsSecret",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CertChain, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _TlsSecret_privateKey(ctx context.Context, field graphql.CollectedField, obj *models.TlsSecret) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "TlsSecret",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrivateKey, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _TlsSecret_rootCa(ctx context.Context, field graphql.CollectedField, obj *models.TlsSecret) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "TlsSecret",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RootCa, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

var transformationImplementors = []string{"Transformation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Transformation(ctx context.Context, sel ast.SelectionSet, obj *models.Transformation) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, transformationImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Transformation")
		case "functionName":
			out.Values[i] = ec._Transformation_functionName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "body":
			out.Values[i] = ec._Transformation_body(ctx, field, obj)
		case "headers":
			out.Values[i] = ec._Transformation_headers(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Transformation_functionName(ctx context.Context, field graphql.CollectedField, obj *models.Transformation) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Transformation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FunctionName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Transformation_body(ctx context.Context, field graphql.CollectedField, obj *models.Transformation) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Transformation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Body, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Transformation_headers(ctx context.Context, field graphql.CollectedField, obj *models.Transformation) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Transformation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Headers, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.MapStringString)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._MapStringString(ctx, field.Selections, res)
}

var transformationParametersImplementors = []string{"TransformationParameters"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _TransformationParameters(ctx context.Context, sel ast.SelectionSet, obj *models.TransformationParameters) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, transformationParametersImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransformationParameters")
		case "headers":
			out.Values[i] = ec._TransformationParameters_headers(ctx, field, obj)
		case "path":
			out.Values[i] = ec._TransformationParameters_path(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _TransformationParameters_headers(ctx context.Context, field graphql.CollectedField, obj *models.TransformationParameters) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "TransformationParameters",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Headers, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.MapStringString)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._MapStringString(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _TransformationParameters_path(ctx context.Context, field graphql.CollectedField, obj *models.TransformationParameters) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "TransformationParameters",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var typeResolverImplementors = []string{"TypeResolver"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _TypeResolver(ctx context.Context, sel ast.SelectionSet, obj *models.TypeResolver) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, typeResolverImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TypeResolver")
		case "typeName":
			out.Values[i] = ec._TypeResolver_typeName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "fields":
			out.Values[i] = ec._TypeResolver_fields(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _TypeResolver_typeName(ctx context.Context, field graphql.CollectedField, obj *models.TypeResolver) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "TypeResolver",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _TypeResolver_fields(ctx context.Context, field graphql.CollectedField, obj *models.TypeResolver) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "TypeResolver",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.FieldResolver)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._FieldResolver(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var upstreamImplementors = []string{"Upstream"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Upstream(ctx context.Context, sel ast.SelectionSet, obj *models.Upstream) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, upstreamImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Upstream")
		case "spec":
			out.Values[i] = ec._Upstream_spec(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "metadata":
			out.Values[i] = ec._Upstream_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._Upstream_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Upstream_spec(ctx context.Context, field graphql.CollectedField, obj *models.Upstream) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Upstream",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Spec, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.UpstreamSpec)
	rctx.Result = res

	return ec._UpstreamSpec(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Upstream_metadata(ctx context.Context, field graphql.CollectedField, obj *models.Upstream) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Upstream",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Metadata)
	rctx.Result = res

	return ec._Metadata(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Upstream_status(ctx context.Context, field graphql.CollectedField, obj *models.Upstream) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Upstream",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Status)
	rctx.Result = res

	return ec._Status(ctx, field.Selections, &res)
}

var upstreamMutationImplementors = []string{"UpstreamMutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _UpstreamMutation(ctx context.Context, sel ast.SelectionSet, obj *customtypes.UpstreamMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, upstreamMutationImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpstreamMutation")
		case "create":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._UpstreamMutation_create(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "update":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._UpstreamMutation_update(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "delete":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._UpstreamMutation_delete(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _UpstreamMutation_create(ctx context.Context, field graphql.CollectedField, obj *customtypes.UpstreamMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_UpstreamMutation_create_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "UpstreamMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UpstreamMutation().Create(rctx, obj, args["upstream"].(models.InputUpstream))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Upstream)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._Upstream(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _UpstreamMutation_update(ctx context.Context, field graphql.CollectedField, obj *customtypes.UpstreamMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_UpstreamMutation_update_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "UpstreamMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UpstreamMutation().Update(rctx, obj, args["upstream"].(models.InputUpstream))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Upstream)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._Upstream(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _UpstreamMutation_delete(ctx context.Context, field graphql.CollectedField, obj *customtypes.UpstreamMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_UpstreamMutation_delete_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "UpstreamMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UpstreamMutation().Delete(rctx, obj, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Upstream)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._Upstream(ctx, field.Selections, res)
}

var upstreamQueryImplementors = []string{"UpstreamQuery"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _UpstreamQuery(ctx context.Context, sel ast.SelectionSet, obj *customtypes.UpstreamQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, upstreamQueryImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpstreamQuery")
		case "list":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._UpstreamQuery_list(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "get":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._UpstreamQuery_get(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _UpstreamQuery_list(ctx context.Context, field graphql.CollectedField, obj *customtypes.UpstreamQuery) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_UpstreamQuery_list_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "UpstreamQuery",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UpstreamQuery().List(rctx, obj, args["selector"].(*models.InputMapStringString))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Upstream)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				if res[idx1] == nil {
					return graphql.Null
				}

				return ec._Upstream(ctx, field.Selections, res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _UpstreamQuery_get(ctx context.Context, field graphql.CollectedField, obj *customtypes.UpstreamQuery) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_UpstreamQuery_get_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "UpstreamQuery",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UpstreamQuery().Get(rctx, obj, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Upstream)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._Upstream(ctx, field.Selections, res)
}

var valueImplementors = []string{"Value"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Value(ctx context.Context, sel ast.SelectionSet, obj *models.Value) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, valueImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Value")
		case "key":
			out.Values[i] = ec._Value_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "value":
			out.Values[i] = ec._Value_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Value_key(ctx context.Context, field graphql.CollectedField, obj *models.Value) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Value",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Value_value(ctx context.Context, field graphql.CollectedField, obj *models.Value) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Value",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

var virtualServiceImplementors = []string{"VirtualService"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _VirtualService(ctx context.Context, sel ast.SelectionSet, obj *models.VirtualService) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, virtualServiceImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VirtualService")
		case "domains":
			out.Values[i] = ec._VirtualService_domains(ctx, field, obj)
		case "routes":
			out.Values[i] = ec._VirtualService_routes(ctx, field, obj)
		case "sslConfig":
			out.Values[i] = ec._VirtualService_sslConfig(ctx, field, obj)
		case "plugins":
			out.Values[i] = ec._VirtualService_plugins(ctx, field, obj)
		case "metadata":
			out.Values[i] = ec._VirtualService_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._VirtualService_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _VirtualService_domains(ctx context.Context, field graphql.CollectedField, obj *models.VirtualService) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "VirtualService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Domains, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _VirtualService_routes(ctx context.Context, field graphql.CollectedField, obj *models.VirtualService) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "VirtualService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Routes, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.Route)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Route(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _VirtualService_sslConfig(ctx context.Context, field graphql.CollectedField, obj *models.VirtualService) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "VirtualService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SslConfig, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.SslConfig)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._SslConfig(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _VirtualService_plugins(ctx context.Context, field graphql.CollectedField, obj *models.VirtualService) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "VirtualService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Plugins, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.VirtualServicePlugins)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._VirtualServicePlugins(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _VirtualService_metadata(ctx context.Context, field graphql.CollectedField, obj *models.VirtualService) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "VirtualService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Metadata)
	rctx.Result = res

	return ec._Metadata(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _VirtualService_status(ctx context.Context, field graphql.CollectedField, obj *models.VirtualService) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "VirtualService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Status)
	rctx.Result = res

	return ec._Status(ctx, field.Selections, &res)
}

var virtualServiceMutationImplementors = []string{"VirtualServiceMutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _VirtualServiceMutation(ctx context.Context, sel ast.SelectionSet, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, virtualServiceMutationImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VirtualServiceMutation")
		case "create":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._VirtualServiceMutation_create(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "update":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._VirtualServiceMutation_update(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "delete":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._VirtualServiceMutation_delete(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "addRoute":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._VirtualServiceMutation_addRoute(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "updateRoute":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._VirtualServiceMutation_updateRoute(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "deleteRoute":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._VirtualServiceMutation_deleteRoute(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "swapRoutes":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._VirtualServiceMutation_swapRoutes(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "shiftRoutes":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._VirtualServiceMutation_shiftRoutes(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _VirtualServiceMutation_create(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_VirtualServiceMutation_create_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "VirtualServiceMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.VirtualServiceMutation().Create(rctx, obj, args["virtualService"].(models.InputVirtualService))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.VirtualService)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._VirtualService(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _VirtualServiceMutation_update(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_VirtualServiceMutation_update_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "VirtualServiceMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.VirtualServiceMutation().Update(rctx, obj, args["name"].(string), args["resourceVersion"].(string), args["updates"].(models.InputUpdateVirtualService))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.VirtualService)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._VirtualService(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _VirtualServiceMutation_delete(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_VirtualServiceMutation_delete_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "VirtualServiceMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.VirtualServiceMutation().Delete(rctx, obj, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.VirtualService)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._VirtualService(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _VirtualServiceMutation_addRoute(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_VirtualServiceMutation_addRoute_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "VirtualServiceMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.VirtualServiceMutation().AddRoute(rctx, obj, args["virtualServiceName"].(string), args["resourceVersion"].(string), args["index"].(int), args["route"].(models.InputRoute))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.VirtualService)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._VirtualService(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _VirtualServiceMutation_updateRoute(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_VirtualServiceMutation_updateRoute_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "VirtualServiceMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.VirtualServiceMutation().UpdateRoute(rctx, obj, args["virtualServiceName"].(string), args["resourceVersion"].(string), args["index"].(int), args["route"].(models.InputRoute))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.VirtualService)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._VirtualService(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _VirtualServiceMutation_deleteRoute(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_VirtualServiceMutation_deleteRoute_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "VirtualServiceMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.VirtualServiceMutation().DeleteRoute(rctx, obj, args["virtualServiceName"].(string), args["resourceVersion"].(string), args["index"].(int))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.VirtualService)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._VirtualService(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _VirtualServiceMutation_swapRoutes(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_VirtualServiceMutation_swapRoutes_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "VirtualServiceMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.VirtualServiceMutation().SwapRoutes(rctx, obj, args["virtualServiceName"].(string), args["resourceVersion"].(string), args["index1"].(int), args["index2"].(int))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.VirtualService)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._VirtualService(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _VirtualServiceMutation_shiftRoutes(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_VirtualServiceMutation_shiftRoutes_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "VirtualServiceMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.VirtualServiceMutation().ShiftRoutes(rctx, obj, args["virtualServiceName"].(string), args["resourceVersion"].(string), args["fromIndex"].(int), args["toIndex"].(int))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.VirtualService)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._VirtualService(ctx, field.Selections, res)
}

var virtualServicePluginsImplementors = []string{"VirtualServicePlugins"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _VirtualServicePlugins(ctx context.Context, sel ast.SelectionSet, obj *models.VirtualServicePlugins) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, virtualServicePluginsImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VirtualServicePlugins")
		case "empty":
			out.Values[i] = ec._VirtualServicePlugins_empty(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _VirtualServicePlugins_empty(ctx context.Context, field graphql.CollectedField, obj *models.VirtualServicePlugins) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "VirtualServicePlugins",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Empty, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var virtualServiceQueryImplementors = []string{"VirtualServiceQuery"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _VirtualServiceQuery(ctx context.Context, sel ast.SelectionSet, obj *customtypes.VirtualServiceQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, virtualServiceQueryImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VirtualServiceQuery")
		case "list":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._VirtualServiceQuery_list(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "get":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._VirtualServiceQuery_get(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _VirtualServiceQuery_list(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceQuery) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_VirtualServiceQuery_list_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "VirtualServiceQuery",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.VirtualServiceQuery().List(rctx, obj, args["selector"].(*models.InputMapStringString))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.VirtualService)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				if res[idx1] == nil {
					return graphql.Null
				}

				return ec._VirtualService(ctx, field.Selections, res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _VirtualServiceQuery_get(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceQuery) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_VirtualServiceQuery_get_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "VirtualServiceQuery",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.VirtualServiceQuery().Get(rctx, obj, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.VirtualService)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec._VirtualService(ctx, field.Selections, res)
}

var weightedDestinationImplementors = []string{"WeightedDestination"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _WeightedDestination(ctx context.Context, sel ast.SelectionSet, obj *models.WeightedDestination) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, weightedDestinationImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WeightedDestination")
		case "destination":
			out.Values[i] = ec._WeightedDestination_destination(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "weight":
			out.Values[i] = ec._WeightedDestination_weight(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _WeightedDestination_destination(ctx context.Context, field graphql.CollectedField, obj *models.WeightedDestination) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "WeightedDestination",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Destination, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.SingleDestination)
	rctx.Result = res

	return ec._SingleDestination(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _WeightedDestination_weight(ctx context.Context, field graphql.CollectedField, obj *models.WeightedDestination) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "WeightedDestination",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Weight, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	return graphql.MarshalInt(res)
}

var __DirectiveImplementors = []string{"__Directive"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __DirectiveImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___InputValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var __EnumValueImplementors = []string{"__EnumValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __EnumValueImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

var __FieldImplementors = []string{"__Field"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __FieldImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___InputValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

var __InputValueImplementors = []string{"__InputValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __InputValueImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __SchemaImplementors = []string{"__Schema"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __SchemaImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Type(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Directive(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var __TypeImplementors = []string{"__Type"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __TypeImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field___Type_fields_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Field(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Type(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Type(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field___Type_enumValues_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___EnumValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___InputValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) _Destination(ctx context.Context, sel ast.SelectionSet, obj *models.Destination) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case models.MultiDestination:
		return ec._MultiDestination(ctx, sel, &obj)
	case *models.MultiDestination:
		return ec._MultiDestination(ctx, sel, obj)
	case models.SingleDestination:
		return ec._SingleDestination(ctx, sel, &obj)
	case *models.SingleDestination:
		return ec._SingleDestination(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _DestinationSpec(ctx context.Context, sel ast.SelectionSet, obj *models.DestinationSpec) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case models.AwsDestinationSpec:
		return ec._AwsDestinationSpec(ctx, sel, &obj)
	case *models.AwsDestinationSpec:
		return ec._AwsDestinationSpec(ctx, sel, obj)
	case models.AzureDestinationSpec:
		return ec._AzureDestinationSpec(ctx, sel, &obj)
	case *models.AzureDestinationSpec:
		return ec._AzureDestinationSpec(ctx, sel, obj)
	case models.RestDestinationSpec:
		return ec._RestDestinationSpec(ctx, sel, &obj)
	case *models.RestDestinationSpec:
		return ec._RestDestinationSpec(ctx, sel, obj)
	case models.GrpcDestinationSpec:
		return ec._GrpcDestinationSpec(ctx, sel, &obj)
	case *models.GrpcDestinationSpec:
		return ec._GrpcDestinationSpec(ctx, sel, obj)
	case models.SqoopDestinationSpec:
		return ec._SqoopDestinationSpec(ctx, sel, &obj)
	case *models.SqoopDestinationSpec:
		return ec._SqoopDestinationSpec(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Resolver(ctx context.Context, sel ast.SelectionSet, obj *models.Resolver) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case models.GlooResolver:
		return ec._GlooResolver(ctx, sel, &obj)
	case *models.GlooResolver:
		return ec._GlooResolver(ctx, sel, obj)
	case models.TemplateResolver:
		return ec._TemplateResolver(ctx, sel, &obj)
	case *models.TemplateResolver:
		return ec._TemplateResolver(ctx, sel, obj)
	case models.NodeJSResolver:
		return ec._NodeJSResolver(ctx, sel, &obj)
	case *models.NodeJSResolver:
		return ec._NodeJSResolver(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Resource(ctx context.Context, sel ast.SelectionSet, obj *models.Resource) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case models.Upstream:
		return ec._Upstream(ctx, sel, &obj)
	case *models.Upstream:
		return ec._Upstream(ctx, sel, obj)
	case models.VirtualService:
		return ec._VirtualService(ctx, sel, &obj)
	case *models.VirtualService:
		return ec._VirtualService(ctx, sel, obj)
	case models.ResolverMap:
		return ec._ResolverMap(ctx, sel, &obj)
	case *models.ResolverMap:
		return ec._ResolverMap(ctx, sel, obj)
	case models.Schema:
		return ec._Schema(ctx, sel, &obj)
	case *models.Schema:
		return ec._Schema(ctx, sel, obj)
	case models.Secret:
		return ec._Secret(ctx, sel, &obj)
	case *models.Secret:
		return ec._Secret(ctx, sel, obj)
	case models.Artifact:
		return ec._Artifact(ctx, sel, &obj)
	case *models.Artifact:
		return ec._Artifact(ctx, sel, obj)
	case models.Settings:
		return ec._Settings(ctx, sel, &obj)
	case *models.Settings:
		return ec._Settings(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _SecretKind(ctx context.Context, sel ast.SelectionSet, obj *models.SecretKind) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case models.AwsSecret:
		return ec._AwsSecret(ctx, sel, &obj)
	case *models.AwsSecret:
		return ec._AwsSecret(ctx, sel, obj)
	case models.AzureSecret:
		return ec._AzureSecret(ctx, sel, &obj)
	case *models.AzureSecret:
		return ec._AzureSecret(ctx, sel, obj)
	case models.TlsSecret:
		return ec._TlsSecret(ctx, sel, &obj)
	case *models.TlsSecret:
		return ec._TlsSecret(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ServiceSpec(ctx context.Context, sel ast.SelectionSet, obj *models.ServiceSpec) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case models.RestServiceSpec:
		return ec._RestServiceSpec(ctx, sel, &obj)
	case *models.RestServiceSpec:
		return ec._RestServiceSpec(ctx, sel, obj)
	case models.GrpcServiceSpec:
		return ec._GrpcServiceSpec(ctx, sel, &obj)
	case *models.GrpcServiceSpec:
		return ec._GrpcServiceSpec(ctx, sel, obj)
	case models.SqoopServiceSpec:
		return ec._SqoopServiceSpec(ctx, sel, &obj)
	case *models.SqoopServiceSpec:
		return ec._SqoopServiceSpec(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UpstreamSpec(ctx context.Context, sel ast.SelectionSet, obj *models.UpstreamSpec) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case models.AwsUpstreamSpec:
		return ec._AwsUpstreamSpec(ctx, sel, &obj)
	case *models.AwsUpstreamSpec:
		return ec._AwsUpstreamSpec(ctx, sel, obj)
	case models.AzureUpstreamSpec:
		return ec._AzureUpstreamSpec(ctx, sel, &obj)
	case *models.AzureUpstreamSpec:
		return ec._AzureUpstreamSpec(ctx, sel, obj)
	case models.KubeUpstreamSpec:
		return ec._KubeUpstreamSpec(ctx, sel, &obj)
	case *models.KubeUpstreamSpec:
		return ec._KubeUpstreamSpec(ctx, sel, obj)
	case models.StaticUpstreamSpec:
		return ec._StaticUpstreamSpec(ctx, sel, &obj)
	case *models.StaticUpstreamSpec:
		return ec._StaticUpstreamSpec(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func UnmarshalInputArtifact(v interface{}) (models.InputArtifact, error) {
	var it models.InputArtifact
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "data":
			var err error
			it.Data, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "metadata":
			var err error
			it.Metadata, err = UnmarshalInputMetadata(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputAwsDestinationSpec(v interface{}) (models.InputAwsDestinationSpec, error) {
	var it models.InputAwsDestinationSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "logicalName":
			var err error
			it.LogicalName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "invocationStyle":
			var err error
			err = (&it.InvocationStyle).UnmarshalGQL(v)
			if err != nil {
				return it, err
			}
		case "responseTransformation":
			var err error
			it.ResponseTransformation, err = graphql.UnmarshalBoolean(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputAwsLambdaFunction(v interface{}) (models.InputAwsLambdaFunction, error) {
	var it models.InputAwsLambdaFunction
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "logicalName":
			var err error
			it.LogicalName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "functionName":
			var err error
			it.FunctionName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "qualifier":
			var err error
			it.Qualifier, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputAwsSecret(v interface{}) (models.InputAwsSecret, error) {
	var it models.InputAwsSecret
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "accessKey":
			var err error
			it.AccessKey, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "secretKey":
			var err error
			it.SecretKey, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputAwsUpstreamSpec(v interface{}) (models.InputAwsUpstreamSpec, error) {
	var it models.InputAwsUpstreamSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "region":
			var err error
			it.Region, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "secretRef":
			var err error
			it.SecretRef, err = UnmarshalInputResourceRef(v)
			if err != nil {
				return it, err
			}
		case "functions":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Functions = make([]models.InputAwsLambdaFunction, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Functions[idx1], err = UnmarshalInputAwsLambdaFunction(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputAzureDestinationSpec(v interface{}) (models.InputAzureDestinationSpec, error) {
	var it models.InputAzureDestinationSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "functionName":
			var err error
			it.FunctionName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputAzureFunction(v interface{}) (models.InputAzureFunction, error) {
	var it models.InputAzureFunction
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "functionName":
			var err error
			it.FunctionName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "authLevel":
			var err error
			it.AuthLevel, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputAzureSecret(v interface{}) (models.InputAzureSecret, error) {
	var it models.InputAzureSecret
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "apiKeys":
			var err error
			it.APIKeys, err = UnmarshalInputMapStringString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputAzureUpstreamSpec(v interface{}) (models.InputAzureUpstreamSpec, error) {
	var it models.InputAzureUpstreamSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "functionAppName":
			var err error
			it.FunctionAppName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "secretRef":
			var err error
			var ptr1 models.InputResourceRef
			if v != nil {
				ptr1, err = UnmarshalInputResourceRef(v)
				it.SecretRef = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "functions":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Functions = make([]models.InputAzureFunction, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Functions[idx1], err = UnmarshalInputAzureFunction(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputDestination(v interface{}) (models.InputDestination, error) {
	var it models.InputDestination
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "singleDestination":
			var err error
			var ptr1 models.InputSingleDestination
			if v != nil {
				ptr1, err = UnmarshalInputSingleDestination(v)
				it.SingleDestination = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "multiDestination":
			var err error
			var ptr1 models.InputMultiDestination
			if v != nil {
				ptr1, err = UnmarshalInputMultiDestination(v)
				it.MultiDestination = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputDestinationSpec(v interface{}) (models.InputDestinationSpec, error) {
	var it models.InputDestinationSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "aws":
			var err error
			var ptr1 models.InputAwsDestinationSpec
			if v != nil {
				ptr1, err = UnmarshalInputAwsDestinationSpec(v)
				it.Aws = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "azure":
			var err error
			var ptr1 models.InputAzureDestinationSpec
			if v != nil {
				ptr1, err = UnmarshalInputAzureDestinationSpec(v)
				it.Azure = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "rest":
			var err error
			var ptr1 models.InputRestDestinationSpec
			if v != nil {
				ptr1, err = UnmarshalInputRestDestinationSpec(v)
				it.Rest = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "grpc":
			var err error
			var ptr1 models.InputGrpcDestinationSpec
			if v != nil {
				ptr1, err = UnmarshalInputGrpcDestinationSpec(v)
				it.Grpc = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "sqoop":
			var err error
			var ptr1 models.InputSqoopDestinationSpec
			if v != nil {
				ptr1, err = UnmarshalInputSqoopDestinationSpec(v)
				it.Sqoop = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputFieldResolver(v interface{}) (models.InputFieldResolver, error) {
	var it models.InputFieldResolver
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "fieldName":
			var err error
			it.FieldName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "resolver":
			var err error
			it.Resolver, err = UnmarshalInputResolver(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputGlooResolver(v interface{}) (models.InputGlooResolver, error) {
	var it models.InputGlooResolver
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "requestTemplate":
			var err error
			var ptr1 models.InputRequestTemplate
			if v != nil {
				ptr1, err = UnmarshalInputRequestTemplate(v)
				it.RequestTemplate = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "responseTemplate":
			var err error
			var ptr1 models.InputResponseTemplate
			if v != nil {
				ptr1, err = UnmarshalInputResponseTemplate(v)
				it.ResponseTemplate = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "destination":
			var err error
			it.Destination, err = UnmarshalInputDestination(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputGrpcDestinationSpec(v interface{}) (models.InputGrpcDestinationSpec, error) {
	var it models.InputGrpcDestinationSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "package":
			var err error
			it.Package, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "service":
			var err error
			it.Service, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "function":
			var err error
			it.Function, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputGrpcServiceSpec(v interface{}) (models.InputGrpcServiceSpec, error) {
	var it models.InputGrpcServiceSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "empty":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Empty = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputKeyValueMatcher(v interface{}) (models.InputKeyValueMatcher, error) {
	var it models.InputKeyValueMatcher
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "value":
			var err error
			it.Value, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "isRegex":
			var err error
			it.IsRegex, err = graphql.UnmarshalBoolean(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputKubeUpstreamSpec(v interface{}) (models.InputKubeUpstreamSpec, error) {
	var it models.InputKubeUpstreamSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "serviceName":
			var err error
			it.ServiceName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "serviceNamespace":
			var err error
			it.ServiceNamespace, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "servicePort":
			var err error
			it.ServicePort, err = graphql.UnmarshalInt(v)
			if err != nil {
				return it, err
			}
		case "selector":
			var err error
			var ptr1 models.InputMapStringString
			if v != nil {
				ptr1, err = UnmarshalInputMapStringString(v)
				it.Selector = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "serviceSpec":
			var err error
			var ptr1 models.InputServiceSpec
			if v != nil {
				ptr1, err = UnmarshalInputServiceSpec(v)
				it.ServiceSpec = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputMapStringString(v interface{}) (models.InputMapStringString, error) {
	var it models.InputMapStringString
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "values":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Values = make([]models.InputValue, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Values[idx1], err = UnmarshalInputValue(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputMatcher(v interface{}) (models.InputMatcher, error) {
	var it models.InputMatcher
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "pathMatch":
			var err error
			it.PathMatch, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "pathMatchType":
			var err error
			err = (&it.PathMatchType).UnmarshalGQL(v)
			if err != nil {
				return it, err
			}
		case "headers":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Headers = make([]models.InputKeyValueMatcher, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Headers[idx1], err = UnmarshalInputKeyValueMatcher(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "queryParameters":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.QueryParameters = make([]models.InputKeyValueMatcher, len(rawIf1))
			for idx1 := range rawIf1 {
				it.QueryParameters[idx1], err = UnmarshalInputKeyValueMatcher(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "methods":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Methods = make([]string, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Methods[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputMetadata(v interface{}) (models.InputMetadata, error) {
	var it models.InputMetadata
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "namespace":
			var err error
			it.Namespace, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "resourceVersion":
			var err error
			it.ResourceVersion, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "labels":
			var err error
			var ptr1 models.InputMapStringString
			if v != nil {
				ptr1, err = UnmarshalInputMapStringString(v)
				it.Labels = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "annotations":
			var err error
			var ptr1 models.InputMapStringString
			if v != nil {
				ptr1, err = UnmarshalInputMapStringString(v)
				it.Annotations = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputMultiDestination(v interface{}) (models.InputMultiDestination, error) {
	var it models.InputMultiDestination
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "destinations":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Destinations = make([]models.InputWeightedDestination, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Destinations[idx1], err = UnmarshalInputWeightedDestination(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputNodeJSResolver(v interface{}) (models.InputNodeJSResolver, error) {
	var it models.InputNodeJSResolver
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "empty":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Empty = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputRequestTemplate(v interface{}) (models.InputRequestTemplate, error) {
	var it models.InputRequestTemplate
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "verb":
			var err error
			it.Verb, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "path":
			var err error
			it.Path, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "body":
			var err error
			it.Body, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "headers":
			var err error
			var ptr1 models.InputMapStringString
			if v != nil {
				ptr1, err = UnmarshalInputMapStringString(v)
				it.Headers = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputResolver(v interface{}) (models.InputResolver, error) {
	var it models.InputResolver
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "glooResolver":
			var err error
			var ptr1 models.InputGlooResolver
			if v != nil {
				ptr1, err = UnmarshalInputGlooResolver(v)
				it.GlooResolver = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "templateResolver":
			var err error
			var ptr1 models.InputTemplateResolver
			if v != nil {
				ptr1, err = UnmarshalInputTemplateResolver(v)
				it.TemplateResolver = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "nodeResolver":
			var err error
			var ptr1 models.InputNodeJSResolver
			if v != nil {
				ptr1, err = UnmarshalInputNodeJSResolver(v)
				it.NodeResolver = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputResolverMap(v interface{}) (models.InputResolverMap, error) {
	var it models.InputResolverMap
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "types":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Types = make([]models.InputTypeResolver, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Types[idx1], err = UnmarshalInputTypeResolver(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "metadata":
			var err error
			it.Metadata, err = UnmarshalInputMetadata(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputResourceRef(v interface{}) (models.InputResourceRef, error) {
	var it models.InputResourceRef
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "namespace":
			var err error
			it.Namespace, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputResponseTemplate(v interface{}) (models.InputResponseTemplate, error) {
	var it models.InputResponseTemplate
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "body":
			var err error
			it.Body, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "headers":
			var err error
			var ptr1 models.InputMapStringString
			if v != nil {
				ptr1, err = UnmarshalInputMapStringString(v)
				it.Headers = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputRestDestinationSpec(v interface{}) (models.InputRestDestinationSpec, error) {
	var it models.InputRestDestinationSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "functionName":
			var err error
			it.FunctionName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "parameters":
			var err error
			var ptr1 models.InputTransformationParameters
			if v != nil {
				ptr1, err = UnmarshalInputTransformationParameters(v)
				it.Parameters = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputRestServiceSpec(v interface{}) (models.InputRestServiceSpec, error) {
	var it models.InputRestServiceSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "functions":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Functions = make([]models.InputTransformation, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Functions[idx1], err = UnmarshalInputTransformation(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "inlineSwaggerDoc":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.InlineSwaggerDoc = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputRoute(v interface{}) (models.InputRoute, error) {
	var it models.InputRoute
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "matcher":
			var err error
			it.Matcher, err = UnmarshalInputMatcher(v)
			if err != nil {
				return it, err
			}
		case "destination":
			var err error
			it.Destination, err = UnmarshalInputDestination(v)
			if err != nil {
				return it, err
			}
		case "plugins":
			var err error
			var ptr1 models.InputRoutePlugins
			if v != nil {
				ptr1, err = UnmarshalInputRoutePlugins(v)
				it.Plugins = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputRoutePlugins(v interface{}) (models.InputRoutePlugins, error) {
	var it models.InputRoutePlugins
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "empty":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Empty = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputSchema(v interface{}) (models.InputSchema, error) {
	var it models.InputSchema
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "inlineSchema":
			var err error
			it.InlineSchema, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "metadata":
			var err error
			it.Metadata, err = UnmarshalInputMetadata(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputSecret(v interface{}) (models.InputSecret, error) {
	var it models.InputSecret
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "kind":
			var err error
			it.Kind, err = UnmarshalInputSecretKind(v)
			if err != nil {
				return it, err
			}
		case "metadata":
			var err error
			it.Metadata, err = UnmarshalInputMetadata(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputSecretKind(v interface{}) (models.InputSecretKind, error) {
	var it models.InputSecretKind
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "aws":
			var err error
			var ptr1 models.InputAwsSecret
			if v != nil {
				ptr1, err = UnmarshalInputAwsSecret(v)
				it.Aws = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "azure":
			var err error
			var ptr1 models.InputAzureSecret
			if v != nil {
				ptr1, err = UnmarshalInputAzureSecret(v)
				it.Azure = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "tls":
			var err error
			var ptr1 models.InputTlsSecret
			if v != nil {
				ptr1, err = UnmarshalInputTlsSecret(v)
				it.TLS = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputServiceSpec(v interface{}) (models.InputServiceSpec, error) {
	var it models.InputServiceSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "rest":
			var err error
			var ptr1 models.InputRestServiceSpec
			if v != nil {
				ptr1, err = UnmarshalInputRestServiceSpec(v)
				it.Rest = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "grpc":
			var err error
			var ptr1 models.InputGrpcServiceSpec
			if v != nil {
				ptr1, err = UnmarshalInputGrpcServiceSpec(v)
				it.Grpc = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputSettings(v interface{}) (models.InputSettings, error) {
	var it models.InputSettings
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "watchNamespaces":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.WatchNamespaces = make([]string, len(rawIf1))
			for idx1 := range rawIf1 {
				it.WatchNamespaces[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "refreshRate":
			var err error
			var ptr1 customtypes.Duration
			if v != nil {
				err = (&ptr1).UnmarshalGQL(v)
				it.RefreshRate = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "metadata":
			var err error
			it.Metadata, err = UnmarshalInputMetadata(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputSingleDestination(v interface{}) (models.InputSingleDestination, error) {
	var it models.InputSingleDestination
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "upstream":
			var err error
			it.Upstream, err = UnmarshalInputResourceRef(v)
			if err != nil {
				return it, err
			}
		case "destinationSpec":
			var err error
			var ptr1 models.InputDestinationSpec
			if v != nil {
				ptr1, err = UnmarshalInputDestinationSpec(v)
				it.DestinationSpec = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputSqoopDestinationSpec(v interface{}) (models.InputSqoopDestinationSpec, error) {
	var it models.InputSqoopDestinationSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "schemaName":
			var err error
			it.SchemaName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "schemaNamespace":
			var err error
			it.SchemaNamespace, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "playground":
			var err error
			it.Playground, err = graphql.UnmarshalBoolean(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputSslConfig(v interface{}) (models.InputSslConfig, error) {
	var it models.InputSslConfig
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "secretRef":
			var err error
			it.SecretRef, err = UnmarshalInputResourceRef(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputStaticHost(v interface{}) (models.InputStaticHost, error) {
	var it models.InputStaticHost
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "addr":
			var err error
			it.Addr, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "port":
			var err error
			it.Port, err = graphql.UnmarshalInt(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputStaticUpstreamSpec(v interface{}) (models.InputStaticUpstreamSpec, error) {
	var it models.InputStaticUpstreamSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "hosts":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Hosts = make([]models.InputStaticHost, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Hosts[idx1], err = UnmarshalInputStaticHost(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "serviceSpec":
			var err error
			var ptr1 models.InputServiceSpec
			if v != nil {
				ptr1, err = UnmarshalInputServiceSpec(v)
				it.ServiceSpec = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "useTls":
			var err error
			it.UseTLS, err = graphql.UnmarshalBoolean(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputStatus(v interface{}) (models.InputStatus, error) {
	var it models.InputStatus
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "state":
			var err error
			err = (&it.State).UnmarshalGQL(v)
			if err != nil {
				return it, err
			}
		case "reason":
			var err error
			it.Reason, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputTemplateResolver(v interface{}) (models.InputTemplateResolver, error) {
	var it models.InputTemplateResolver
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "empty":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Empty = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputTlsSecret(v interface{}) (models.InputTlsSecret, error) {
	var it models.InputTlsSecret
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "certChain":
			var err error
			it.CertChain, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "privateKey":
			var err error
			it.PrivateKey, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "rootCa":
			var err error
			it.RootCa, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputTransformation(v interface{}) (models.InputTransformation, error) {
	var it models.InputTransformation
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "functionName":
			var err error
			it.FunctionName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "body":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Body = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "headers":
			var err error
			var ptr1 models.InputMapStringString
			if v != nil {
				ptr1, err = UnmarshalInputMapStringString(v)
				it.Headers = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputTransformationParameters(v interface{}) (models.InputTransformationParameters, error) {
	var it models.InputTransformationParameters
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "headers":
			var err error
			var ptr1 models.InputMapStringString
			if v != nil {
				ptr1, err = UnmarshalInputMapStringString(v)
				it.Headers = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "path":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Path = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputTypeResolver(v interface{}) (models.InputTypeResolver, error) {
	var it models.InputTypeResolver
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "typeName":
			var err error
			it.TypeName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "fields":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Fields = make([]models.InputFieldResolver, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Fields[idx1], err = UnmarshalInputFieldResolver(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputUpdateMetadata(v interface{}) (models.InputUpdateMetadata, error) {
	var it models.InputUpdateMetadata
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Name = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "labels":
			var err error
			var ptr1 models.InputMapStringString
			if v != nil {
				ptr1, err = UnmarshalInputMapStringString(v)
				it.Labels = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "annotations":
			var err error
			var ptr1 models.InputMapStringString
			if v != nil {
				ptr1, err = UnmarshalInputMapStringString(v)
				it.Annotations = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputUpdateVirtualService(v interface{}) (models.InputUpdateVirtualService, error) {
	var it models.InputUpdateVirtualService
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "domains":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Domains = make([]string, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Domains[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "sslConfig":
			var err error
			var ptr1 models.InputSslConfig
			if v != nil {
				ptr1, err = UnmarshalInputSslConfig(v)
				it.SslConfig = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "plugins":
			var err error
			var ptr1 models.InputVirtualServicePlugins
			if v != nil {
				ptr1, err = UnmarshalInputVirtualServicePlugins(v)
				it.Plugins = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "metadata":
			var err error
			var ptr1 models.InputUpdateMetadata
			if v != nil {
				ptr1, err = UnmarshalInputUpdateMetadata(v)
				it.Metadata = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputUpstream(v interface{}) (models.InputUpstream, error) {
	var it models.InputUpstream
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "spec":
			var err error
			it.Spec, err = UnmarshalInputUpstreamSpec(v)
			if err != nil {
				return it, err
			}
		case "metadata":
			var err error
			it.Metadata, err = UnmarshalInputMetadata(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputUpstreamSpec(v interface{}) (models.InputUpstreamSpec, error) {
	var it models.InputUpstreamSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "aws":
			var err error
			var ptr1 models.InputAwsUpstreamSpec
			if v != nil {
				ptr1, err = UnmarshalInputAwsUpstreamSpec(v)
				it.Aws = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "azure":
			var err error
			var ptr1 models.InputAzureUpstreamSpec
			if v != nil {
				ptr1, err = UnmarshalInputAzureUpstreamSpec(v)
				it.Azure = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "kube":
			var err error
			var ptr1 models.InputKubeUpstreamSpec
			if v != nil {
				ptr1, err = UnmarshalInputKubeUpstreamSpec(v)
				it.Kube = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "static":
			var err error
			var ptr1 models.InputStaticUpstreamSpec
			if v != nil {
				ptr1, err = UnmarshalInputStaticUpstreamSpec(v)
				it.Static = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputValue(v interface{}) (models.InputValue, error) {
	var it models.InputValue
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "key":
			var err error
			it.Key, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "value":
			var err error
			it.Value, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputVirtualService(v interface{}) (models.InputVirtualService, error) {
	var it models.InputVirtualService
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "domains":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Domains = make([]string, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Domains[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "routes":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Routes = make([]models.InputRoute, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Routes[idx1], err = UnmarshalInputRoute(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "sslConfig":
			var err error
			var ptr1 models.InputSslConfig
			if v != nil {
				ptr1, err = UnmarshalInputSslConfig(v)
				it.SslConfig = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "plugins":
			var err error
			var ptr1 models.InputVirtualServicePlugins
			if v != nil {
				ptr1, err = UnmarshalInputVirtualServicePlugins(v)
				it.Plugins = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "metadata":
			var err error
			it.Metadata, err = UnmarshalInputMetadata(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputVirtualServicePlugins(v interface{}) (models.InputVirtualServicePlugins, error) {
	var it models.InputVirtualServicePlugins
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "empty":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Empty = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputWeightedDestination(v interface{}) (models.InputWeightedDestination, error) {
	var it models.InputWeightedDestination
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "destination":
			var err error
			it.Destination, err = UnmarshalInputSingleDestination(v)
			if err != nil {
				return it, err
			}
		case "weight":
			var err error
			it.Weight, err = graphql.UnmarshalInt(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) FieldMiddleware(ctx context.Context, obj interface{}, next graphql.Resolver) (ret interface{}) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	res, err := ec.ResolverMiddleware(ctx, next)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return res
}

func (ec *executionContext) introspectSchema() *introspection.Schema {
	return introspection.WrapSchema(parsedSchema)
}

func (ec *executionContext) introspectType(name string) *introspection.Type {
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name])
}

var parsedSchema = gqlparser.MustLoadSchema(
	&ast.Source{Name: "schema.graphql", Input: `# Top Level
schema {
    query: Query
    mutation: Mutation
}

type Query {
    resource(guid: String!): Resource!
    getOAuthEndpoint: OAuthEndpoint!
    version: String!
    upstreams(namespace: String!):       UpstreamQuery!
    virtualServices(namespace: String!): VirtualServiceQuery!
    resolverMaps(namespace: String!): ResolverMapQuery!
    schemas(namespace: String!): SchemaQuery!
    secrets(namespace: String!): SecretQuery!
    artifacts(namespace: String!): ArtifactQuery!
    settings: SettingsQuery!
}

type Mutation {
    upstreams(namespace: String!):       UpstreamMutation!
    virtualServices(namespace: String!): VirtualServiceMutation!
    resolverMaps(namespace: String!): ResolverMapMutation!
    schemas(namespace: String!): SchemaMutation!
    secrets(namespace: String!): SecretMutation!
    artifacts(namespace: String!): ArtifactMutation!
    settings: SettingsMutation!
}

type Subscription {
    upstreams(namespace: String!, selector: InputMapStringString): [Upstream]
    virtualServices(namespace: String!, selector: InputMapStringString): [VirtualService]
}

union Resource = Upstream | VirtualService | ResolverMap | Schema | Secret | Artifact | Settings

type OAuthEndpoint {
    url: String!
    clientName: String!
}

type UpstreamQuery {
    list(selector: InputMapStringString): [Upstream]
    get(name: String!):                Upstream
}


type UpstreamMutation {
    create(upstream: InputUpstream!): Upstream
    update(upstream: InputUpstream!): Upstream
    delete(name: String!): Upstream
}


type VirtualServiceQuery {
    list(selector: InputMapStringString): [VirtualService]
    get(name: String!):                VirtualService
}


type VirtualServiceMutation {
    create(virtualService: InputVirtualService!): VirtualService
    update(name: String!, resourceVersion: String!, updates: InputUpdateVirtualService!): VirtualService
    delete(name: String!): VirtualService

    addRoute(virtualServiceName: String!, resourceVersion: String!, index: Int!, route: InputRoute!) : VirtualService
    updateRoute(virtualServiceName: String!, resourceVersion: String!, index: Int!, route: InputRoute!) : VirtualService
    deleteRoute(virtualServiceName: String!, resourceVersion: String!, index: Int!) : VirtualService
    swapRoutes(virtualServiceName: String!, resourceVersion: String!, index1: Int!, index2: Int!) : VirtualService
    shiftRoutes(virtualServiceName: String!, resourceVersion: String!, fromIndex: Int!, toIndex: Int!) : VirtualService
}


type ResolverMapQuery {
    list(selector: InputMapStringString): [ResolverMap]
    get(name: String!):                ResolverMap
}

type ResolverMapMutation {
    create(resolverMap: InputResolverMap!): ResolverMap
    update(resolverMap: InputResolverMap!): ResolverMap
    delete(name: String!): ResolverMap
    setResolver(resolverMapName: String!, resourceVersion: String!, typeName: String!, fieldName: String!, glooResolver: InputGlooResolver!): ResolverMap
}

type SchemaQuery {
    list(selector: InputMapStringString): [Schema]
    get(name: String!):                Schema
}

type SchemaMutation {
    create(schema: InputSchema!): Schema
    update(schema: InputSchema!): Schema
    delete(name: String!): Schema
}

type SecretQuery {
    list(selector: InputMapStringString): [Secret]
    get(name: String!):                Secret
}

type SecretMutation {
    create(secret: InputSecret!): Secret
    update(secret: InputSecret!): Secret
    delete(name: String!): Secret
}

type ArtifactQuery {
    list(selector: InputMapStringString): [Artifact]
    get(name: String!):                Artifact
}

type ArtifactMutation {
    create(artifact: InputArtifact!): Artifact
    update(artifact: InputArtifact!): Artifact
    delete(name: String!): Artifact
}

type SettingsQuery {
    get:                Settings
}

type SettingsMutation {
    update(settings: InputSettings!): Settings
}

# Upstream
# Upstream
# Upstream
# Upstream

type Upstream {
    spec:     UpstreamSpec!
    metadata: Metadata!
    status:   Status!
}

union UpstreamSpec = AwsUpstreamSpec | AzureUpstreamSpec | KubeUpstreamSpec | StaticUpstreamSpec

type AwsUpstreamSpec {
    region:    String!
    secretRef: ResourceRef!
    functions: [AwsLambdaFunction!]
}

type AzureUpstreamSpec {
    functionAppName: String!
    secretRef:       ResourceRef!
    functions:       [AzureFunction!]
}

type KubeUpstreamSpec {
    serviceName:      String!
    serviceNamespace: String!
    servicePort:      Int!
    selector:         MapStringString
    serviceSpec:      ServiceSpec
}

type StaticUpstreamSpec {
    hosts:        [StaticHost!]
    serviceSpec:  ServiceSpec
    useTls:       Boolean!
}

type StaticHost {
    addr: String!
    port: Int!
}

type AwsLambdaFunction {
    logicalName:  String!
    functionName: String!
    qualifier:    String!
}

type AzureFunction {
    functionName: String!
    authLevel:    AzureFnAuthLevel!
}

union ServiceSpec = RestServiceSpec | GrpcServiceSpec | SqoopServiceSpec

type RestServiceSpec  {
    functions: [Transformation!]
}

type Transformation {
    functionName: String!
    body: String
    headers: MapStringString
}

type GrpcServiceSpec {
    grpcServices: [GrpcService]
}

type GrpcService {
    packageName: String!
    serviceName: String!
    functionNames: [String!]
}

type SqoopServiceSpec {
    schemas: [Schema]!
}



# Upstream Mutation
# Upstream Mutation
# Upstream Mutation
# Upstream Mutation

input InputUpstream {
    spec:     InputUpstreamSpec!
    metadata: InputMetadata!
}

input InputUpstreamSpec {
    # oneof: aws | azure | kube | static
    aws: InputAwsUpstreamSpec
    azure: InputAzureUpstreamSpec
    kube: InputKubeUpstreamSpec
    static: InputStaticUpstreamSpec
}

input InputAwsUpstreamSpec {
    region:    String!
    secretRef: InputResourceRef!
    functions: [InputAwsLambdaFunction!]
}

input InputAzureUpstreamSpec {
    functionAppName: String!
    secretRef:       InputResourceRef
    functions:       [InputAzureFunction!]
}

input InputKubeUpstreamSpec {
    serviceName:      String!
    serviceNamespace: String!
    servicePort:      Int!
    selector:         InputMapStringString
    serviceSpec:      InputServiceSpec
}

input InputStaticUpstreamSpec {
    hosts:        [InputStaticHost!]
    serviceSpec:  InputServiceSpec
    useTls:       Boolean!
}

input InputStaticHost {
    addr: String!
    port: Int!
}

input InputAwsLambdaFunction {
    logicalName:  String!
    functionName: String!
    qualifier:    String!
}

input InputAzureFunction {
    functionName: String!
    authLevel:    String!
}

input InputServiceSpec  {
    # oneof: Rest | grpc
    rest: InputRestServiceSpec
    grpc:    InputGrpcServiceSpec
}

input InputRestServiceSpec  {
    functions: [InputTransformation!]
    inlineSwaggerDoc: String
}

input InputTransformation {
    functionName: String!
    body: String
    headers: InputMapStringString
}


# Not implemented yet
input InputGrpcServiceSpec {
    empty: String
}

input InputMetadata {
    name:            String!
    namespace:       String!
    resourceVersion: String!
    labels:          InputMapStringString
    annotations:     InputMapStringString
}

input InputUpdateMetadata {
    name:            String
    labels:          InputMapStringString
    annotations:     InputMapStringString
}

input InputStatus {
    state:  State!
    reason: String!
}






## VirtualService
## VirtualService
## VirtualService
## VirtualService
## VirtualService
## VirtualService

type VirtualService {
    domains: [String!]
    routes:  [Route!]
    sslConfig: SslConfig
    plugins: VirtualServicePlugins

    metadata: Metadata!
    status:   Status!
}


type Route {
    matcher: Matcher!
    destination: Destination!
    plugins: RoutePlugins
}

# not implemented
type VirtualServicePlugins {
    empty: String
}

type Matcher {
    pathMatch: String!
    pathMatchType: PathMatchType!
    headers: [KeyValueMatcher!]
    queryParameters: [KeyValueMatcher!]
    methods: [String!]
}

type KeyValueMatcher {
    name: String!
    value: String!
    isRegex: Boolean!
}

union Destination = MultiDestination | SingleDestination

type MultiDestination {
    destinations: [WeightedDestination!]
}

type WeightedDestination {
    destination: SingleDestination!
    weight: Int!
}

type SingleDestination {
    upstream: Upstream!
    destinationSpec: DestinationSpec
}

union DestinationSpec = AwsDestinationSpec | AzureDestinationSpec | RestDestinationSpec | GrpcDestinationSpec | SqoopDestinationSpec

type AwsDestinationSpec {
    logicalName: String!
    invocationStyle: AwsLambdaInvocationStyle!
    responseTransformation: Boolean!
}

type AzureDestinationSpec {
    functionName: String!
}

type RestDestinationSpec {
    functionName: String!
    parameters: TransformationParameters
}

type GrpcDestinationSpec {
    package: String!
    service: String!
    function: String!
    parameters: TransformationParameters
}

type SqoopDestinationSpec {
    schema: Schema!
    playground: Boolean!
}

type TransformationParameters {
    headers: MapStringString
    path: String
}

type SslConfig {
    secretRef: ResourceRef!
}

# not implemented
type RoutePlugins {
    empty: String
}

# InputVirtualService
# InputVirtualService
# InputVirtualService
# InputVirtualService

input InputVirtualService {
    domains: [String!]
    routes:  [InputRoute!]
    sslConfig: InputSslConfig
    plugins: InputVirtualServicePlugins
    metadata: InputMetadata!
}

input InputUpdateVirtualService {
    domains: [String!]
    sslConfig: InputSslConfig
    plugins: InputVirtualServicePlugins
    metadata: InputUpdateMetadata
}

input InputRoute {
    matcher: InputMatcher!
    destination: InputDestination!
    plugins: InputRoutePlugins
}

# not implemented
input InputVirtualServicePlugins {
    empty: String
}

input InputMatcher {
    pathMatch: String!
    pathMatchType: PathMatchType!
    headers: [InputKeyValueMatcher!]
    queryParameters: [InputKeyValueMatcher!]
    methods: [String!]
}

input InputKeyValueMatcher {
    name: String!
    value: String!
    isRegex: Boolean!
}

input InputDestination {
    # oneof: MultiDestination, SingleDestination
    singleDestination: InputSingleDestination
    multiDestination: InputMultiDestination
}

input InputMultiDestination {
    destinations: [InputWeightedDestination!]
}

input InputWeightedDestination {
    destination: InputSingleDestination!
    weight: Int!
}

input InputSingleDestination {
    upstream: InputResourceRef!
    destinationSpec: InputDestinationSpec
}

input InputDestinationSpec {
    # oneof: aws | azure
    aws: InputAwsDestinationSpec
    azure: InputAzureDestinationSpec
    rest: InputRestDestinationSpec
    grpc: InputGrpcDestinationSpec
    sqoop: InputSqoopDestinationSpec
}

input InputRestDestinationSpec {
    functionName: String!
    parameters: InputTransformationParameters
}

input InputGrpcDestinationSpec {
    package: String!
    service: String!
    function: String!
}

input InputSqoopDestinationSpec {
    schemaName: String!
    schemaNamespace: String!
    playground: Boolean!
}

input InputTransformationParameters {
    headers: InputMapStringString
    path: String
}

input InputAwsDestinationSpec {
    logicalName: String!
    invocationStyle: AwsLambdaInvocationStyle!
    responseTransformation: Boolean!
}

input InputAzureDestinationSpec {
    functionName: String!
}

input InputSslConfig {
    secretRef: InputResourceRef!
}


# not implemented
input InputRoutePlugins {
    empty: String
}


## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap


type ResolverMap {
    # can't do maps, thanks facebook
    # the trick with type resolvers is the typeNames must be unique!
    # this converts to a map in the server
    # what a novel idea for a type system. maps... who would have thunk it?
    types: [TypeResolver!]!
    metadata: Metadata!
    status:   Status!
}

type TypeResolver {
    typeName: String!
    # again, the fieldNames within this array must be unique
    fields: [FieldResolver!]!
}

type FieldResolver {
    fieldName: String!
    resolver: Resolver
}

union Resolver = GlooResolver | TemplateResolver | NodeJSResolver

type GlooResolver {
    requestTemplate: RequestTemplate
    responseTemplate: ResponseTemplate
    destination: Destination!
}

type RequestTemplate {
    verb: String!
    path: String!
    body: String!
    headers: MapStringString
}

type ResponseTemplate {
    body: String!
    headers: MapStringString
}

type TemplateResolver {
    inlineTemplate: String
}

type NodeJSResolver {
    empty: String
}



input InputResolverMap {
    # can't do maps, thanks facebook
    # the trick with type resolvers is the typeNames must be unique!
    # this converts to a map in the server
    # what a novel idea for a type system. maps... who would have thunk it?
    types: [InputTypeResolver!]!
    metadata: InputMetadata!
}

input InputTypeResolver {
    typeName: String!
    # again, the fieldNames within this array must be unique
    fields: [InputFieldResolver!]!
}

input InputFieldResolver {
    fieldName: String!
    resolver: InputResolver!
}

input InputResolver {
    # oneof: gloo, template, node
    glooResolver: InputGlooResolver
    templateResolver: InputTemplateResolver
    nodeResolver: InputNodeJSResolver
}

input InputGlooResolver {
    requestTemplate: InputRequestTemplate
    responseTemplate: InputResponseTemplate
    destination: InputDestination!
}

input InputRequestTemplate {
    verb: String!
    path: String!
    body: String!
    headers: InputMapStringString
}

input InputResponseTemplate {
    body: String!
    headers: InputMapStringString
}
input InputTemplateResolver {
    empty: String
}
input InputNodeJSResolver {
    empty: String
}


## Schema
## Schema
## Schema
## Schema
## Schema

type Schema {
    inlineSchema: String!
    metadata: Metadata!
    status: Status!
}

input InputSchema {
    inlineSchema: String!
    metadata: InputMetadata!
}


## Secret
## Secret
## Secret
## Secret
## Secret
## Secret

type Secret {
    kind: SecretKind!
    metadata: Metadata!
}

union SecretKind = AwsSecret | AzureSecret | TlsSecret

type AwsSecret {
    accessKey: String!
    secretKey: String!
}

type AzureSecret {
    apiKeys: MapStringString
}

type TlsSecret {
    certChain: String!
    privateKey: String!
    rootCa: String! # note: it is okay to leave this as an empty string
}

input InputSecret {
    kind: InputSecretKind!
    metadata: InputMetadata!
}

input InputSecretKind {
    # oneof: aws, azure, tls
    aws: InputAwsSecret
    azure: InputAzureSecret
    tls: InputTlsSecret
}

input InputAwsSecret {
    accessKey: String!
    secretKey: String!
}

input InputAzureSecret {
    apiKeys: InputMapStringString!
}

input InputTlsSecret {
    certChain: String!
    privateKey: String!
    rootCa: String! # note: it is okay to leave this as an empty string
}

## Artifact
## Artifact
## Artifact
## Artifact
## Artifact

type Artifact {
    data: String!
    metadata: Metadata!
}

input InputArtifact {
    data: String!
    metadata: InputMetadata!
}

## Settings
## Settings
## Settings
## Settings
## Settings

type Settings {
    watchNamespaces: [String!]
    refreshRate: Duration
    metadata: Metadata!
}

input InputSettings {
    watchNamespaces: [String!]
    refreshRate: Duration
    metadata: InputMetadata!
}



# Common output types
# Common output types
# Common output types
# Common output types
# Common output types

type Metadata {
    name:            String!
    namespace:       String!
    resourceVersion: String!
    labels:          MapStringString
    annotations:     MapStringString
    guid:            String!
}

type Status {
    state:  State!
    reason: String
}

type ResourceRef {
    name: String!
    namespace: String!
}

input InputResourceRef {
    name: String!
    namespace: String!
}


# Scalars / Extra

enum State {
    PENDING
    ACCEPTED
    REJECTED
}

enum AzureFnAuthLevel {
    ANONYMOUS
    FUNCTION
    ADMIN
}

type MapStringString {
    values: [Value!]
}

input InputMapStringString {
    values: [InputValue!]
}

type Value {
    key: String!
    value: String!
}

input InputValue {
    key: String!
    value: String!
}

enum PathMatchType {
    PREFIX
    REGEX
    EXACT
}

enum AwsLambdaInvocationStyle {
    SYNC
    ASYNC
}

scalar Duration`},
)
