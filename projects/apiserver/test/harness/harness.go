package harness

import (
	"bytes"
	"fmt"
	"io"
	"net/http"
	"strings"

	"github.com/vektah/gqlparser/gqlerror"
	"gopkg.in/yaml.v2"
)

// ResponseErrors is the same as github.com/99designs/gqlgen/graphql.Response,
// except, since only care about the errors, and since proper unmarshaling of
// the data field requires that we use the full typeset generated by gqlgen,
// we umarshal the Data field into a dummy interface.
type ResponseErrors struct {
	// This is what we care about: check errors during tests
	Errors gqlerror.List `json:"errors,omitempty"`
	// This is what we will use for our purposes
	Data map[string]interface{} `json:"data`
	// This is how github.com/99designs/gqlgen/graphql.Response implements the Data field
	// Data       json.RawMessage        `json:"data"`
	// This can be ignored, preserved for consistency
	Extensions map[string]interface{} `json:"extensions,omitempty"`
}

type ApiServer struct {
	Origin string
	Token  string
}

func (a *ApiServer) CallQueryWithVariables(query, variables string) (ResponseErrors, error) {
	data := fmt.Sprintf(`{"query": "%v", "variables": %v}`, query, variables)
	data = strings.Replace(data, "\n", " ", -1)
	data = strings.Replace(data, "\t", " ", -1)
	return a.CallQuery(data)
}

// CallQuery is an adaptation of the graphiql playground's curl query to go code
// If a Token is provided in the ApiServer, it will include the Authorization header
// NOTE: this will only work when run from inside the cluster (or by connecting to a port-forwarded apiserver)
func (a *ApiServer) CallQuery(data string) (ResponseErrors, error) {

	body := bytes.NewReader([]byte(data))

	req, err := http.NewRequest("POST", fmt.Sprintf("%v/query", a.Origin), body)
	if err != nil {
		return ResponseErrors{}, err
	}
	req.Header.Set("Accept-Encoding", "gzip, deflate, br")
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/json")
	req.Header.Set("Connection", "keep-alive")
	req.Header.Set("Dnt", "1")
	req.Header.Set("Origin", a.Origin)
	if a.Token != "" {
		req.Header.Set("Authorization", a.Token)
	}

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return ResponseErrors{}, err
	}
	p := new(bytes.Buffer)
	_, err = io.Copy(p, resp.Body)
	defer resp.Body.Close()

	re := ResponseErrors{}
	if err := yaml.Unmarshal(p.Bytes(), &re); err != nil {
		return ResponseErrors{}, err
	}
	return re, nil
}
