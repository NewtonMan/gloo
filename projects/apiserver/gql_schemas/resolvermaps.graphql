type ResolverMapMutation {
  create(resolverMap: InputResolverMap!): ResolverMap
  update(resolverMap: InputResolverMap!): ResolverMap
  delete(guid: ID!): ResolverMap
  setResolver(
    resolverMapId: ID!
    resourceVersion: String!
    typeName: String!
    fieldName: String!
    glooResolver: InputGlooResolver!
  ): ResolverMap
}

type ResolverMap {
  # can't do maps, thanks facebook
  # the trick with type resolvers is the typeNames must be unique!
  # this converts to a map in the server
  # what a novel idea for a type system. maps... who would have thunk it?
  types: [TypeResolver!]!
  metadata: Metadata!
  status: Status!
}

type TypeResolver {
  typeName: String!
  # again, the fieldNames within this array must be unique
  fields: [FieldResolver!]!
}

type FieldResolver {
  fieldName: String!
  resolver: Resolver
}

union Resolver = GlooResolver | TemplateResolver | NodeJSResolver

type GlooResolver {
  requestTemplate: RequestTemplate
  responseTemplate: ResponseTemplate
  destination: Destination!
}

type RequestTemplate {
  verb: String!
  path: String!
  body: String!
  headers: MapStringString
}

type ResponseTemplate {
  body: String!
  headers: MapStringString
}

type TemplateResolver {
  inlineTemplate: String
}

type NodeJSResolver {
  empty: String
}

input InputResolverMap {
  # can't do maps, thanks facebook
  # the trick with type resolvers is the typeNames must be unique!
  # this converts to a map in the server
  # what a novel idea for a type system. maps... who would have thunk it?
  types: [InputTypeResolver!]!
  metadata: InputMetadata!
}

input InputTypeResolver {
  typeName: String!
  # again, the fieldNames within this array must be unique
  fields: [InputFieldResolver!]!
}

input InputFieldResolver {
  fieldName: String!
  resolver: InputResolver!
}

input InputResolver {
  # oneof: gloo, template, node
  glooResolver: InputGlooResolver
  templateResolver: InputTemplateResolver
  nodeResolver: InputNodeJSResolver
}

input InputGlooResolver {
  requestTemplate: InputRequestTemplate
  responseTemplate: InputResponseTemplate
  destination: InputDestination!
}

input InputRequestTemplate {
  verb: String!
  path: String!
  body: String!
  headers: InputMapStringString
}

input InputResponseTemplate {
  body: String!
  headers: InputMapStringString
}
input InputTemplateResolver {
  empty: String
}
input InputNodeJSResolver {
  empty: String
}
