type VirtualServiceMutation {
  create(virtualService: InputVirtualService!): VirtualService
  update(
    virtualServiceId: ID!
    resourceVersion: String!
    updates: InputUpdateVirtualService!
  ): VirtualService

  delete(guid: ID!): VirtualService

  addRoute(
    virtualServiceId: ID!
    resourceVersion: String!
    index: Int!
    route: InputRoute!
  ): VirtualService

  updateRoute(
    virtualServiceId: ID!
    resourceVersion: String!
    index: Int!
    route: InputRoute!
  ): VirtualService

  deleteRoute(
    virtualServiceId: ID!
    resourceVersion: String!
    index: Int!
  ): VirtualService

  swapRoutes(
    virtualServiceId: ID!
    resourceVersion: String!
    index1: Int!
    index2: Int!
  ): VirtualService

  shiftRoutes(
    virtualServiceId: ID!
    resourceVersion: String!
    fromIndex: Int!
    toIndex: Int!
  ): VirtualService
}

type VirtualService {
  metadata: Metadata!
  status: Status!
  domains: [String!]
  routes: [Route!]
  sslConfig: SslConfig
  rateLimitConfig: RateLimitConfig
  plugins: VirtualServicePlugins @deprecated(reason: "Use `rateLimitConfig`.")
}

type Route {
  matcher: Matcher!
  destination: Destination!
  plugins: RoutePlugins
}

type Matcher {
  pathMatch: String!
  pathMatchType: PathMatchType!
  headers: [KeyValueMatcher!]
  queryParameters: [KeyValueMatcher!]
  methods: [String!]
}

union Destination = MultiDestination | SingleDestination

type MultiDestination {
  destinations: [WeightedDestination!]
}

type WeightedDestination {
  destination: SingleDestination!
  weight: Int!
}

type SingleDestination {
  upstream: Upstream!
  destinationSpec: DestinationSpec
}

union DestinationSpec =
    AwsDestinationSpec
  | AzureDestinationSpec
  | RestDestinationSpec
  | GrpcDestinationSpec
  | SqoopDestinationSpec

type AwsDestinationSpec {
  logicalName: String!
  invocationStyle: AwsLambdaInvocationStyle!
  responseTransformation: Boolean!
}

type AzureDestinationSpec {
  functionName: String!
}

type RestDestinationSpec {
  functionName: String!
  parameters: TransformationParameters
}

type GrpcDestinationSpec {
  package: String!
  service: String!
  function: String!
  parameters: TransformationParameters
}

type RateLimitConfig {
  authorizedHeader: String!
  authorizedLimits: RateLimit
  anonymousLimits: RateLimit
}

type RateLimit {
  unit: TimeUnit!
  requestsPerUnit: UnsignedInt!
}

enum TimeUnit {
  SECOND
  MINUTE
  HOUR
  DAY
}

# not implemented
type VirtualServicePlugins {
  empty: String
}

# not implemented
type RoutePlugins {
  empty: String
}

input InputVirtualService {
  domains: [String!]
  routes: [InputRoute!]
  sslConfig: InputSslConfig
  rateLimitConfig: InputRateLimitConfig
  metadata: InputMetadata!
  plugins: InputVirtualServicePlugins @deprecated(reason: "Use `rateLimitConfig`.")
}

input InputUpdateVirtualService {
  domains: [String!]
  sslConfig: InputSslConfig
  rateLimitConfig: InputRateLimitConfig
  metadata: InputUpdateMetadata
  plugins: InputVirtualServicePlugins @deprecated(reason: "Use `rateLimitConfig`.")
}

input InputRoute {
  matcher: InputMatcher!
  destination: InputDestination!
  plugins: InputRoutePlugins
}

input InputMatcher {
  pathMatch: String!
  pathMatchType: PathMatchType!
  headers: [InputKeyValueMatcher!]
  queryParameters: [InputKeyValueMatcher!]
  methods: [String!]
}

input InputRateLimitConfig {
  authorizedHeader: String!
  authorizedLimits: InputRateLimit
  anonymousLimits: InputRateLimit
}

input InputRateLimit {
  unit: TimeUnit!
  requestsPerUnit: UnsignedInt!
}

# not implemented
input InputVirtualServicePlugins {
  empty: String
}

input InputDestination {
  # oneof: MultiDestination, SingleDestination
  singleDestination: InputSingleDestination
  multiDestination: InputMultiDestination
}

input InputKeyValueMatcher {
  name: String!
  value: String!
  isRegex: Boolean!
}

type TransformationParameters {
  headers: MapStringString
  path: String
}

type KeyValueMatcher {
  name: String!
  value: String!
  isRegex: Boolean!
}

type SslConfig {
  secretRef: ResourceRef!
}

input InputSslConfig {
  secretRef: InputResourceRef!
}

input InputSingleDestination {
  upstream: InputResourceRef!
  destinationSpec: InputDestinationSpec
}

input InputDestinationSpec {
  # oneof: aws | azure
  aws: InputAwsDestinationSpec
  azure: InputAzureDestinationSpec
  rest: InputRestDestinationSpec
  grpc: InputGrpcDestinationSpec
  sqoop: InputSqoopDestinationSpec
}

input InputMultiDestination {
  destinations: [InputWeightedDestination!]
}

# not implemented
input InputRoutePlugins {
  empty: String
}

input InputWeightedDestination {
  destination: InputSingleDestination!
  weight: Int!
}

input InputAwsDestinationSpec {
  logicalName: String!
  invocationStyle: AwsLambdaInvocationStyle!
  responseTransformation: Boolean!
}

input InputAzureDestinationSpec {
  functionName: String!
}

input InputRestDestinationSpec {
  functionName: String!
  parameters: InputTransformationParameters
}

input InputGrpcDestinationSpec {
  package: String!
  service: String!
  function: String!
}

input InputSqoopDestinationSpec {
  schemaName: String!
  schemaNamespace: String!
  playground: Boolean!
}

input InputTransformationParameters {
  headers: InputMapStringString
  path: String
}