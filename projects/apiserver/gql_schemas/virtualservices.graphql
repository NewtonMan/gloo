type VirtualServiceMutation {
  create(virtualService: InputVirtualService!): VirtualService
  update(
    virtualServiceId: ID!
    resourceVersion: String!
    updates: InputUpdateVirtualService!
  ): VirtualService

  delete(guid: ID!): VirtualService

  addRoute(
    virtualServiceId: ID!
    resourceVersion: String!
    index: Int!
    route: InputRoute!
  ): VirtualService

  updateRoute(
    virtualServiceId: ID!
    resourceVersion: String!
    index: Int!
    route: InputRoute!
  ): VirtualService

  deleteRoute(
    virtualServiceId: ID!
    resourceVersion: String!
    index: Int!
  ): VirtualService

  swapRoutes(
    virtualServiceId: ID!
    resourceVersion: String!
    index1: Int!
    index2: Int!
  ): VirtualService

  shiftRoutes(
    virtualServiceId: ID!
    resourceVersion: String!
    fromIndex: Int!
    toIndex: Int!
  ): VirtualService
}

type VirtualService {
  displayName: String!
  metadata: Metadata!
  status: Status!
  domains: [String!]
  routes: [Route!]
  sslConfig: SslConfig
  rateLimitConfig: RateLimitConfig
  extAuthConfig: ExtAuthConfig
  plugins: VirtualServicePlugins @deprecated(reason: "Use `rateLimitConfig`.")
}

type Route {
  matcher: Matcher!
  destination: Destination!
  plugins: RoutePlugins
  virtualService: VirtualService
}

type Matcher {
  pathMatch: String!
  pathMatchType: PathMatchType!
  headers: [KeyValueMatcher!]
  queryParameters: [KeyValueMatcher!]
  methods: [String!]
}

union Destination = MultiDestination | SingleDestination

type MultiDestination {
  destinations: [WeightedDestination!]
}

type WeightedDestination {
  destination: SingleDestination!
  weight: Int!
}

type SingleDestination {
  upstream: Upstream!
  destinationSpec: DestinationSpec
}

union DestinationSpec =
    AwsDestinationSpec
  | AzureDestinationSpec
  | RestDestinationSpec
  | GrpcDestinationSpec

type AwsDestinationSpec {
  logicalName: String!
  invocationStyle: AwsLambdaInvocationStyle!
  responseTransformation: Boolean!
}

type AzureDestinationSpec {
  functionName: String!
}

type RestDestinationSpec {
  functionName: String!
  parameters: TransformationParameters
}

type GrpcDestinationSpec {
  package: String!
  service: String!
  function: String!
  parameters: TransformationParameters
}

type RateLimitConfig {
  authorizedLimits: RateLimit
  anonymousLimits: RateLimit
}

type RateLimit {
  unit: TimeUnit!
  requestsPerUnit: UnsignedInt!
}

enum TimeUnit {
  SECOND
  MINUTE
  HOUR
  DAY
}

type ExtAuthConfig {
  authType: AuthType
}

union AuthType =
  OAuthConfig
  | BasicAuth
  | CustomAuth

type OAuthConfig {
  "your client id as registered with the issuer"
  clientId: String
  "your client secret as registered with the issuer"
  clientSecret: String
  """
  The url of the issuer. We will look for OIDC information in issuerUrl+
  '.well-known/openid-configuration'
  """
  issuerUrl: String
  """
  we to redirect after successful auth, if we can't determine the original
  url this should be your publicly available app url.
  """
  appUrl: String
  """
  a callback path relative to app url that will be used for OIDC callbacks.
  needs to not be used by the application
  """
  callbackPath: String
}

"NOTE: resolvers not implemented"
type BasicAuth {
  realm: String!
}

type CustomAuth {
  empty: String
}

# not implemented
type VirtualServicePlugins {
  empty: String
}

# not implemented
type RoutePlugins {
  empty: String @deprecated(reason: "This was a placeholder.")
  prefixRewrite: String
}

input InputVirtualService {
  displayName: String!
  domains: [String!]
  routes: [InputRoute!]
  sslConfig: InputSslConfig
  rateLimitConfig: InputRateLimitConfig
  extAuthConfig: InputExtAuthConfig
  metadata: InputMetadata!
  plugins: InputVirtualServicePlugins @deprecated(reason: "Use `rateLimitConfig`.")
}

input InputUpdateVirtualService {
  displayName: String
  domains: [String!]
  sslConfig: InputSslConfig
  rateLimitConfig: InputRateLimitConfig
  extAuthConfig: InputExtAuthConfig
  plugins: InputVirtualServicePlugins @deprecated(reason: "Use `rateLimitConfig`.")
}

input InputRoute {
  matcher: InputMatcher!
  destination: InputDestination!
  plugins: InputRoutePlugins
}

input InputMatcher {
  pathMatch: String!
  pathMatchType: PathMatchType!
  headers: [InputKeyValueMatcher!]
  queryParameters: [InputKeyValueMatcher!]
  methods: [String!]
}

input InputRateLimitConfig {
  authorizedLimits: InputRateLimit
  anonymousLimits: InputRateLimit
}

input InputRateLimit {
  unit: TimeUnit!
  requestsPerUnit: UnsignedInt!
}

"Only one of oAuth or basicAuth should be specified"
input InputExtAuthConfig {
  oAuth: InputOAuthConfig
  basicAuth: InputBasicAuth
}

input InputOAuthConfig {
  "your client id as registered with the issuer"
  clientId: String!
  "your client secret as registered with the issuer"
  clientSecretRef: InputResourceRef!
  """
  The url of the issuer. We will look for OIDC information in issuerUrl+
  '.well-known/openid-configuration'
  """
  issuerUrl: String!
  """
  we to redirect after successful auth, if we can't determine the original
  url this should be your publicly available app url.
  """
  appUrl: String!
  """
  a callback path relative to app url that will be used for OIDC callbacks.
  needs to not be used by the application
  """
  callbackPath: String!
}

"NOTE: resolvers not implemented"
input InputBasicAuth {
  realm: String!
  "specCsv rows should have the form: <user_name>,<pw_salt>,<pw_hash>"
  specCsv: String!
}

# not implemented
input InputVirtualServicePlugins {
  empty: String
}

input InputDestination {
  # oneof: MultiDestination, SingleDestination
  singleDestination: InputSingleDestination
  multiDestination: InputMultiDestination
}

input InputKeyValueMatcher {
  name: String!
  value: String!
  isRegex: Boolean!
}

type TransformationParameters {
  headers: MapStringString
  path: String
}

type KeyValueMatcher {
  name: String!
  value: String!
  isRegex: Boolean!
}

type SslConfig {
  secretRef: ResourceRef!
}

input InputSslConfig {
  secretRef: InputResourceRef!
}

input InputSingleDestination {
  upstream: InputResourceRef!
  destinationSpec: InputDestinationSpec
}

input InputDestinationSpec {
  # oneof: aws | azure | rest | grpc
  aws: InputAwsDestinationSpec
  azure: InputAzureDestinationSpec
  rest: InputRestDestinationSpec
  grpc: InputGrpcDestinationSpec
}

input InputMultiDestination {
  destinations: [InputWeightedDestination!]
}

input InputRoutePlugins {
  empty: String @deprecated(reason: "This was a placeholder.")
  prefixRewrite: String
}

input InputWeightedDestination {
  destination: InputSingleDestination!
  weight: Int!
}

input InputAwsDestinationSpec {
  logicalName: String!
  invocationStyle: AwsLambdaInvocationStyle!
  responseTransformation: Boolean!
}

input InputAzureDestinationSpec {
  functionName: String!
}

input InputRestDestinationSpec {
  functionName: String!
  parameters: InputTransformationParameters
}

input InputGrpcDestinationSpec {
  package: String!
  service: String!
  function: String!
}

input InputTransformationParameters {
  headers: InputMapStringString
  path: String
}
