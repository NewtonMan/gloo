# Top Level
schema {
    query: Query
    mutation: Mutation
}

type Query {
    resource(guid: String!): Resource!
    getOAuthEndpoint: OAuthEndpoint!
    version: String!
    upstreams(namespace: String!):       UpstreamQuery!
    virtualServices(namespace: String!): VirtualServiceQuery!
    resolverMaps(namespace: String!): ResolverMapQuery!
    schemas(namespace: String!): SchemaQuery!
    secrets(namespace: String!): SecretQuery!
    artifacts(namespace: String!): ArtifactQuery!
    settings: SettingsQuery!
}

type Mutation {
    upstreams(namespace: String!):       UpstreamMutation!
    virtualServices(namespace: String!): VirtualServiceMutation!
    resolverMaps(namespace: String!): ResolverMapMutation!
    schemas(namespace: String!): SchemaMutation!
    secrets(namespace: String!): SecretMutation!
    artifacts(namespace: String!): ArtifactMutation!
    settings: SettingsMutation!
    vcs(username: String!): VcsMutation!
}

type Subscription {
    upstreams(namespace: String!, selector: InputMapStringString): [Upstream]
    virtualServices(namespace: String!, selector: InputMapStringString): [VirtualService]
}

union Resource = Upstream | VirtualService | ResolverMap | Schema | Secret | Artifact | Settings

type OAuthEndpoint {
    url: String!
    clientName: String!
}

type UpstreamQuery {
    list(selector: InputMapStringString): [Upstream]
    get(name: String!):                Upstream
}


type UpstreamMutation {
    create(upstream: InputUpstream!): Upstream
    update(upstream: InputUpstream!): Upstream
    delete(name: String!): Upstream
}


type VirtualServiceQuery {
    list(selector: InputMapStringString): [VirtualService]
    get(name: String!):                VirtualService
}


type VirtualServiceMutation {
    create(virtualService: InputVirtualService!): VirtualService
    update(name: String!, resourceVersion: String!, updates: InputUpdateVirtualService!): VirtualService
    delete(name: String!): VirtualService

    addRoute(virtualServiceName: String!, resourceVersion: String!, index: Int!, route: InputRoute!) : VirtualService
    updateRoute(virtualServiceName: String!, resourceVersion: String!, index: Int!, route: InputRoute!) : VirtualService
    deleteRoute(virtualServiceName: String!, resourceVersion: String!, index: Int!) : VirtualService
    swapRoutes(virtualServiceName: String!, resourceVersion: String!, index1: Int!, index2: Int!) : VirtualService
    shiftRoutes(virtualServiceName: String!, resourceVersion: String!, fromIndex: Int!, toIndex: Int!) : VirtualService
}


type ResolverMapQuery {
    list(selector: InputMapStringString): [ResolverMap]
    get(name: String!):                ResolverMap
}

type ResolverMapMutation {
    create(resolverMap: InputResolverMap!): ResolverMap
    update(resolverMap: InputResolverMap!): ResolverMap
    delete(name: String!): ResolverMap
    setResolver(resolverMapName: String!, resourceVersion: String!, typeName: String!, fieldName: String!, glooResolver: InputGlooResolver!): ResolverMap
}

type SchemaQuery {
    list(selector: InputMapStringString): [Schema]
    get(name: String!):                Schema
}

type SchemaMutation {
    create(schema: InputSchema!): Schema
    update(schema: InputSchema!): Schema
    delete(name: String!): Schema
}

type SecretQuery {
    list(selector: InputMapStringString): [Secret]
    get(name: String!):                Secret
}

type SecretMutation {
    create(secret: InputSecret!): Secret
    update(secret: InputSecret!): Secret
    delete(name: String!): Secret
}

type ArtifactQuery {
    list(selector: InputMapStringString): [Artifact]
    get(name: String!):                Artifact
}

type ArtifactMutation {
    create(artifact: InputArtifact!): Artifact
    update(artifact: InputArtifact!): Artifact
    delete(name: String!): Artifact
}

type SettingsQuery {
    get:                Settings
}

type SettingsMutation {
    update(settings: InputSettings!): Settings
}

type VcsMutation {
    commit(message: String!): String
    clearError(): String
    createBranch(branchName: String!): String
    resetChanges(): String
    checkoutBranch(branchName: String!): String
    checkoutCommit(hash: String!): String
}

# Upstream
# Upstream
# Upstream
# Upstream

type Upstream {
    spec:     UpstreamSpec!
    metadata: Metadata!
    status:   Status!
}

union UpstreamSpec = AwsUpstreamSpec | AzureUpstreamSpec | KubeUpstreamSpec | StaticUpstreamSpec

type AwsUpstreamSpec {
    region:    String!
    secretRef: ResourceRef!
    functions: [AwsLambdaFunction!]
}

type AzureUpstreamSpec {
    functionAppName: String!
    secretRef:       ResourceRef!
    functions:       [AzureFunction!]
}

type KubeUpstreamSpec {
    serviceName:      String!
    serviceNamespace: String!
    servicePort:      Int!
    selector:         MapStringString
    serviceSpec:      ServiceSpec
}

type StaticUpstreamSpec {
    hosts:        [StaticHost!]
    serviceSpec:  ServiceSpec
    useTls:       Boolean!
}

type StaticHost {
    addr: String!
    port: Int!
}

type AwsLambdaFunction {
    logicalName:  String!
    functionName: String!
    qualifier:    String!
}

type AzureFunction {
    functionName: String!
    authLevel:    AzureFnAuthLevel!
}

union ServiceSpec = RestServiceSpec | GrpcServiceSpec | SqoopServiceSpec

type RestServiceSpec  {
    functions: [Transformation!]
}

type Transformation {
    functionName: String!
    body: String
    headers: MapStringString
}

type GrpcServiceSpec {
    grpcServices: [GrpcService]
}

type GrpcService {
    packageName: String!
    serviceName: String!
    functionNames: [String!]
}

type SqoopServiceSpec {
    schemas: [Schema]!
}



# Upstream Mutation
# Upstream Mutation
# Upstream Mutation
# Upstream Mutation

input InputUpstream {
    spec:     InputUpstreamSpec!
    metadata: InputMetadata!
}

input InputUpstreamSpec {
    # oneof: aws | azure | kube | static
    aws: InputAwsUpstreamSpec
    azure: InputAzureUpstreamSpec
    kube: InputKubeUpstreamSpec
    static: InputStaticUpstreamSpec
}

input InputAwsUpstreamSpec {
    region:    String!
    secretRef: InputResourceRef!
    functions: [InputAwsLambdaFunction!]
}

input InputAzureUpstreamSpec {
    functionAppName: String!
    secretRef:       InputResourceRef
    functions:       [InputAzureFunction!]
}

input InputKubeUpstreamSpec {
    serviceName:      String!
    serviceNamespace: String!
    servicePort:      Int!
    selector:         InputMapStringString
    serviceSpec:      InputServiceSpec
}

input InputStaticUpstreamSpec {
    hosts:        [InputStaticHost!]
    serviceSpec:  InputServiceSpec
    useTls:       Boolean!
}

input InputStaticHost {
    addr: String!
    port: Int!
}

input InputAwsLambdaFunction {
    logicalName:  String!
    functionName: String!
    qualifier:    String!
}

input InputAzureFunction {
    functionName: String!
    authLevel:    String!
}

input InputServiceSpec  {
    # oneof: Rest | grpc
    rest: InputRestServiceSpec
    grpc:    InputGrpcServiceSpec
}

input InputRestServiceSpec  {
    functions: [InputTransformation!]
    inlineSwaggerDoc: String
}

input InputTransformation {
    functionName: String!
    body: String
    headers: InputMapStringString
}


# Not implemented yet
input InputGrpcServiceSpec {
    empty: String
}

input InputMetadata {
    name:            String!
    namespace:       String!
    resourceVersion: String!
    labels:          InputMapStringString
    annotations:     InputMapStringString
}

input InputUpdateMetadata {
    name:            String
    labels:          InputMapStringString
    annotations:     InputMapStringString
}

input InputStatus {
    state:  State!
    reason: String!
}






## VirtualService
## VirtualService
## VirtualService
## VirtualService
## VirtualService
## VirtualService

type VirtualService {
    domains: [String!]
    routes:  [Route!]
    sslConfig: SslConfig
    plugins: VirtualServicePlugins

    metadata: Metadata!
    status:   Status!
}


type Route {
    matcher: Matcher!
    destination: Destination!
    plugins: RoutePlugins
}

# not implemented
type VirtualServicePlugins {
    empty: String
}

type Matcher {
    pathMatch: String!
    pathMatchType: PathMatchType!
    headers: [KeyValueMatcher!]
    queryParameters: [KeyValueMatcher!]
    methods: [String!]
}

type KeyValueMatcher {
    name: String!
    value: String!
    isRegex: Boolean!
}

union Destination = MultiDestination | SingleDestination

type MultiDestination {
    destinations: [WeightedDestination!]
}

type WeightedDestination {
    destination: SingleDestination!
    weight: Int!
}

type SingleDestination {
    upstream: Upstream!
    destinationSpec: DestinationSpec
}

union DestinationSpec = AwsDestinationSpec | AzureDestinationSpec | RestDestinationSpec | GrpcDestinationSpec | SqoopDestinationSpec

type AwsDestinationSpec {
    logicalName: String!
    invocationStyle: AwsLambdaInvocationStyle!
    responseTransformation: Boolean!
}

type AzureDestinationSpec {
    functionName: String!
}

type RestDestinationSpec {
    functionName: String!
    parameters: TransformationParameters
}

type GrpcDestinationSpec {
    package: String!
    service: String!
    function: String!
    parameters: TransformationParameters
}

type SqoopDestinationSpec {
    schema: Schema!
    playground: Boolean!
}

type TransformationParameters {
    headers: MapStringString
    path: String
}

type SslConfig {
    secretRef: ResourceRef!
}

# not implemented
type RoutePlugins {
    empty: String
}

# InputVirtualService
# InputVirtualService
# InputVirtualService
# InputVirtualService

input InputVirtualService {
    domains: [String!]
    routes:  [InputRoute!]
    sslConfig: InputSslConfig
    plugins: InputVirtualServicePlugins
    metadata: InputMetadata!
}

input InputUpdateVirtualService {
    domains: [String!]
    sslConfig: InputSslConfig
    plugins: InputVirtualServicePlugins
    metadata: InputUpdateMetadata
}

input InputRoute {
    matcher: InputMatcher!
    destination: InputDestination!
    plugins: InputRoutePlugins
}

# not implemented
input InputVirtualServicePlugins {
    empty: String
}

input InputMatcher {
    pathMatch: String!
    pathMatchType: PathMatchType!
    headers: [InputKeyValueMatcher!]
    queryParameters: [InputKeyValueMatcher!]
    methods: [String!]
}

input InputKeyValueMatcher {
    name: String!
    value: String!
    isRegex: Boolean!
}

input InputDestination {
    # oneof: MultiDestination, SingleDestination
    singleDestination: InputSingleDestination
    multiDestination: InputMultiDestination
}

input InputMultiDestination {
    destinations: [InputWeightedDestination!]
}

input InputWeightedDestination {
    destination: InputSingleDestination!
    weight: Int!
}

input InputSingleDestination {
    upstream: InputResourceRef!
    destinationSpec: InputDestinationSpec
}

input InputDestinationSpec {
    # oneof: aws | azure
    aws: InputAwsDestinationSpec
    azure: InputAzureDestinationSpec
    rest: InputRestDestinationSpec
    grpc: InputGrpcDestinationSpec
    sqoop: InputSqoopDestinationSpec
}

input InputRestDestinationSpec {
    functionName: String!
    parameters: InputTransformationParameters
}

input InputGrpcDestinationSpec {
    package: String!
    service: String!
    function: String!
}

input InputSqoopDestinationSpec {
    schemaName: String!
    schemaNamespace: String!
    playground: Boolean!
}

input InputTransformationParameters {
    headers: InputMapStringString
    path: String
}

input InputAwsDestinationSpec {
    logicalName: String!
    invocationStyle: AwsLambdaInvocationStyle!
    responseTransformation: Boolean!
}

input InputAzureDestinationSpec {
    functionName: String!
}

input InputSslConfig {
    secretRef: InputResourceRef!
}


# not implemented
input InputRoutePlugins {
    empty: String
}


## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap


type ResolverMap {
    # can't do maps, thanks facebook
    # the trick with type resolvers is the typeNames must be unique!
    # this converts to a map in the server
    # what a novel idea for a type system. maps... who would have thunk it?
    types: [TypeResolver!]!
    metadata: Metadata!
    status:   Status!
}

type TypeResolver {
    typeName: String!
    # again, the fieldNames within this array must be unique
    fields: [FieldResolver!]!
}

type FieldResolver {
    fieldName: String!
    resolver: Resolver
}

union Resolver = GlooResolver | TemplateResolver | NodeJSResolver

type GlooResolver {
    requestTemplate: RequestTemplate
    responseTemplate: ResponseTemplate
    destination: Destination!
}

type RequestTemplate {
    verb: String!
    path: String!
    body: String!
    headers: MapStringString
}

type ResponseTemplate {
    body: String!
    headers: MapStringString
}

type TemplateResolver {
    inlineTemplate: String
}

type NodeJSResolver {
    empty: String
}



input InputResolverMap {
    # can't do maps, thanks facebook
    # the trick with type resolvers is the typeNames must be unique!
    # this converts to a map in the server
    # what a novel idea for a type system. maps... who would have thunk it?
    types: [InputTypeResolver!]!
    metadata: InputMetadata!
}

input InputTypeResolver {
    typeName: String!
    # again, the fieldNames within this array must be unique
    fields: [InputFieldResolver!]!
}

input InputFieldResolver {
    fieldName: String!
    resolver: InputResolver!
}

input InputResolver {
    # oneof: gloo, template, node
    glooResolver: InputGlooResolver
    templateResolver: InputTemplateResolver
    nodeResolver: InputNodeJSResolver
}

input InputGlooResolver {
    requestTemplate: InputRequestTemplate
    responseTemplate: InputResponseTemplate
    destination: InputDestination!
}

input InputRequestTemplate {
    verb: String!
    path: String!
    body: String!
    headers: InputMapStringString
}

input InputResponseTemplate {
    body: String!
    headers: InputMapStringString
}
input InputTemplateResolver {
    empty: String
}
input InputNodeJSResolver {
    empty: String
}


## Schema
## Schema
## Schema
## Schema
## Schema

type Schema {
    inlineSchema: String!
    metadata: Metadata!
    status: Status!
}

input InputSchema {
    inlineSchema: String!
    metadata: InputMetadata!
}


## Secret
## Secret
## Secret
## Secret
## Secret
## Secret

type Secret {
    kind: SecretKind!
    metadata: Metadata!
}

union SecretKind = AwsSecret | AzureSecret | TlsSecret

type AwsSecret {
    accessKey: String!
    secretKey: String!
}

type AzureSecret {
    apiKeys: MapStringString
}

type TlsSecret {
    certChain: String!
    privateKey: String!
    rootCa: String! # note: it is okay to leave this as an empty string
}

input InputSecret {
    kind: InputSecretKind!
    metadata: InputMetadata!
}

input InputSecretKind {
    # oneof: aws, azure, tls
    aws: InputAwsSecret
    azure: InputAzureSecret
    tls: InputTlsSecret
}

input InputAwsSecret {
    accessKey: String!
    secretKey: String!
}

input InputAzureSecret {
    apiKeys: InputMapStringString!
}

input InputTlsSecret {
    certChain: String!
    privateKey: String!
    rootCa: String! # note: it is okay to leave this as an empty string
}

## Artifact
## Artifact
## Artifact
## Artifact
## Artifact

type Artifact {
    data: String!
    metadata: Metadata!
}

input InputArtifact {
    data: String!
    metadata: InputMetadata!
}

## Settings
## Settings
## Settings
## Settings
## Settings

type Settings {
    watchNamespaces: [String!]
    refreshRate: Duration
    metadata: Metadata!
}

input InputSettings {
    watchNamespaces: [String!]
    refreshRate: Duration
    metadata: InputMetadata!
}



# Common output types
# Common output types
# Common output types
# Common output types
# Common output types

type Metadata {
    name:            String!
    namespace:       String!
    resourceVersion: String!
    labels:          MapStringString
    annotations:     MapStringString
    guid:            String!
}

type Status {
    state:  State!
    reason: String
}

type ResourceRef {
    name: String!
    namespace: String!
}

input InputResourceRef {
    name: String!
    namespace: String!
}


# Scalars / Extra

enum State {
    PENDING
    ACCEPTED
    REJECTED
}

enum AzureFnAuthLevel {
    ANONYMOUS
    FUNCTION
    ADMIN
}

type MapStringString {
    values: [Value!]
}

input InputMapStringString {
    values: [InputValue!]
}

type Value {
    key: String!
    value: String!
}

input InputValue {
    key: String!
    value: String!
}

enum PathMatchType {
    PREFIX
    REGEX
    EXACT
}

enum AwsLambdaInvocationStyle {
    SYNC
    ASYNC
}

scalar Duration