// Definition for federated resource cluster handler templates
package federation

{{ $import_prefix := group_import_name $ }}

import (
    "context"

    "github.com/avast/retry-go"
    {{ $import_prefix }} "{{ group_import_path $ }}"
    "github.com/solo-io/solo-projects/projects/gloo-fed/pkg/federation/placement"
    mc_types "github.com/solo-io/solo-projects/projects/gloo-fed/pkg/api/fed.solo.io/core/v1"
    "github.com/solo-io/go-utils/contextutils"
    "github.com/solo-io/skv2/pkg/multicluster"
    "go.uber.org/zap"
    "k8s.io/apimachinery/pkg/api/errors"
    "sigs.k8s.io/controller-runtime/pkg/client"
    "sigs.k8s.io/controller-runtime/pkg/manager"
)


var ClusterHandlerRetryAttempts uint = 5

type clusterHandler struct {
    ctx     context.Context
    clients {{ $import_prefix }}.Clientset
    factory placement.StatusBuilderFactory
}

func NewClusterHandler(ctx context.Context, clients {{ $import_prefix }}.Clientset, factory placement.StatusBuilderFactory) multicluster.ClusterHandler {
    return &clusterHandler{
        ctx:     ctx,
        clients: clients,
        factory: factory,
    }
}

func (f *clusterHandler) AddCluster(_ context.Context, cluster string, _ manager.Manager) {
    f.handleClusterEvent(cluster)
}

func (f *clusterHandler) RemoveCluster(cluster string) {
    f.handleClusterEvent(cluster)
}

func (f *clusterHandler) handleClusterEvent(cluster string) {
    {{- range $resource := $.Resources }}

    {{- $kindLowerCamel := lower_camel $resource.Kind }}

    {{ $kindLowerCamel }}List, err := f.clients.{{ pluralize $resource.Kind }}().List{{ $resource.Kind }}(f.ctx)
    if err != nil {
        contextutils.LoggerFrom(f.ctx).Errorf("Failed to list {{ $resource.Kind }}s referencing cluster %s", cluster)
    } else {
        for _, item := range {{ $kindLowerCamel }}List.Items {
            item := item
            if err := f.maybeUpdate{{ $resource.Kind }}StatusWithRetries(&item, cluster); err != nil {
                contextutils.LoggerFrom(f.ctx).Errorw("Failed to update status on {{ $resource.Kind }}",
                    zap.Error(err),
                    zap.Any("{{ $resource.Kind }}", item))
            }
        }
    }
    {{- end }}
}

{{- range $resource := $.Resources }}

{{- $kindLowerCamel := lower_camel $resource.Kind }}

func (f *clusterHandler) maybeUpdate{{ $resource.Kind }}StatusWithRetries(item *{{ $import_prefix }}.{{ $resource.Kind }}, cluster string) error {
    return retry.Do(func() error {
        err := f.maybeUpdate{{ $resource.Kind }}Status(item, cluster)
        if err != nil && errors.IsNotFound(err) {
            // If the resource no longer exists, there is nothing to do.
            return nil
        } else if err != nil {
            // On conflict, retry with the new object to pick up any changes to the resource's spec.
            obj, err := f.clients.{{ pluralize $resource.Kind }}().Get{{ $resource.Kind }}(f.ctx, client.ObjectKey{Namespace: item.Namespace, Name: item.Name})
            if err != nil {
                return err
            }
            item = obj
        }
        return err
    }, retry.Attempts(ClusterHandlerRetryAttempts))
}

func (f *clusterHandler) maybeUpdate{{ $resource.Kind }}Status(item *{{ $import_prefix }}.{{ $resource.Kind }}, cluster string) error {
	for _, c := range item.Spec.Placement.GetClusters() {
        if c == cluster {
            // An existing resource references the given cluster. Update its status to trigger a resync.
            item.Status.PlacementStatus = f.factory.GetBuilder().
                UpdateUnprocessed(item.Status.PlacementStatus, placement.ClusterEventTriggered(cluster), mc_types.PlacementStatus_PENDING).
                // Do not update the observed generation or written by fields as we have not actually processed the resource.
                Eject(item.Status.PlacementStatus.GetObservedGeneration())

            return f.clients.{{ pluralize $resource.Kind }}().Update{{ $resource.Kind }}Status(f.ctx, item)
        }
    }
    return nil
}

{{- end }}