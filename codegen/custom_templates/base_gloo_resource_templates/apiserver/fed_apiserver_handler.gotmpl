{{- $base_import_prefix := base_group_import_name $ }}
{{- $base_group := base_group $ }}
{{- $base_Group := base_Group $ }}
{{- $base_proto_group_shorthand := base_proto_group_shorthand $ }}

package {{ $base_group }}_resource_handler

import (
	"context"
	"math"
	"sort"
	"string"
	"sort"

	"github.com/rotisserie/eris"
	"go.uber.org/zap"
	"github.com/ghodss/yaml"

	{{ $base_import_prefix }} "github.com/solo-io/solo-apis/pkg/api/{{ $base_proto_group_shorthand }}.solo.io/{{ base_group_version $ }}"
	rpc_edge_v1 "github.com/solo-io/solo-projects/projects/apiserver/pkg/api/rpc.edge.gloo/v1"
	"github.com/solo-io/solo-projects/projects/apiserver/server/apiserverutils"
	skv2v1 "github.com/solo-io/skv2/pkg/api/core.skv2.solo.io/v1"
	fedv1 "github.com/solo-io/solo-projects/projects/gloo-fed/pkg/api/fed.solo.io/v1"
	"github.com/solo-io/go-utils/contextutils"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

func NewFed{{ $base_Group }}ResourceHandler(
	instanceClient fedv1.GlooInstanceClient,
	mc{{ $base_Group }}CRDClientset {{ $base_import_prefix }}.MulticlusterClientset,

) rpc_edge_v1.{{ $base_Group }}ResourceApiServer {
	return &fed{{ $base_Group }}ResourceHandler{
		instanceClient:     instanceClient,
		mc{{ $base_Group }}CRDClientset: mc{{ $base_Group }}CRDClientset,
	}
}

type fed{{ $base_Group }}ResourceHandler struct {
	instanceClient     fedv1.GlooInstanceClient
	mc{{ $base_Group }}CRDClientset {{ $base_import_prefix }}.MulticlusterClientset
}


{{- range $resource := $.Resources }}

{{- $kindLowerCamel := lower_camel $resource.Kind }}
{{- $baseKind := base_kind $resource.Kind }}

func (k *fed{{ $base_Group }}ResourceHandler) List{{ pluralize $baseKind }}(ctx context.Context, request *rpc_edge_v1.List{{ pluralize $baseKind }}Request) (*rpc_edge_v1.List{{ pluralize $baseKind }}Response, error) {
	var rpc{{ pluralize $baseKind }} []*rpc_edge_v1.{{ $baseKind }}
	if request.GetGlooInstanceRef() == nil || request.GetGlooInstanceRef().GetName() == "" || request.GetGlooInstanceRef().GetNamespace() == "" {
		// List {{ pluralize $kindLowerCamel }} across all gloo edge instances
		instanceList, err := k.instanceClient.ListGlooInstance(ctx)
		if err != nil {
			wrapped := eris.Wrapf(err, "Failed to list gloo edge instances")
			contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
			return nil, wrapped
		}
		for _, instance := range instanceList.Items {
			rpc{{ $baseKind }}List, err := k.list{{ pluralize $baseKind }}ForGlooInstance(ctx, &instance)
			if err != nil {
				wrapped := eris.Wrapf(err, "Failed to list {{ pluralize $kindLowerCamel }} for gloo edge instance %s.%s", instance.GetNamespace(), instance.GetName())
				contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
				return nil, wrapped
			}
			rpc{{ pluralize $baseKind }} = append(rpc{{ pluralize $baseKind }}, rpc{{ $baseKind }}List...)
		}
	} else {
		// List {{ pluralize $kindLowerCamel }} for a specific gloo edge instance
		instance, err := k.instanceClient.GetGlooInstance(ctx, types.NamespacedName{
			Name:      request.GetGlooInstanceRef().GetName(),
			Namespace: request.GetGlooInstanceRef().GetNamespace(),
		})
		if err != nil {
			wrapped := eris.Wrapf(err, "Failed to get gloo edge instance %s.%s", instance.GetNamespace(), instance.GetName())
			contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
			return nil, wrapped
		}
		rpc{{ pluralize $baseKind }}, err = k.list{{ pluralize $baseKind }}ForGlooInstance(ctx, instance)
		if err != nil {
			wrapped := eris.Wrapf(err, "Failed to list {{ pluralize $kindLowerCamel }} for gloo edge instance %s.%s", instance.GetNamespace(), instance.GetName())
			contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
			return nil, wrapped
		}
	}

	// Search, Filter
	var filtered{{ pluralize $baseKind }} []*rpc_edge_v1.{{ $baseKind }}
	qs := request.GetQueryString()
	sf := request.GetStatusFilter()
	if sf != nil || qs != "" {
	    for _, d := range rpc{{ pluralize $baseKind }} {
	        if (sf == nil || sf.State == int32(d.Status.State) ) && strings.Contains(d.Metadata.Name, qs) {
	            filtered{{ pluralize $baseKind }} = append(filtered{{ pluralize $baseKind }}, d)
	        }
	    }
	} else {
		filtered{{ pluralize $baseKind }} = rpc{{ pluralize $baseKind }}
	}
	// Sort
	sortOptions := request.GetSortOptions()
	if sortOptions != nil {
		isDescending := sortOptions.GetDescending();
		sortKey := sortOptions.GetSortKey();
		if isDescending == true {
			switch sortKey {
			case rpc_edge_v1.SortOptions_NAME:
				sort.SliceStable(filtered{{ pluralize $baseKind }}, func(i, j int) bool {
					a := filtered{{ pluralize $baseKind }}[i]
					b := filtered{{ pluralize $baseKind }}[j]
					return a.Metadata.Name+a.Metadata.Namespace+string(a.Status.State) > b.Metadata.Name+b.Metadata.Namespace+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_NAMESPACE :
				sort.SliceStable(filtered{{ pluralize $baseKind }}, func(i, j int) bool {
					a := filtered{{ pluralize $baseKind }}[i]
					b := filtered{{ pluralize $baseKind }}[j]
					return a.Metadata.Namespace+a.Metadata.Name+string(a.Status.State) > b.Metadata.Namespace+b.Metadata.Name+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_STATUS:
				sort.SliceStable(filtered{{ pluralize $baseKind }}, func(i, j int) bool {
					a := filtered{{ pluralize $baseKind }}[i]
					b := filtered{{ pluralize $baseKind }}[j]
					return string(a.Status.State)+a.Metadata.Name+a.Metadata.Namespace > string(b.Status.State)+b.Metadata.Name+b.Metadata.Namespace
				})
			}
		} else {
			switch sortKey {
			case rpc_edge_v1.SortOptions_NAME:
				sort.SliceStable(filtered{{ pluralize $baseKind }}, func(i, j int) bool {
					a := filtered{{ pluralize $baseKind }}[i]
					b := filtered{{ pluralize $baseKind }}[j]
					return a.Metadata.Name+a.Metadata.Namespace+string(a.Status.State) < b.Metadata.Name+b.Metadata.Namespace+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_NAMESPACE :
				sort.SliceStable(filtered{{ pluralize $baseKind }}, func(i, j int) bool {
					a := filtered{{ pluralize $baseKind }}[i]
					b := filtered{{ pluralize $baseKind }}[j]
					return a.Metadata.Namespace+a.Metadata.Name+string(a.Status.State) < b.Metadata.Namespace+b.Metadata.Name+string(b.Status.State)
				})
			case rpc_edge_v1.SortOptions_STATUS:
				sort.SliceStable(filtered{{ pluralize $baseKind }}, func(i, j int) bool {
					a := filtered{{ pluralize $baseKind }}[i]
					b := filtered{{ pluralize $baseKind }}[j]
					return string(a.Status.State)+a.Metadata.Name+a.Metadata.Namespace < string(b.Status.State)+b.Metadata.Name+b.Metadata.Namespace
				})
			}
		}
	}
	// Paginate
	paginated{{ pluralize $baseKind }} := filtered{{ pluralize $baseKind }}
	pagination := request.GetPagination()
	totalCount := int32(len(filtered{{ pluralize $baseKind }}))
	if pagination.GetLimit() > 0 && pagination.GetOffset() >= 0 {
		start := apiserverutils.Min(pagination.GetOffset(), totalCount)
		end := apiserverutils.Min(pagination.GetOffset()+pagination.GetLimit(), totalCount)
		paginated{{ pluralize $baseKind }} = filtered{{ pluralize $baseKind }}[start:end]
	}
	// Build response
	res := &rpc_edge_v1.List{{ pluralize $baseKind }}Response{
		{{ pluralize $baseKind }}: paginated{{ pluralize $baseKind }},
		Total: totalCount,
	}
	return res, nil
}

func (k *fed{{ $base_Group }}ResourceHandler) list{{ pluralize $baseKind }}ForGlooInstance(ctx context.Context, instance *fedv1.GlooInstance) ([]*rpc_edge_v1.{{ $baseKind }}, error) {

	{{ $base_group }}CRDClientset, err := k.mc{{ $base_Group }}CRDClientset.Cluster(instance.Spec.GetCluster())
	if err != nil {
		return nil, err
	}
	{{ $kindLowerCamel }}Client := {{ $base_group }}CRDClientset.{{ pluralize $baseKind }}()

	var {{ $base_group }}{{ $baseKind }}List []*{{ $base_import_prefix }}.{{ $baseKind }}
	watchedNamespaces := instance.Spec.GetControlPlane().GetWatchedNamespaces()
	if len(watchedNamespaces) != 0 {
		for _, ns := range watchedNamespaces {
			list, err := {{ $kindLowerCamel }}Client.List{{ $baseKind }}(ctx, client.InNamespace(ns))
			if err != nil {
				return nil, err
			}
			for i, _ := range list.Items {
				{{ $base_group }}{{ $baseKind }}List = append({{ $base_group }}{{ $baseKind }}List, &list.Items[i])
			}
		}
	} else {
		list, err := {{ $kindLowerCamel }}Client.List{{ $baseKind }}(ctx)
		if err != nil {
			return nil, err
		}
		for i, _ := range list.Items {
			{{ $base_group }}{{ $baseKind }}List = append({{ $base_group }}{{ $baseKind }}List, &list.Items[i])
		}
	}
	sort.Slice({{ $base_group }}{{ $baseKind }}List, func(i, j int) bool {
		x := {{ $base_group }}{{ $baseKind }}List[i]
		y := {{ $base_group }}{{ $baseKind }}List[j]
		return x.GetNamespace()+x.GetName() < y.GetNamespace()+y.GetName()
	})

	var rpc{{ pluralize $baseKind }} []*rpc_edge_v1.{{ $baseKind }}
	for _, {{ $kindLowerCamel }} := range {{ $base_group }}{{ $baseKind }}List {
		rpc{{ pluralize $baseKind}} = append(rpc{{ pluralize $baseKind}}, BuildRpc{{ $baseKind }}({{ $kindLowerCamel }}, &skv2v1.ObjectRef{
			Name:                 instance.GetName(),
			Namespace:            instance.GetNamespace(),
		}, instance.Spec.GetCluster()))
	}
	return rpc{{ pluralize $baseKind }}, nil
}

func BuildRpc{{ $baseKind }}({{ $kindLowerCamel }} *{{ $base_import_prefix }}.{{ $baseKind }}, glooInstance *skv2v1.ObjectRef, cluster string) *rpc_edge_v1.{{ $baseKind }} {
	m := &rpc_edge_v1.{{ $baseKind }}{
		Metadata: apiserverutils.ToMetadata({{ $kindLowerCamel }}.ObjectMeta),
		GlooInstance: glooInstance,
		Spec:     &{{ $kindLowerCamel }}.Spec,
		Status:   &{{ $kindLowerCamel }}.Status,
	}
	m.Metadata.ClusterName = cluster
	return m
}

func (k *fed{{ $base_Group }}ResourceHandler) Get{{ $baseKind }}Yaml(ctx context.Context, request *rpc_edge_v1.Get{{ $baseKind }}YamlRequest) (*rpc_edge_v1.Get{{ $baseKind }}YamlResponse, error) {
	{{ $base_group }}ClientSet, err := k.mc{{ $base_Group }}CRDClientset.Cluster(request.Get{{ $baseKind }}Ref().GetClusterName())
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to get {{ $base_group }} client set")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	{{ $kindLowerCamel }}, err := {{ $base_group }}ClientSet.{{ pluralize $baseKind }}().Get{{ $baseKind }}(ctx, client.ObjectKey{
		Namespace: request.Get{{ $baseKind }}Ref().GetNamespace(),
		Name:      request.Get{{ $baseKind }}Ref().GetName(),
	})
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to get {{ $kindLowerCamel }}")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	content, err := yaml.Marshal({{ $kindLowerCamel }})
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to marshal kube resource into yaml")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	return &rpc_edge_v1.Get{{ $baseKind }}YamlResponse{
		YamlData: &rpc_edge_v1.ResourceYaml{
            Yaml: string(content),
        },
	}, nil
}

func (k *fed{{ $base_Group }}ResourceHandler) Get{{ $baseKind }}Details(ctx context.Context, request *rpc_edge_v1.Get{{ $baseKind }}DetailsRequest) (*rpc_edge_v1.Get{{ $baseKind }}DetailsResponse, error) {
	{{ $baseKind }}Ref := request.Get{{ $baseKind }}Ref()
	if {{ $baseKind }}Ref == nil {
		return nil, eris.Errorf("{{ $baseKind }} ref missing from request: %v", request)
	}
	clientset, err := k.mc{{ $base_Group }}CRDClientset.Cluster({{ $baseKind }}Ref.GetClusterName())
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to get {{ $baseKind }} client set")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	{{ $baseKind }}, err := clientset.{{ pluralize $baseKind }}().Get{{ $baseKind }}(ctx, client.ObjectKey{
		Namespace: {{ $baseKind }}Ref.GetNamespace(),
		Name:      {{ $baseKind }}Ref.GetName(),
	})
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to get {{ $baseKind }}")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	// find which gloo instance this {{ $baseKind }} belongs to, by finding a gloo instance that is watching
	// the {{ $baseKind }}'s namespace
	instanceList, err := k.instanceClient.ListGlooInstance(ctx)
	if err != nil {
		wrapped := eris.Wrapf(err, "Failed to list gloo edge instances")
		contextutils.LoggerFrom(ctx).Errorw(wrapped.Error(), zap.Error(err), zap.Any("request", request))
		return nil, wrapped
	}
	var glooInstance *fedv1.GlooInstance;
	for _, instance := range instanceList.Items {
		watchedNamespaces := instance.Spec.GetControlPlane().GetWatchedNamespaces()
		if len(watchedNamespaces) == 0 {
			glooInstance = &instance
			break
		}
		for _, ns := range watchedNamespaces {
			if ns == {{ $baseKind }}Ref.GetNamespace() {
				glooInstance = &instance
				break
			}
		}
		if glooInstance != nil {
			break
		}
	}
	if glooInstance == nil {
		return nil, eris.Errorf("Failed to find a gloo edge instance for namespace %s", {{ $baseKind }}.GetNamespace())
	}
	rpc{{ $baseKind }} := &rpc_edge_v1.{{ $baseKind }}{
		Metadata:     apiserverutils.ToMetadata({{ $baseKind }}.ObjectMeta),
		GlooInstance: &skv2v1.ObjectRef{
			Name:      glooInstance.GetName(),
			Namespace: glooInstance.GetNamespace(),
		},
		Spec:         &{{ $baseKind }}.Spec,
		Status:       &{{ $baseKind }}.Status,
	}
	rpc{{ $baseKind }}.Metadata.ClusterName = glooInstance.Spec.GetCluster()
    return &rpc_edge_v1.Get{{ $baseKind }}DetailsResponse{
		{{ $baseKind }}: rpc{{ $baseKind }},
    }, nil
}

{{- end }}