package helpers

import (
	"github.com/golang/protobuf/ptypes/wrappers"
	v3 "github.com/solo-io/gloo/projects/gloo/pkg/api/external/envoy/config/core/v3"
	v1 "github.com/solo-io/gloo/projects/gloo/pkg/api/v1"
	"github.com/solo-io/gloo/projects/gloo/pkg/api/v1/core/matchers"
	"github.com/solo-io/gloo/projects/gloo/pkg/api/v1/gloosnapshot"
	v1static "github.com/solo-io/gloo/projects/gloo/pkg/api/v1/options/static"
	"github.com/solo-io/gloo/projects/gloo/pkg/api/v1/ssl"
	"github.com/solo-io/solo-kit/pkg/api/v1/resources/core"
)

// ScaleConfig enumerates the number of each type of resource that should be included in a snapshot as generated by
// ScaledSnapshot
// Additional fields should be added as needed
type ScaleConfig struct {
	Endpoints int
	Upstreams int
}

var upName = &core.Metadata{
	Name:      "test",
	Namespace: "gloo-system",
}

// Upstream is a generic upstream included in snapshots generated from ScaledSnapshot
var Upstream = &v1.Upstream{
	Metadata: upName,
	UpstreamType: &v1.Upstream_Static{
		Static: &v1static.UpstreamSpec{
			Hosts: []*v1static.Host{
				{
					Addr: "Test",
					Port: 124,
				},
			},
		},
	},
}

// Endpoint is a generic endpoint included in snapshots generated from ScaledSnapshot
var Endpoint = &v1.Endpoint{
	Upstreams: []*core.ResourceRef{upName.Ref()},
	Address:   "1.2.3.4",
	Port:      32,
	Metadata: &core.Metadata{
		Name:      "test-ep",
		Namespace: "gloo-system",
	},
}

var matcher = &matchers.Matcher{
	PathSpecifier: &matchers.Matcher_Prefix{
		Prefix: "/",
	},
}

var routes = []*v1.Route{{
	Name:     "testRouteName",
	Matchers: []*matchers.Matcher{matcher},
	Action: &v1.Route_RouteAction{
		RouteAction: &v1.RouteAction{
			Destination: &v1.RouteAction_Single{
				Single: &v1.Destination{
					DestinationType: &v1.Destination_Upstream{
						Upstream: upName.Ref(),
					},
				},
			},
		},
	},
}}
var virtualHostName = "virt1"

var httpListener = &v1.Listener{
	Name:        "http-listener",
	BindAddress: "127.0.0.1",
	BindPort:    80,
	ListenerType: &v1.Listener_HttpListener{
		HttpListener: &v1.HttpListener{
			VirtualHosts: []*v1.VirtualHost{{
				Name:    virtualHostName,
				Domains: []string{"*"},
				Routes:  routes,
			}},
		},
	},
}

// tcpListener invokes functions that contain assertions and therefore can only be invoked from within a test block
func tcpListener() *v1.Listener {
	return &v1.Listener{
		Name:        "tcp-listener",
		BindAddress: "127.0.0.1",
		BindPort:    8080,
		ListenerType: &v1.Listener_TcpListener{
			TcpListener: &v1.TcpListener{
				TcpHosts: []*v1.TcpHost{
					{
						Destination: &v1.TcpHost_TcpAction{
							Destination: &v1.TcpHost_TcpAction_Single{
								Single: &v1.Destination{
									DestinationType: &v1.Destination_Upstream{
										Upstream: &core.ResourceRef{
											Name:      "test",
											Namespace: "gloo-system",
										},
									},
								},
							},
						},
						SslConfig: &ssl.SslConfig{
							SslSecrets: &ssl.SslConfig_SslFiles{
								SslFiles: &ssl.SSLFiles{
									TlsCert: Certificate(),
									TlsKey:  PrivateKey(),
								},
							},
							SniDomains: []string{
								"sni1",
							},
						},
					},
				},
			},
		},
	}
}

// hybridListener invokes functions that contain assertions and therefore can only be invoked from within a test block
func hybridListener() *v1.Listener {
	return &v1.Listener{
		Name:        "hybrid-listener",
		BindAddress: "127.0.0.1",
		BindPort:    8888,
		ListenerType: &v1.Listener_HybridListener{
			HybridListener: &v1.HybridListener{
				MatchedListeners: []*v1.MatchedListener{
					{
						Matcher: &v1.Matcher{
							SslConfig: &ssl.SslConfig{
								SslSecrets: &ssl.SslConfig_SslFiles{
									SslFiles: &ssl.SSLFiles{
										TlsCert: Certificate(),
										TlsKey:  PrivateKey(),
									},
								},
								SniDomains: []string{
									"sni1",
								},
							},
							SourcePrefixRanges: []*v3.CidrRange{
								{
									AddressPrefix: "1.2.3.4",
									PrefixLen: &wrappers.UInt32Value{
										Value: 32,
									},
								},
							},
						},
						ListenerType: &v1.MatchedListener_TcpListener{
							TcpListener: &v1.TcpListener{
								TcpHosts: []*v1.TcpHost{
									{
										Destination: &v1.TcpHost_TcpAction{
											Destination: &v1.TcpHost_TcpAction_Single{
												Single: &v1.Destination{
													DestinationType: &v1.Destination_Upstream{
														Upstream: &core.ResourceRef{
															Name:      "test",
															Namespace: "gloo-system",
														},
													},
												},
											},
										},
										SslConfig: &ssl.SslConfig{
											SslSecrets: &ssl.SslConfig_SslFiles{
												SslFiles: &ssl.SSLFiles{
													TlsCert: Certificate(),
													TlsKey:  PrivateKey(),
												},
											},
											SniDomains: []string{
												"sni1",
											},
										},
									},
								},
							},
						},
					},
					{
						Matcher: &v1.Matcher{
							SslConfig: &ssl.SslConfig{
								SslSecrets: &ssl.SslConfig_SslFiles{
									SslFiles: &ssl.SSLFiles{
										TlsCert: Certificate(),
										TlsKey:  PrivateKey(),
									},
								},
								SniDomains: []string{
									"sni2",
								},
							},
							SourcePrefixRanges: []*v3.CidrRange{
								{
									AddressPrefix: "5.6.7.8",
									PrefixLen: &wrappers.UInt32Value{
										Value: 32,
									},
								},
							},
						},
						ListenerType: &v1.MatchedListener_HttpListener{
							HttpListener: &v1.HttpListener{
								VirtualHosts: []*v1.VirtualHost{{
									Name:    virtualHostName,
									Domains: []string{"*"},
									Routes:  routes,
								}},
							},
						},
					},
				},
			},
		},
	}
}

// Proxy returns a generic proxy that can be used for translation benchmarking
// Proxy invokes functions that contain assertions and therefore can only be invoked from within a test block
func Proxy() *v1.Proxy {
	return &v1.Proxy{
		Metadata: &core.Metadata{
			Name:      "test",
			Namespace: "gloo-system",
		},
		Listeners: []*v1.Listener{
			httpListener,
			tcpListener(),
			hybridListener(),
		},
	}
}

// ScaledSnapshot generates a snapshot populated with particular numbers of each resource types as determined by the
// passed config
func ScaledSnapshot(config ScaleConfig) *gloosnapshot.ApiSnapshot {
	endpointList := v1.EndpointList{}
	for i := 0; i < config.Endpoints; i++ {
		endpointList = append(endpointList, Endpoint)
	}

	upstreamList := v1.UpstreamList{}
	for i := 0; i < config.Upstreams; i++ {
		upstreamList = append(upstreamList, Upstream)
	}

	return &gloosnapshot.ApiSnapshot{
		Endpoints: endpointList,
		Upstreams: upstreamList,
	}
}
